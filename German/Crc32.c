/* This file was generated by the Hex-Rays decompiler.
   Copyright (c) 2007-2020 Hex-Rays <info@hex-rays.com>

   Detected compiler: Visual C++
*/

#include <windows.h>
#include <defs.h>


//-------------------------------------------------------------------------
// Function declarations

#define __thiscall __cdecl // Test compile in C mode

CFvCrc32 *__thiscall CFvCrc32::CFvCrc32(CFvCrc32 *this);
char __thiscall CFvCrc32::Crc32Mem(CFvCrc32 *this, unsigned __int8 *a2, unsigned int a3, unsigned int *a4);
char __thiscall CFvCrc32::Crc32MemCont(CFvCrc32 *this, unsigned __int8 *a2, unsigned int a3, unsigned int *a4);
char __thiscall CFvCrc32::Crc32MemContForASProtectSKE(CFvCrc32 *this, unsigned int a2, unsigned int a3, unsigned __int8 *a4, unsigned int *a5, unsigned int a6, unsigned int a7);
char __thiscall CFvCrc32::Crc32File(CFvCrc32 *this, LPCSTR lpFileName, unsigned int *a3);
char __thiscall CFvCrc32::Crc32FileRange(CFvCrc32 *this, LPCSTR lpFileName, LONG lDistanceToMove, unsigned int a4, unsigned int *a5);
char __thiscall CFvCrc32::Crc32FileRangeCont(CFvCrc32 *this, LPCSTR lpFileName, LONG lDistanceToMove, unsigned int a4, unsigned int *a5);
// BOOL __stdcall CloseHandle(HANDLE hObject);
// BOOL __stdcall ReadFile(HANDLE hFile, LPVOID lpBuffer, DWORD nNumberOfBytesToRead, LPDWORD lpNumberOfBytesRead, LPOVERLAPPED lpOverlapped);
// HANDLE __stdcall CreateFileA(LPCSTR lpFileName, DWORD dwDesiredAccess, DWORD dwShareMode, LPSECURITY_ATTRIBUTES lpSecurityAttributes, DWORD dwCreationDisposition, DWORD dwFlagsAndAttributes, HANDLE hTemplateFile);
// DWORD __stdcall SetFilePointer(HANDLE hFile, LONG lDistanceToMove, PLONG lpDistanceToMoveHigh, DWORD dwMoveMethod);


//----- (00000000) --------------------------------------------------------
CFvCrc32 *__thiscall CFvCrc32::CFvCrc32(CFvCrc32 *this)
{
  CFvCrc32 *result; // eax
  int v2; // esi
  CFvCrc32 *v3; // edi
  unsigned int v4; // edx
  int v5; // ebx

  result = this;
  v2 = 0;
  v3 = this;
  do
  {
    v4 = v2;
    v5 = 8;
    do
    {
      if ( (v4 & 1) != 0 )
        v4 = (v4 >> 1) ^ 0xEDB88320;
      else
        v4 >>= 1;
      --v5;
    }
    while ( v5 );
    *(_DWORD *)v3 = v4;
    ++v2;
    v3 = (CFvCrc32 *)((char *)v3 + 4);
  }
  while ( v2 < 256 );
  return result;
}

//----- (00000050) --------------------------------------------------------
char __thiscall CFvCrc32::Crc32Mem(CFvCrc32 *this, unsigned __int8 *a2, unsigned int a3, unsigned int *a4)
{
  *a4 = -1;
  CFvCrc32::Crc32MemCont(this, a2, a3, a4);
  *a4 = ~*a4;
  return 1;
}

//----- (00000080) --------------------------------------------------------
char __thiscall CFvCrc32::Crc32MemCont(CFvCrc32 *this, unsigned __int8 *a2, unsigned int a3, unsigned int *a4)
{
  unsigned __int8 *v4; // eax
  char result; // al
  unsigned int v7; // ecx

  v4 = a2;
  if ( a2 )
  {
    if ( a2 < &a2[a3] )
    {
      do
      {
        v7 = (*a4 >> 8) ^ *((_DWORD *)this + (*(unsigned __int8 *)a4 ^ *v4++));
        *a4 = v7;
      }
      while ( v4 < &a2[a3] );
    }
    result = 1;
  }
  else
  {
    *((_DWORD *)this + 256) = 1;
    result = 0;
  }
  return result;
}

//----- (000000D0) --------------------------------------------------------
char __thiscall CFvCrc32::Crc32MemContForASProtectSKE(CFvCrc32 *this, unsigned int a2, unsigned int a3, unsigned __int8 *a4, unsigned int *a5, unsigned int a6, unsigned int a7)
{
  unsigned __int8 *v7; // edx
  unsigned __int8 *v8; // eax
  bool v9; // cf
  int v11; // edi
  unsigned int v12; // eax
  int v13; // eax
  unsigned int v14; // ecx
  unsigned int v15; // eax
  unsigned __int8 *v18; // [esp+14h] [ebp-4h]
  unsigned int v19; // [esp+20h] [ebp+8h]
  unsigned __int8 *v20; // [esp+24h] [ebp+Ch]

  v7 = a4;
  v8 = &a4[a3];
  v9 = a4 < &a4[a3];
  v18 = &a4[a3];
  v20 = 0;
  v19 = 0;
  if ( v9 )
  {
    do
    {
      v11 = 1;
      if ( v7 + 5 > v8 )
        break;
      *a5 = (*a5 >> 8) ^ *((_DWORD *)this + (*(unsigned __int8 *)a5 ^ *v7));
      if ( *v7 == 0xE8 )
      {
        v12 = *(_DWORD *)(v7 + 1) + a2 + 5;
        if ( v12 < a6 || v12 > a7 )
        {
          if ( *(_WORD *)(v7 + 1) + (_WORD)a2 == 0xFFFB && !v20 )
            v20 = (unsigned __int8 *)(*(_DWORD *)(v7 + 1) + a2 + 5);
          if ( (((unsigned int)v20 ^ v12) & 0xFFFF0000) != 0 )
          {
            if ( (unsigned __int16)v12 == 4 )
              v11 = 6;
          }
          else
          {
            v11 = 6;
          }
        }
      }
      else if ( *v7 == 0xE9 )
      {
        v13 = *(_DWORD *)(v7 + 1);
        if ( v13 == 1 )
        {
          v14 = 0;
          v19 = 0;
        }
        else
        {
          v14 = v19;
        }
        v15 = v13 + a2 + 5;
        if ( v15 < a6 || v15 > a7 )
        {
          if ( !(_WORD)v15 && !v14 )
          {
            v14 = v15;
            v19 = v15;
          }
          if ( ((v14 ^ v15) & 0xFFFF0000) == 0 )
            v11 = 5;
        }
      }
      v8 = v18;
      v7 += v11;
      a2 += v11;
    }
    while ( v7 < v18 );
  }
  return 1;
}

//----- (000001F0) --------------------------------------------------------
char __thiscall CFvCrc32::Crc32File(CFvCrc32 *this, LPCSTR lpFileName, unsigned int *a3)
{
  HANDLE v4; // edi
  char result; // al
  char *v6; // ecx
  char *i; // eax
  unsigned int v8; // edx
  DWORD NumberOfBytesRead; // [esp+Ch] [ebp-1004h] BYREF
  char Buffer[4096]; // [esp+10h] [ebp-1000h] BYREF

  *a3 = -1;
  if ( lpFileName && *lpFileName )
  {
    v4 = CreateFileA(lpFileName, 0x80000000, 3u, 0, 3u, 0x80u, 0);
    if ( v4 == (HANDLE)-1 )
    {
      *((_DWORD *)this + 256) = 2;
      result = 0;
    }
    else
    {
      if ( ReadFile(v4, Buffer, 0x1000u, &NumberOfBytesRead, 0) )
      {
        while ( NumberOfBytesRead )
        {
          v6 = &Buffer[NumberOfBytesRead];
          for ( i = Buffer; i < v6; *a3 = v8 )
            v8 = (*a3 >> 8) ^ *((_DWORD *)this + ((unsigned __int8)*i++ ^ *(unsigned __int8 *)a3));
          if ( !ReadFile(v4, Buffer, 0x1000u, &NumberOfBytesRead, 0) )
            goto LABEL_12;
        }
      }
      else
      {
LABEL_12:
        *((_DWORD *)this + 256) = 3;
      }
      CloseHandle(v4);
      *a3 = ~*a3;
      result = 1;
    }
  }
  else
  {
    *((_DWORD *)this + 256) = 1;
    result = 0;
  }
  return result;
}
// 2CD: conditional instruction was optimized away because of 'eax.4!=0'

//----- (00000310) --------------------------------------------------------
char __thiscall CFvCrc32::Crc32FileRange(CFvCrc32 *this, LPCSTR lpFileName, LONG lDistanceToMove, unsigned int a4, unsigned int *a5)
{
  char result; // al

  *a5 = -1;
  CFvCrc32::Crc32FileRangeCont(this, lpFileName, lDistanceToMove, a4, a5);
  result = 1;
  *a5 = ~*a5;
  return result;
}

//----- (00000340) --------------------------------------------------------
char __thiscall CFvCrc32::Crc32FileRangeCont(CFvCrc32 *this, LPCSTR lpFileName, LONG lDistanceToMove, unsigned int a4, unsigned int *a5)
{
  CFvCrc32 *v5; // esi
  HANDLE v6; // ebx
  char result; // al
  BOOL v8; // eax
  char *v10; // ecx
  char *v11; // edx
  unsigned int v12; // eax
  BOOL v14; // [esp+Ch] [ebp-100Ch]
  DWORD NumberOfBytesRead; // [esp+10h] [ebp-1008h] BYREF
  HANDLE v16; // [esp+14h] [ebp-1004h]
  char Buffer[4096]; // [esp+18h] [ebp-1000h] BYREF

  v5 = this;
  if ( lpFileName && *lpFileName )
  {
    v6 = CreateFileA(lpFileName, 0x80000000, 3u, 0, 3u, 0x80u, 0);
    v16 = v6;
    if ( v6 == (HANDLE)-1 )
    {
      *((_DWORD *)v5 + 256) = 2;
      result = 0;
    }
    else if ( SetFilePointer(v6, lDistanceToMove, 0, 0) == -1 )
    {
      *((_DWORD *)v5 + 256) = 4;
      CloseHandle(v6);
      result = 0;
    }
    else
    {
      v8 = ReadFile(v6, Buffer, 0x1000u, &NumberOfBytesRead, 0);
      v14 = v8;
      if ( v8 )
      {
        while ( NumberOfBytesRead )
        {
          v10 = Buffer;
          if ( a4 <= NumberOfBytesRead )
          {
            v11 = &Buffer[a4];
            a4 = 0;
          }
          else
          {
            v11 = &Buffer[NumberOfBytesRead];
            a4 -= NumberOfBytesRead;
          }
          if ( Buffer < v11 )
          {
            do
            {
              v12 = (*a5 >> 8) ^ *((_DWORD *)this + (*(unsigned __int8 *)a5 ^ (unsigned __int8)*v10++));
              *a5 = v12;
            }
            while ( v10 < v11 );
            v6 = v16;
            v8 = v14;
          }
          if ( !a4 )
            break;
          v8 = ReadFile(v6, Buffer, 0x1000u, &NumberOfBytesRead, 0);
          v14 = v8;
          if ( !v8 )
            goto LABEL_19;
        }
        if ( v8 )
          goto LABEL_21;
LABEL_19:
        v5 = this;
      }
      *((_DWORD *)v5 + 256) = 3;
LABEL_21:
      CloseHandle(v6);
      result = 1;
    }
  }
  else
  {
    *((_DWORD *)this + 256) = 1;
    result = 0;
  }
  return result;
}

// nfuncs=13 queued=7 decompiled=7 lumina nreq=0 worse=0 better=0
// ALL OK, 7 function(s) have been successfully decompiled
