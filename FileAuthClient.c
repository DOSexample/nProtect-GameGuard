/* This file was generated by the Hex-Rays decompiler.
   Copyright (c) 2007-2020 Hex-Rays <info@hex-rays.com>

   Detected compiler: Visual C++
*/

#include <windows.h>
#include <Wincrypt.h>
#include "defs.h"


//-------------------------------------------------------------------------
// Function declarations

#define __thiscall __cdecl // Test compile in C mode

#define RC4_INT unsigned char

typedef struct rc4_key_st {
    RC4_INT x, y;
    RC4_INT data[256];
} RC4_KEY;


class CFileAuthClient
{
	HCRYPTPROV * CFileAuthClient(HCRYPTPROV *phProv);
	void ~CFileAuthClient();
	char Auth(HCRYPTPROV *phProv, LPCSTR lpFileNameToRead, bool a3);
	char Decrypt(CFileAuthClient *this, LPCSTR lpFileNameRead, LPCSTR outputfileNameToCreate, BYTE *pbData);
	char DecryptMem(CFileAuthClient *this, LPCSTR lpFileName, char *dstArray, unsigned int dstSize, BYTE *pbData);
	char DecryptRC4(CFileAuthClient *this, unsigned __int8 *a2, unsigned int a3);
};

HCRYPTPROV *__thiscall CFileAuthClient::CFileAuthClient(HCRYPTPROV *phProv);
void __thiscall CFileAuthClient::~CFileAuthClient(CFileAuthClient *__hidden this); // idb
char __thiscall CFileAuthClient::Auth(HCRYPTPROV *phProv, LPCSTR lpFileNameToRead, bool a3); // idb
char __thiscall CFileAuthClient::Decrypt(CFileAuthClient *this, LPCSTR lpFileNameRead, LPCSTR outputfileNameToCreate, BYTE *pbData); // idb
char __thiscall CFileAuthClient::DecryptMem(CFileAuthClient *this, LPCSTR lpFileName, char *dstArray, unsigned int dstSize, BYTE *pbData);
void __cdecl RC4_set_key(struct rc4_key_st *, int, unsigned __int8 *); // idb
void __cdecl RC4(struct rc4_key_st *, unsigned int, unsigned __int8 *, unsigned __int8 *); // idb
char __thiscall CFileAuthClient::DecryptRC4(CFileAuthClient *this, unsigned __int8 *a2, unsigned int a3);
// BOOL __stdcall CryptAcquireContextA(HCRYPTPROV *phProv, LPCSTR szContainer, LPCSTR szProvider, DWORD dwProvType, DWORD dwFlags);
// BOOL __stdcall CryptReleaseContext(HCRYPTPROV hProv, DWORD dwFlags);
// BOOL __stdcall CryptDestroyKey(HCRYPTKEY hKey);
// BOOL __stdcall CryptDestroyHash(HCRYPTHASH hHash);
// void __cdecl free(void *Block);
// int __cdecl _strnicmp(const char *String1, const char *String2, size_t MaxCount);
// char *__cdecl strrchr(const char *Str, int Ch);
// BOOL __stdcall CryptVerifySignatureA(HCRYPTHASH hHash, const BYTE *pbSignature, DWORD dwSigLen, HCRYPTKEY hPubKey, LPCSTR szDescription, DWORD dwFlags);
// BOOL __stdcall CryptHashData(HCRYPTHASH hHash, const BYTE *pbData, DWORD dwDataLen, DWORD dwFlags);
// BOOL __stdcall CryptCreateHash(HCRYPTPROV hProv, ALG_ID Algid, HCRYPTKEY hKey, DWORD dwFlags, HCRYPTHASH *phHash);
// DWORD __stdcall GetLastError();
// BOOL __stdcall CryptImportKey(HCRYPTPROV hProv, const BYTE *pbData, DWORD dwDataLen, HCRYPTKEY hPubKey, DWORD dwFlags, HCRYPTKEY *phKey);
// BOOL __stdcall ReadFile(HANDLE hFile, LPVOID lpBuffer, DWORD nNumberOfBytesToRead, LPDWORD lpNumberOfBytesRead, LPOVERLAPPED lpOverlapped);
// void *__cdecl malloc(size_t Size);
// BOOL __stdcall CloseHandle(HANDLE hObject);
// DWORD __stdcall GetFileSize(HANDLE hFile, LPDWORD lpFileSizeHigh);
// HANDLE __stdcall CreateFileA(LPCSTR lpFileName, DWORD dwDesiredAccess, DWORD dwShareMode, LPSECURITY_ATTRIBUTES lpSecurityAttributes, DWORD dwCreationDisposition, DWORD dwFlagsAndAttributes, HANDLE hTemplateFile);
// BOOL __stdcall FlushFileBuffers(HANDLE hFile);
// BOOL __stdcall SetEndOfFile(HANDLE hFile);
// BOOL __stdcall WriteFile(HANDLE hFile, LPCVOID lpBuffer, DWORD nNumberOfBytesToWrite, LPDWORD lpNumberOfBytesWritten, LPOVERLAPPED lpOverlapped);
// BOOL __stdcall CryptDecrypt(HCRYPTKEY hKey, HCRYPTHASH hHash, BOOL Final, DWORD dwFlags, BYTE *pbData, DWORD *pdwDataLen);
// BOOL __stdcall CryptDeriveKey(HCRYPTPROV hProv, ALG_ID Algid, HCRYPTHASH hBaseData, DWORD dwFlags, HCRYPTKEY *phKey);
// BOOL __stdcall CryptGetHashParam(HCRYPTHASH hHash, DWORD dwParam, BYTE *pbData, DWORD *pdwDataLen, DWORD dwFlags);

//-------------------------------------------------------------------------
// Data declarations

BYTE pbPubKey = 6u; // idb
_UNKNOWN unk_1; // weak
_UNKNOWN unk_40; // weak
DWORD dwPubKeyLen = 84u; // idb


//----- (00000058) --------------------------------------------------------
HCRYPTPROV *__thiscall CFileAuthClient::CFileAuthClient(HCRYPTPROV *phProv)
{
  phProv[5] = 0;
  phProv[3] = 0;
  *phProv = 0;
  phProv[1] = 0;
  phProv[2] = 0;
  phProv[9] = 0;
  phProv[14] = 0;
  phProv[16] = 0;
  phProv[15] = 0;
  phProv[6] = 0;
  *((_BYTE *)phProv + 28) = 0;
  phProv[8] = 0;
  phProv[17] = 0;
  phProv[4] = 0;
  if ( !CryptAcquireContextA(phProv, 0, "Microsoft Base Cryptographic Provider v1.0", PROV_RSA_FULL, CRYPT_VERIFYCONTEXT) )
    *phProv = 0;
  return phProv;
}

//----- (000000D4) --------------------------------------------------------
void __thiscall CFileAuthClient::~CFileAuthClient(CFileAuthClient *this)
{
  HCRYPTHASH v2; // eax
  void (__stdcall *v3)(HCRYPTHASH); // ebx
  HCRYPTKEY v4; // eax
  void (__stdcall *v5)(HCRYPTKEY); // edi
  HCRYPTPROV v6; // esi

  if ( *((_DWORD *)this + 1) )
    free(*((void **)this + 1));
  if ( *((_DWORD *)this + 5) )
    free(*((void **)this + 5));
  v2 = *((_DWORD *)this + 3);
  v3 = (void (__stdcall *)(HCRYPTHASH))CryptDestroyHash;
  if ( v2 )
    CryptDestroyHash(v2);
  v4 = *((_DWORD *)this + 4);
  v5 = (void (__stdcall *)(HCRYPTKEY))CryptDestroyKey;
  if ( v4 )
    CryptDestroyKey(v4);
  if ( *((_DWORD *)this + 15) )
    v5(*((_DWORD *)this + 15));
  if ( *((_DWORD *)this + 16) )
    v3(*((_DWORD *)this + 16));
  v6 = *(_DWORD *)this;
  if ( v6 )
    CryptReleaseContext(v6, 0);
}

//----- (00000144) --------------------------------------------------------
char __thiscall CFileAuthClient::Auth(HCRYPTPROV *phProv, LPCSTR lpFileNameToRead, bool a3)
{
  char result; // al
  HANDLE v5; // eax
  void *v6; // esi
  DWORD v7; // eax
  void *v8; // eax
  HCRYPTPROV v9; // eax
  HCRYPTPROV *v10; // edx
  HCRYPTPROV v11; // ecx
  HCRYPTPROV v12; // edx
  int v13; // edx
  void *v14; // eax
  void *v15; // eax
  HCRYPTPROV *v16; // edi
  BOOL (__stdcall *v17)(HCRYPTPROV, const BYTE *, DWORD, HCRYPTKEY, DWORD, HCRYPTKEY *); // esi
  HCRYPTPROV *v18; // esi
  char *v19; // eax
  const char *v20; // eax
  DWORD NumberOfBytesRead; // [esp+10h] [ebp-4h] BYREF

  if ( !lpFileNameToRead )
  {
    phProv[17] = 1;
    return 0;
  }
  if ( !*lpFileNameToRead )
  {
    phProv[17] = 2;
    return 0;
  }
  v5 = CreateFileA(lpFileNameToRead, GENERIC_READ, 3u, 0, 3u, 0x80u, 0);
  v6 = v5;
  if ( v5 == (HANDLE)-1 )
  {
    phProv[17] = 3;
    return 0;
  }
  v7 = GetFileSize(v5, 0);
  phProv[9] = v7;
  if ( v7 == -1 )
  {
    CloseHandle(v6);
    phProv[17] = 33;
    return 0;
  }
  if ( phProv[1] )
  {
    free((void *)phProv[1]);
    phProv[1] = 0;
  }
  v8 = malloc(phProv[9]);
  phProv[1] = (HCRYPTPROV)v8;
  if ( !v8 )
  {
    CloseHandle(v6);
    phProv[17] = 4;
    return 0;
  }
  ReadFile(v6, v8, phProv[9], &NumberOfBytesRead, 0);
  v9 = phProv[9];
  if ( NumberOfBytesRead != v9 )
  {
    CloseHandle(v6);
    phProv[17] = 5;
    return 0;
  }
  v10 = (HCRYPTPROV *)(phProv[1] + v9 - 16);
  phProv[10] = *v10;
  phProv[11] = v10[1];
  phProv[12] = v10[2];
  phProv[13] = v10[3];
  if ( phProv[10] == 0x32812622 && phProv[13] == 847324705 )
  {
    v11 = phProv[11];
    v12 = phProv[12];
    *((_BYTE *)phProv + 28) = 1;
    v13 = v12 + v11 + 16;
    phProv[14] = v11;
    phProv[8] = v13;
    phProv[2] = v9 - v13;
  }
  else
  {
    phProv[10] = 0;
    phProv[11] = 0;
    phProv[12] = 0;
    phProv[13] = 0;
    v9 = phProv[9];
    *((_BYTE *)phProv + 28) = 0;
    phProv[8] = 0;
    phProv[2] = v9;
    phProv[14] = 0;
  }
  if ( v9 < phProv[8] )
  {
    *((_BYTE *)phProv + 28) = 0;
    phProv[8] = 0;
    phProv[9] = 0;
    phProv[2] = 0;
    phProv[14] = 0;
  }
  CloseHandle(v6);
  if ( !*((_BYTE *)phProv + 28) )
  {
    phProv[17] = 6;
    return 0;
  }
  v14 = (void *)phProv[5];
  phProv[6] = phProv[12];
  if ( v14 )
  {
    free(v14);
    phProv[5] = 0;
  }
  v15 = malloc(phProv[6]);
  phProv[5] = (HCRYPTPROV)v15;
  if ( !v15 )
  {
    phProv[17] = 7;
    return 0;
  }
  qmemcpy(v15, (const void *)(phProv[14] + phProv[1] + phProv[2]), phProv[6]);
  if ( !*phProv && !CryptAcquireContextA(phProv, 0, "Microsoft Base Cryptographic Provider v1.0", PROV_RSA_FULL, CRYPT_VERIFYCONTEXT) )
  {
    phProv[17] = 8;
    return 0;
  }
  v16 = phProv + 4;
  if ( phProv[4] )
  {
    CryptDestroyKey(phProv[4]);
    *v16 = 0;
  }
  v17 = CryptImportKey;
  if ( !CryptImportKey(*phProv, &pbPubKey, dwPubKeyLen, 0, 0, phProv + 4) )
  {
    if ( GetLastError() != 87 )
      goto LABEL_37;
    if ( !CryptAcquireContextA(phProv, 0, "Microsoft Base Cryptographic Provider v1.0", PROV_RSA_FULL, CRYPT_VERIFYCONTEXT) )
    {
      phProv[17] = 98;
      return 0;
    }
    if ( !v17(*phProv, &pbPubKey, dwPubKeyLen, 0, 0, phProv + 4) )
    {
LABEL_37:
      phProv[17] = 9;
      return 0;
    }
  }
  v18 = phProv + 3;
  if ( phProv[3] )
  {
    CryptDestroyHash(phProv[3]);
    *v18 = 0;
  }
  if ( !CryptCreateHash(*phProv, CALG_MD5, 0, 0, phProv + 3) )
  {
    phProv[17] = 10;
    return 0;
  }
  if ( !CryptHashData(*v18, (const BYTE *)phProv[1], phProv[14] + phProv[2], 0) )
  {
    phProv[17] = 11;
    return 0;
  }
  if ( CryptVerifySignatureA(*v18, (const BYTE *)phProv[5], phProv[6], *v16, 0, 0) )
    goto LABEL_61;
  if ( GetLastError() != 87 )
    goto LABEL_49;
  if ( !CryptAcquireContextA(phProv, 0, "Microsoft Base Cryptographic Provider v1.0", PROV_RSA_FULL, CRYPT_VERIFYCONTEXT) )
  {
    phProv[17] = 128;
    return 0;
  }
  if ( CryptVerifySignatureA(*v18, (const BYTE *)phProv[5], phProv[6], *v16, 0, 0) )
  {
LABEL_61:
    if ( !a3
      || ((v19 = strrchr(lpFileNameToRead, '\\')) == 0 ? (v20 = lpFileNameToRead) : (v20 = v19 + 1),
          !_strnicmp(v20, (const char *)(phProv[1] + phProv[2]), phProv[14])) )
    {
      if ( phProv[1] )
      {
        free((void *)phProv[1]);
        phProv[1] = 0;
      }
      result = 1;
    }
    else
    {
      phProv[17] = 13;
      result = 0;
    }
  }
  else
  {
LABEL_49:
    phProv[17] = 12;
    result = 0;
  }
  return result;
}

//----- (00000554) --------------------------------------------------------
char __thiscall CFileAuthClient::Decrypt(CFileAuthClient *this, LPCSTR lpFileNameRead, LPCSTR outputfileNameToCreate, BYTE *pbData)
{
  HANDLE v5; // eax
  void *v6; // edi
  char result; // al
  DWORD v8; // eax
  void *v9; // eax
  unsigned int v10; // eax
  _DWORD *v11; // edx
  int v12; // ecx
  int v13; // edx
  int v14; // edx
  HCRYPTHASH *v15; // ebp
  HCRYPTKEY *v16; // edi
  BYTE *v17; // ecx
  HANDLE v18; // edi
  DWORD NumberOfBytesRead; // [esp+10h] [ebp-4h] BYREF

  v5 = CreateFileA(lpFileNameRead, GENERIC_READ, 3u, 0, 3u, 0x80u, 0);
  v6 = v5;
  if ( v5 == (HANDLE)-1 )
  {
    *((_DWORD *)this + 17) = 1;
    return 0;
  }
  v8 = GetFileSize(v5, 0);
  *((_DWORD *)this + 9) = v8;
  if ( v8 == -1 )
  {
    CloseHandle(v6);
    *((_DWORD *)this + 17) = 11;
    return 0;
  }
  if ( *((_DWORD *)this + 1) )
  {
    free(*((void **)this + 1));
    *((_DWORD *)this + 1) = 0;
  }
  v9 = malloc(*((_DWORD *)this + 9));
  *((_DWORD *)this + 1) = v9;
  if ( !v9 )
  {
    CloseHandle(v6);
    *((_DWORD *)this + 17) = 2;
    return 0;
  }
  ReadFile(v6, v9, *((_DWORD *)this + 9), &NumberOfBytesRead, 0);
  v10 = *((_DWORD *)this + 9);
  if ( NumberOfBytesRead != v10 )
  {
    CloseHandle(v6);
    *((_DWORD *)this + 17) = 3;
    return 0;
  }
  v11 = (_DWORD *)(*((_DWORD *)this + 1) + v10 - 16);
  *((_DWORD *)this + 10) = *v11;
  *((_DWORD *)this + 11) = v11[1];
  *((_DWORD *)this + 12) = v11[2];
  *((_DWORD *)this + 13) = v11[3];
  if ( *((_DWORD *)this + 10) == 847324706 && *((_DWORD *)this + 13) == 847324705 )
  {
    v12 = *((_DWORD *)this + 11);
    v13 = *((_DWORD *)this + 12);
    *((_BYTE *)this + 28) = 1;
    v14 = v13 + v12 + 16;
    *((_DWORD *)this + 14) = v12;
    *((_DWORD *)this + 8) = v14;
    *((_DWORD *)this + 2) = v10 - v14;
  }
  else
  {
    *((_DWORD *)this + 10) = 0;
    *((_DWORD *)this + 11) = 0;
    *((_DWORD *)this + 12) = 0;
    *((_DWORD *)this + 13) = 0;
    v10 = *((_DWORD *)this + 9);
    *((_BYTE *)this + 28) = 0;
    *((_DWORD *)this + 8) = 0;
    *((_DWORD *)this + 2) = v10;
    *((_DWORD *)this + 14) = 0;
  }
  if ( v10 < *((_DWORD *)this + 8) )
  {
    *((_BYTE *)this + 28) = 0;
    *((_DWORD *)this + 8) = 0;
    *((_DWORD *)this + 9) = 0;
    *((_DWORD *)this + 2) = 0;
    *((_DWORD *)this + 14) = 0;
  }
  CloseHandle(v6);
  if ( !*(_DWORD *)this
    && !CryptAcquireContextA(
          (HCRYPTPROV *)this,
          0,
          "Microsoft Base Cryptographic Provider v1.0",
          PROV_RSA_FULL,
          CRYPT_VERIFYCONTEXT) )
  {
    *((_DWORD *)this + 17) = 4;
    return 0;
  }
  v15 = (HCRYPTHASH *)((char *)this + 64);
  if ( *((_DWORD *)this + 16) )
  {
    CryptDestroyHash(*((_DWORD *)this + 16));
    *v15 = 0;
  }
  if ( !CryptCreateHash(*(_DWORD *)this, CALG_MD5, 0, 0, (HCRYPTHASH *)this + 16) )
  {
    *((_DWORD *)this + 17) = 5;
    return 0;
  }
  if ( !CryptHashData(*v15, pbData, strlen((const char *)pbData), 0) )
  {
    *((_DWORD *)this + 17) = 6;
    return 0;
  }
  v16 = (HCRYPTKEY *)((char *)this + 60);
  if ( *((_DWORD *)this + 15) )
  {
    CryptDestroyKey(*((_DWORD *)this + 15));
    *v16 = 0;
  }
  if ( !CryptDeriveKey(*(_DWORD *)this, CALG_RC4, *v15, 0, (HCRYPTKEY *)this + 15) )
  {
    *((_DWORD *)this + 17) = 7;
    return 0;
  }
  v17 = (BYTE *)*((_DWORD *)this + 1);
  lpFileNameRead = (LPCSTR)*((_DWORD *)this + 2);
  if ( CryptDecrypt(*v16, 0, 1, 0, v17, (DWORD *)&lpFileNameRead) )
    goto LABEL_35;
  if ( GetLastError() != (unsigned int)NTE_PERM )
  {
    *((_DWORD *)this + 17) = 8;
    return 0;
  }
  result = CFileAuthClient::DecryptRC4(this, *((unsigned __int8 **)this + 1), (unsigned int)lpFileNameRead);
  if ( result )
  {
LABEL_35:
    v18 = CreateFileA(outputfileNameToCreate, GENERIC_WRITE, 3u, 0, 2u, 0x80u, 0);
    if ( v18 == (HANDLE)-1 )
    {
      *((_DWORD *)this + 17) = 9;
      result = 0;
    }
    else
    {
      WriteFile(v18, *((LPCVOID *)this + 1), *((_DWORD *)this + 2), (LPDWORD)&lpFileNameRead, 0);
      SetEndOfFile(v18);
      FlushFileBuffers(v18);
      CloseHandle(v18);
      if ( *((_DWORD *)this + 1) )
      {
        free(*((void **)this + 1));
        *((_DWORD *)this + 1) = 0;
      }
      result = 1;
    }
  }
  else
  {
    *((_DWORD *)this + 17) = 88;
  }
  return result;
}

//----- (00000874) --------------------------------------------------------
char __thiscall CFileAuthClient::DecryptMem(CFileAuthClient *this, LPCSTR lpFileName, char *dstArray, unsigned int dstSize, BYTE *pbData)
{
  HANDLE v6; // eax
  void *v7; // esi
  char result; // al
  DWORD v9; // eax
  void *v10; // eax
  unsigned int v11; // eax
  _DWORD *v12; // edx
  int v13; // ecx
  int v14; // edx
  int v15; // edx
  HCRYPTHASH *v16; // ebx
  HCRYPTKEY *v17; // esi
  BYTE *v18; // ecx
  unsigned int v19; // eax
  char *v20; // edx
  DWORD NumberOfBytesRead; // [esp+10h] [ebp-4h] BYREF

  v6 = CreateFileA(lpFileName, GENERIC_READ, 3u, 0, 3u, 0x80u, 0);
  v7 = v6;
  if ( v6 == (HANDLE)-1 )
  {
    *((_DWORD *)this + 17) = 1;
    return 0;
  }
  v9 = GetFileSize(v6, 0);
  *((_DWORD *)this + 9) = v9;
  if ( v9 == -1 )
  {
    CloseHandle(v7);
    *((_DWORD *)this + 17) = 11;
    return 0;
  }
  if ( *((_DWORD *)this + 1) )
  {
    free(*((void **)this + 1));
    *((_DWORD *)this + 1) = 0;
  }
  v10 = malloc(*((_DWORD *)this + 9));
  *((_DWORD *)this + 1) = v10;
  if ( !v10 )
  {
    CloseHandle(v7);
    *((_DWORD *)this + 17) = 2;
    return 0;
  }
  ReadFile(v7, v10, *((_DWORD *)this + 9), &NumberOfBytesRead, 0);
  v11 = *((_DWORD *)this + 9);
  if ( NumberOfBytesRead != v11 )
  {
    CloseHandle(v7);
    *((_DWORD *)this + 17) = 3;
    return 0;
  }
  v12 = (_DWORD *)(*((_DWORD *)this + 1) + v11 - 16);
  *((_DWORD *)this + 10) = *v12;
  *((_DWORD *)this + 11) = v12[1];
  *((_DWORD *)this + 12) = v12[2];
  *((_DWORD *)this + 13) = v12[3];
  if ( *((_DWORD *)this + 10) == 847324706 && *((_DWORD *)this + 13) == 847324705 )
  {
    v13 = *((_DWORD *)this + 11);
    v14 = *((_DWORD *)this + 12);
    *((_BYTE *)this + 28) = 1;
    v15 = v14 + v13 + 16;
    *((_DWORD *)this + 14) = v13;
    *((_DWORD *)this + 8) = v15;
    *((_DWORD *)this + 2) = v11 - v15;
  }
  else
  {
    *((_DWORD *)this + 10) = 0;
    *((_DWORD *)this + 11) = 0;
    *((_DWORD *)this + 12) = 0;
    *((_DWORD *)this + 13) = 0;
    *((_BYTE *)this + 28) = 0;
    v11 = *((_DWORD *)this + 9);
    *((_DWORD *)this + 8) = 0;
    *((_DWORD *)this + 2) = v11;
    *((_DWORD *)this + 14) = 0;
  }
  if ( v11 < *((_DWORD *)this + 8) )
  {
    *((_BYTE *)this + 28) = 0;
    *((_DWORD *)this + 8) = 0;
    *((_DWORD *)this + 9) = 0;
    *((_DWORD *)this + 2) = 0;
    *((_DWORD *)this + 14) = 0;
  }
  CloseHandle(v7);
  if ( !*(_DWORD *)this
    && !CryptAcquireContextA((HCRYPTPROV *)this, 0, "Microsoft Base Cryptographic Provider v1.0", PROV_RSA_FULL, CRYPT_VERIFYCONTEXT) )
  {
    *((_DWORD *)this + 17) = 4;
    return 0;
  }
  v16 = (HCRYPTHASH *)((char *)this + 64);
  if ( *((_DWORD *)this + 16) )
  {
    CryptDestroyHash(*((_DWORD *)this + 16));
    *v16 = 0;
  }
  if ( !CryptCreateHash(*(_DWORD *)this, CALG_MD5, 0, 0, (HCRYPTHASH *)this + 16) )
  {
    *((_DWORD *)this + 17) = 5;
    return 0;
  }
  if ( !CryptHashData(*v16, pbData, strlen((const char *)pbData), 0) )
  {
    *((_DWORD *)this + 17) = 6;
    return 0;
  }
  v17 = (HCRYPTKEY *)((char *)this + 60);
  if ( *((_DWORD *)this + 15) )
  {
    CryptDestroyKey(*((_DWORD *)this + 15));
    *v17 = 0;
  }
  if ( !CryptDeriveKey(*(_DWORD *)this, 0x6801u, *v16, 0, (HCRYPTKEY *)this + 15) )
  {
    *((_DWORD *)this + 17) = 7;
    return 0;
  }
  v18 = (BYTE *)*((_DWORD *)this + 1);
  lpFileName = (LPCSTR)*((_DWORD *)this + 2);   // Size, length to decrypt or whatever
  if ( CryptDecrypt(*v17, 0, 1, 0, v18, (DWORD *)&lpFileName) )
    goto LABEL_35;
  if ( GetLastError() != (unsigned int)NTE_PERM )
  {
    *((_DWORD *)this + 17) = 8;
    return 0;
  }
  result = CFileAuthClient::DecryptRC4(this, *((unsigned __int8 **)this + 1), (unsigned int)lpFileName);
  if ( result )
  {
LABEL_35:
    v19 = dstSize;
    if ( dstSize > *((_DWORD *)this + 2) )
      v19 = *((_DWORD *)this + 2);
    v20 = dstArray;
    qmemcpy(dstArray, *((const void **)this + 1), v19);
    v20[v19] = 0;
    if ( *((_DWORD *)this + 1) )
    {
      free(*((void **)this + 1));
      *((_DWORD *)this + 1) = 0;
    }
    result = 1;
  }
  else
  {
    *((_DWORD *)this + 17) = 88;
  }
  return result;
}

//----- (00000B74) --------------------------------------------------------
void __cdecl RC4_set_key(struct rc4_key_st *a1, int a2, unsigned __int8 *a3)
{
  char *v3; // esi
  char v4; // di
  unsigned int v5; // eax
  DWORD *v6; // ecx
  int v7; // eax
  int *v8; // ecx
  int v9; // edx
  int v10; // ebx
  int v11; // eax
  int v12; // edx
  int v13; // ebx
  int v14; // eax
  int v15; // edx
  int v16; // ebx
  int v17; // eax
  int v18; // edx
  int v19; // ebx
  struct rc4_key_st *v20; // [esp+14h] [ebp+4h]

  v3 = (char *)a1 + 8;
  v4 = 0;
  v5 = 0;
  v6 = (DWORD *)((char *)a1 + 8);
  do
    *v6++ = v5++;
  while ( v5 < 0x100 );
  *(DWORD *)a1 = 0;
  *((DWORD *)a1 + 1) = 0;
  v7 = 0;
  v8 = (int *)((char *)a1 + 16);
  v20 = (struct rc4_key_st *)&unk_40;
  do
  {
    v9 = *(v8 - 2);
    v10 = (unsigned __int8)(v4 + v9 + a3[v7]);
    v11 = v7 + 1;
    if ( v11 == a2 )
      v11 = 0;
    *(v8 - 2) = *(DWORD *)&v3[4 * v10];
    *(DWORD *)&v3[4 * v10] = v9;
    v12 = *(v8 - 1);
    v13 = (unsigned __int8)(v10 + v12 + a3[v11]);
    v14 = v11 + 1;
    if ( v14 == a2 )
      v14 = 0;
    *(v8 - 1) = *(DWORD *)&v3[4 * v13];
    *(DWORD *)&v3[4 * v13] = v12;
    v15 = *v8;
    v16 = (unsigned __int8)(v13 + *v8 + a3[v14]);
    v17 = v14 + 1;
    if ( v17 == a2 )
      v17 = 0;
    *v8 = *(DWORD *)&v3[4 * v16];
    *(DWORD *)&v3[4 * v16] = v15;
    v18 = v8[1];
    v19 = (unsigned __int8)(v16 + v18 + a3[v17]);
    v7 = v17 + 1;
    v4 = v19;
    if ( v7 == a2 )
      v7 = 0;
    v8[1] = *(DWORD *)&v3[4 * v19];
    *(DWORD *)&v3[4 * v19] = v18;
    v8 += 4;
    v20 = (struct rc4_key_st *)((char *)v20 - 1);
  }
  while ( v20 );
}

//----- (00000C64) --------------------------------------------------------
void __cdecl RC4(struct rc4_key_st *a1, unsigned int a2, unsigned __int8 *a3, unsigned __int8 *a4)
{
  char v4; // dl
  int v6; // ebp
  int v7; // edi
  int v8; // edi
  int v9; // ecx
  int v10; // ebp
  int v11; // edx
  int v12; // edi
  int v13; // edx
  int v14; // ebp
  int v15; // ebx
  int v16; // edi
  int v17; // edx
  int v18; // ebp
  int v19; // ebx
  int v20; // edi
  int v21; // edx
  int v22; // ebp
  int v23; // ebx
  int v24; // edi
  int v25; // edx
  int v26; // ebp
  int v27; // ebx
  int v28; // edi
  int v29; // edx
  int v30; // ebp
  int v31; // ebx
  int v32; // edi
  int v33; // edx
  int v34; // ebp
  int v35; // ebx
  int v36; // edx
  int v37; // ebx
  unsigned __int8 *v38; // ecx
  unsigned __int8 *v39; // esi
  int v40; // edi
  int v41; // edx
  int v42; // ebp
  int v43; // ebx
  BYTE *v44; // ecx
  BYTE *v45; // esi
  int v46; // edi
  int v47; // edx
  int v48; // ebp
  int v49; // ebx
  int v50; // edi
  int v51; // edx
  int v52; // ebp
  int v53; // ebx
  int v54; // edi
  int v55; // edx
  int v56; // ebp
  int v57; // ebx
  int v58; // edi
  int v59; // edx
  int v60; // ebp
  int v61; // ebx
  int v62; // edi
  int v63; // edx
  int v64; // ebp
  int v65; // ebx
  int v66; // edi
  int v67; // edx
  int v68; // ebp
  int v69; // ebx
  int v70; // edx
  int v71; // ebx
  int v72; // edx
  int v73; // ebx
  BYTE *v74; // ecx
  BYTE *v75; // esi
  int v76; // edx
  int v77; // ebx
  BYTE *v78; // ecx
  BYTE *v79; // esi
  int v80; // edx
  int v81; // ebx
  BYTE *v82; // ecx
  BYTE *v83; // esi
  int v84; // edx
  int v85; // ebx
  BYTE *v86; // ecx
  BYTE *v87; // esi
  int v88; // edx
  int v89; // ebx
  BYTE *v90; // ecx
  BYTE *v91; // esi
  int v92; // edx
  int v93; // ebx
  BYTE *v94; // ecx
  BYTE *v95; // esi
  int v96; // edx
  int v97; // ebx
  BYTE *v98; // ecx
  BYTE *v99; // esi
  int v100; // edx
  int v101; // ebx
  struct rc4_key_st *v102; // [esp+14h] [ebp+4h]
  struct rc4_key_st *v103; // [esp+14h] [ebp+4h]
  struct rc4_key_st *i; // [esp+14h] [ebp+4h]
  struct rc4_key_st *v105; // [esp+14h] [ebp+4h]
  struct rc4_key_st *v106; // [esp+14h] [ebp+4h]
  struct rc4_key_st *v107; // [esp+14h] [ebp+4h]
  struct rc4_key_st *v108; // [esp+14h] [ebp+4h]
  struct rc4_key_st *v109; // [esp+14h] [ebp+4h]
  struct rc4_key_st *v110; // [esp+14h] [ebp+4h]
  unsigned __int8 *v111; // [esp+20h] [ebp+10h]

  v4 = a2;
  v6 = *((DWORD *)a1 + 1);
  v7 = *(DWORD *)a1;
  v102 = (struct rc4_key_st *)(a2 >> 3);
  if ( a2 >> 3 )
  {
    v8 = (unsigned __int8)(v7 + 1);
    v9 = *((DWORD *)a1 + v8 + 2);
    v10 = (unsigned __int8)(v9 + v6);
    v11 = *((DWORD *)a1 + v10 + 2);
    *((DWORD *)a1 + v8 + 2) = v11;
    *((DWORD *)a1 + v10 + 2) = v9;
    *a4 = *a3 ^ *((BYTE *)a1 + 4 * (unsigned __int8)(v9 + v11) + 8);
    v12 = (unsigned __int8)(v8 + 1);
    v13 = *((DWORD *)a1 + v12 + 2);
    v14 = (unsigned __int8)(v13 + v10);
    v15 = *((DWORD *)a1 + v14 + 2);
    *((DWORD *)a1 + v12 + 2) = v15;
    *((DWORD *)a1 + v14 + 2) = v13;
    a4[1] = a3[1] ^ *((BYTE *)a1 + 4 * (unsigned __int8)(v13 + v15) + 8);
    v16 = (unsigned __int8)(v12 + 1);
    v17 = *((DWORD *)a1 + v16 + 2);
    v18 = (unsigned __int8)(v17 + v14);
    v19 = *((DWORD *)a1 + v18 + 2);
    *((DWORD *)a1 + v16 + 2) = v19;
    *((DWORD *)a1 + v18 + 2) = v17;
    a4[2] = a3[2] ^ *((BYTE *)a1 + 4 * (unsigned __int8)(v17 + v19) + 8);
    v20 = (unsigned __int8)(v16 + 1);
    v21 = *((DWORD *)a1 + v20 + 2);
    v22 = (unsigned __int8)(v21 + v18);
    v23 = *((DWORD *)a1 + v22 + 2);
    *((DWORD *)a1 + v20 + 2) = v23;
    *((DWORD *)a1 + v22 + 2) = v21;
    a4[3] = a3[3] ^ *((BYTE *)a1 + 4 * (unsigned __int8)(v21 + v23) + 8);
    v24 = (unsigned __int8)(v20 + 1);
    v25 = *((DWORD *)a1 + v24 + 2);
    v26 = (unsigned __int8)(v25 + v22);
    v27 = *((DWORD *)a1 + v26 + 2);
    *((DWORD *)a1 + v24 + 2) = v27;
    *((DWORD *)a1 + v26 + 2) = v25;
    a4[4] = a3[4] ^ *((BYTE *)a1 + 4 * (unsigned __int8)(v25 + v27) + 8);
    v28 = (unsigned __int8)(v24 + 1);
    v29 = *((DWORD *)a1 + v28 + 2);
    v30 = (unsigned __int8)(v29 + v26);
    v31 = *((DWORD *)a1 + v30 + 2);
    *((DWORD *)a1 + v28 + 2) = v31;
    *((DWORD *)a1 + v30 + 2) = v29;
    a4[5] = a3[5] ^ *((BYTE *)a1 + 4 * (unsigned __int8)(v29 + v31) + 8);
    v32 = (unsigned __int8)(v28 + 1);
    v33 = *((DWORD *)a1 + v32 + 2);
    v34 = (unsigned __int8)(v33 + v30);
    v35 = *((DWORD *)a1 + v34 + 2);
    *((DWORD *)a1 + v32 + 2) = v35;
    *((DWORD *)a1 + v34 + 2) = v33;
    a4[6] = a3[6] ^ *((BYTE *)a1 + 4 * (unsigned __int8)(v33 + v35) + 8);
    v7 = (unsigned __int8)(v32 + 1);
    v36 = *((DWORD *)a1 + v7 + 2);
    v6 = (unsigned __int8)(v36 + v34);
    v37 = *((DWORD *)a1 + v6 + 2);
    *((DWORD *)a1 + v7 + 2) = v37;
    *((DWORD *)a1 + v6 + 2) = v36;
    a4[7] = a3[7] ^ *((BYTE *)a1 + 4 * (unsigned __int8)(v36 + v37) + 8);
    v38 = a4 + 8;
    v39 = a3 + 8;
    if ( v102 != (struct rc4_key_st *)&unk_1 )
    {
      v111 = (unsigned __int8 *)v102 - 1;
      do
      {
        v40 = (unsigned __int8)(v7 + 1);
        v41 = *((DWORD *)a1 + v40 + 2);
        v42 = (unsigned __int8)(v41 + v6);
        v43 = *((DWORD *)a1 + v42 + 2);
        *((DWORD *)a1 + v40 + 2) = v43;
        *((DWORD *)a1 + v42 + 2) = v41;
        *v38 = *v39 ^ *((BYTE *)a1 + 4 * (unsigned __int8)(v41 + v43) + 8);
        v44 = v38 + 1;
        v45 = v39 + 1;
        v46 = (unsigned __int8)(v40 + 1);
        v47 = *((DWORD *)a1 + v46 + 2);
        v48 = (unsigned __int8)(v47 + v42);
        v49 = *((DWORD *)a1 + v48 + 2);
        *((DWORD *)a1 + v46 + 2) = v49;
        *((DWORD *)a1 + v48 + 2) = v47;
        *v44++ = *v45++ ^ *((BYTE *)a1 + 4 * (unsigned __int8)(v47 + v49) + 8);
        v50 = (unsigned __int8)(v46 + 1);
        v51 = *((DWORD *)a1 + v50 + 2);
        v52 = (unsigned __int8)(v51 + v48);
        v53 = *((DWORD *)a1 + v52 + 2);
        *((DWORD *)a1 + v50 + 2) = v53;
        *((DWORD *)a1 + v52 + 2) = v51;
        *v44++ = *v45++ ^ *((BYTE *)a1 + 4 * (unsigned __int8)(v51 + v53) + 8);
        v54 = (unsigned __int8)(v50 + 1);
        v55 = *((DWORD *)a1 + v54 + 2);
        v56 = (unsigned __int8)(v55 + v52);
        v57 = *((DWORD *)a1 + v56 + 2);
        *((DWORD *)a1 + v54 + 2) = v57;
        *((DWORD *)a1 + v56 + 2) = v55;
        *v44++ = *v45++ ^ *((BYTE *)a1 + 4 * (unsigned __int8)(v55 + v57) + 8);
        v58 = (unsigned __int8)(v54 + 1);
        v59 = *((DWORD *)a1 + v58 + 2);
        v60 = (unsigned __int8)(v59 + v56);
        v61 = *((DWORD *)a1 + v60 + 2);
        *((DWORD *)a1 + v58 + 2) = v61;
        *((DWORD *)a1 + v60 + 2) = v59;
        *v44++ = *v45++ ^ *((BYTE *)a1 + 4 * (unsigned __int8)(v59 + v61) + 8);
        v62 = (unsigned __int8)(v58 + 1);
        v63 = *((DWORD *)a1 + v62 + 2);
        v64 = (unsigned __int8)(v63 + v60);
        v65 = *((DWORD *)a1 + v64 + 2);
        *((DWORD *)a1 + v62 + 2) = v65;
        *((DWORD *)a1 + v64 + 2) = v63;
        *v44++ = *v45++ ^ *((BYTE *)a1 + 4 * (unsigned __int8)(v63 + v65) + 8);
        v66 = (unsigned __int8)(v62 + 1);
        v67 = *((DWORD *)a1 + v66 + 2);
        v68 = (unsigned __int8)(v67 + v64);
        v69 = *((DWORD *)a1 + v68 + 2);
        *((DWORD *)a1 + v66 + 2) = v69;
        *((DWORD *)a1 + v68 + 2) = v67;
        *v44++ = *v45++ ^ *((BYTE *)a1 + 4 * (unsigned __int8)(v67 + v69) + 8);
        v7 = (unsigned __int8)(v66 + 1);
        v70 = *((DWORD *)a1 + v7 + 2);
        v6 = (unsigned __int8)(v70 + v68);
        v71 = *((DWORD *)a1 + v6 + 2);
        *((DWORD *)a1 + v7 + 2) = v71;
        *((DWORD *)a1 + v6 + 2) = v70;
        *v44 = *v45 ^ *((BYTE *)a1 + 4 * (unsigned __int8)(v70 + v71) + 8);
        v38 = v44 + 1;
        v39 = v45 + 1;
        --v111;
      }
      while ( v111 );
    }
    v4 = a2;
  }
  else
  {
    v38 = a4;
    v39 = a3;
  }
  v103 = (struct rc4_key_st *)(v4 & 7);
  if ( (v4 & 7) != 0 )
  {
    v7 = (unsigned __int8)(v7 + 1);
    v72 = *((DWORD *)a1 + v7 + 2);
    v6 = (unsigned __int8)(v72 + v6);
    v73 = *((DWORD *)a1 + v6 + 2);
    *((DWORD *)a1 + v7 + 2) = v73;
    *((DWORD *)a1 + v6 + 2) = v72;
    *v38 = *v39 ^ *((BYTE *)a1 + 4 * (unsigned __int8)(v72 + v73) + 8);
    v74 = v38 + 1;
    v75 = v39 + 1;
    for ( i = (struct rc4_key_st *)((char *)v103 - 1); i; i = (struct rc4_key_st *)((char *)v110 - 1) )
    {
      v7 = (unsigned __int8)(v7 + 1);
      v76 = *((DWORD *)a1 + v7 + 2);
      v6 = (unsigned __int8)(v76 + v6);
      v77 = *((DWORD *)a1 + v6 + 2);
      *((DWORD *)a1 + v7 + 2) = v77;
      *((DWORD *)a1 + v6 + 2) = v76;
      *v74 = *v75 ^ *((BYTE *)a1 + 4 * (unsigned __int8)(v76 + v77) + 8);
      v78 = v74 + 1;
      v79 = v75 + 1;
      v105 = (struct rc4_key_st *)((char *)i - 1);
      if ( !v105 )
        break;
      v7 = (unsigned __int8)(v7 + 1);
      v80 = *((DWORD *)a1 + v7 + 2);
      v6 = (unsigned __int8)(v80 + v6);
      v81 = *((DWORD *)a1 + v6 + 2);
      *((DWORD *)a1 + v7 + 2) = v81;
      *((DWORD *)a1 + v6 + 2) = v80;
      *v78 = *v79 ^ *((BYTE *)a1 + 4 * (unsigned __int8)(v80 + v81) + 8);
      v82 = v78 + 1;
      v83 = v79 + 1;
      v106 = (struct rc4_key_st *)((char *)v105 - 1);
      if ( !v106 )
        break;
      v7 = (unsigned __int8)(v7 + 1);
      v84 = *((DWORD *)a1 + v7 + 2);
      v6 = (unsigned __int8)(v84 + v6);
      v85 = *((DWORD *)a1 + v6 + 2);
      *((DWORD *)a1 + v7 + 2) = v85;
      *((DWORD *)a1 + v6 + 2) = v84;
      *v82 = *v83 ^ *((BYTE *)a1 + 4 * (unsigned __int8)(v84 + v85) + 8);
      v86 = v82 + 1;
      v87 = v83 + 1;
      v107 = (struct rc4_key_st *)((char *)v106 - 1);
      if ( !v107 )
        break;
      v7 = (unsigned __int8)(v7 + 1);
      v88 = *((DWORD *)a1 + v7 + 2);
      v6 = (unsigned __int8)(v88 + v6);
      v89 = *((DWORD *)a1 + v6 + 2);
      *((DWORD *)a1 + v7 + 2) = v89;
      *((DWORD *)a1 + v6 + 2) = v88;
      *v86 = *v87 ^ *((BYTE *)a1 + 4 * (unsigned __int8)(v88 + v89) + 8);
      v90 = v86 + 1;
      v91 = v87 + 1;
      v108 = (struct rc4_key_st *)((char *)v107 - 1);
      if ( !v108 )
        break;
      v7 = (unsigned __int8)(v7 + 1);
      v92 = *((DWORD *)a1 + v7 + 2);
      v6 = (unsigned __int8)(v92 + v6);
      v93 = *((DWORD *)a1 + v6 + 2);
      *((DWORD *)a1 + v7 + 2) = v93;
      *((DWORD *)a1 + v6 + 2) = v92;
      *v90 = *v91 ^ *((BYTE *)a1 + 4 * (unsigned __int8)(v92 + v93) + 8);
      v94 = v90 + 1;
      v95 = v91 + 1;
      v109 = (struct rc4_key_st *)((char *)v108 - 1);
      if ( !v109 )
        break;
      v7 = (unsigned __int8)(v7 + 1);
      v96 = *((DWORD *)a1 + v7 + 2);
      v6 = (unsigned __int8)(v96 + v6);
      v97 = *((DWORD *)a1 + v6 + 2);
      *((DWORD *)a1 + v7 + 2) = v97;
      *((DWORD *)a1 + v6 + 2) = v96;
      *v94 = *v95 ^ *((BYTE *)a1 + 4 * (unsigned __int8)(v96 + v97) + 8);
      v98 = v94 + 1;
      v99 = v95 + 1;
      v110 = (struct rc4_key_st *)((char *)v109 - 1);
      if ( !v110 )
        break;
      v7 = (unsigned __int8)(v7 + 1);
      v100 = *((DWORD *)a1 + v7 + 2);
      v6 = (unsigned __int8)(v100 + v6);
      v101 = *((DWORD *)a1 + v6 + 2);
      *((DWORD *)a1 + v7 + 2) = v101;
      *((DWORD *)a1 + v6 + 2) = v100;
      *v98 = *v99 ^ *((BYTE *)a1 + 4 * (unsigned __int8)(v100 + v101) + 8);
      v74 = v98 + 1;
      v75 = v99 + 1;
    }
  }
  *(DWORD *)a1 = v7;
  *((DWORD *)a1 + 1) = v6;
}

//----- (00001214) --------------------------------------------------------
char __thiscall CFileAuthClient::DecryptRC4(CFileAuthClient *this, unsigned __int8 *a2, unsigned int a3)
{
  HCRYPTHASH v4; // [esp-14h] [ebp-430h]
  DWORD pdwDataLen; // [esp+0h] [ebp-41Ch] BYREF
  BYTE pbData[5]; // [esp+4h] [ebp-418h] BYREF
  int v7; // [esp+9h] [ebp-413h]
  int v8; // [esp+Dh] [ebp-40Fh]
  __int16 v9; // [esp+11h] [ebp-40Bh]
  char v10; // [esp+13h] [ebp-409h]
  char v11[1032]; // [esp+14h] [ebp-408h] BYREF

  v4 = *((DWORD *)this + 16);
  pdwDataLen = 16;
  if ( !CryptGetHashParam(v4, 2u, pbData, &pdwDataLen, 0) )
    return 0;
  v7 = 0;
  v8 = 0;
  v9 = 0;
  v10 = 0;
  RC4_set_key((struct rc4_key_st *)v11, 16, pbData);
  RC4((struct rc4_key_st *)v11, a3, a2, a2);
  return 1;
}

// nfuncs=31 queued=8 decompiled=8 lumina nreq=0 worse=0 better=0
// ALL OK, 8 function(s) have been successfully decompiled
