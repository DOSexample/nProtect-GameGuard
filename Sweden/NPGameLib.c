/* This file was generated by the Hex-Rays decompiler.
   Copyright (c) 2007-2020 Hex-Rays <info@hex-rays.com>

   Detected compiler: Visual C++
*/

#include <windows.h>
#include <defs.h>

#include <stdarg.h>


//-------------------------------------------------------------------------
// Function declarations

#define __thiscall __cdecl // Test compile in C mode

int _E4();
CSafeAPI *_E1();
int _E3();
void __cdecl _E2(); // idb
unsigned int InitNPGameMon();
// void __usercall SetHwndToGameMon(int a1@<ebx>, HWND a2);
void __cdecl RunFAQWebPage(unsigned int a1);
int __cdecl PreInitNPGameMonW(wchar_t *String); // idb
int __cdecl PreInitNPGameMonA(char *); // idb
unsigned int CheckNPGameMon();
int __cdecl SendUserIDToGameMonW(wchar_t *String); // idb
int __cdecl SendUserIDToGameMonA(char *); // idb
BOOL __cdecl SendCSAuthToGameMon(unsigned int a1);
BOOL __cdecl SendCSAuth2ToGameMon(struct _GG_AUTH_DATA *a1);
const char *GetInfoFromGameMon();
int __cdecl ResourceAuthW(wchar_t *String, bool); // idb
int __cdecl ResourceAuthA(char *, bool); // idb
BOOL CloseNPGameMon();
void __thiscall CGameGuard::~CGameGuard(CGameGuard *__hidden this); // idb
// void __usercall _L63443(int a1@<ebp>);
unsigned int __thiscall CGameGuard::InitNPGameMonI(CGameGuard *__hidden this); // idb
const char *__thiscall CGameGuard::PreInitNPGameMonI(CGameGuard *this, const char *Source);
void __thiscall CCriticalSector::~CCriticalSector(LPCRITICAL_SECTION lpCriticalSection); // idb
void __thiscall CLog::~CLog(CLog *__hidden this); // idb
// void __usercall _L63726(int a1@<ebp>);
char CLog::Write(CLog *this, const char *Format, ...);
// void __userpurge CGameGuard::SetHwndToGameMonI(CGameGuard *this@<ecx>, int a2@<ebx>, HWND a3);
void __thiscall CGameGuard::RunFAQWebPageI(CGameGuard *__hidden this, unsigned int); // idb
char __thiscall CGameGuard::IsWinNT(CGameGuard *this);
char __thiscall CGameGuard::GetGameGuardDirectory(CGameGuard *this, LPSTR lpFilename, unsigned int a3);
char __thiscall CGameGuard::GetGameDirectory(CGameGuard *this, LPSTR lpFilename, unsigned int nSize);
unsigned int __thiscall CGameGuard::CheckNPGameMonI(CGameGuard *__hidden this); // idb
bool __thiscall CGameGuard::SendCSAuthToGameMonI(CGameGuard *__hidden this, unsigned int); // idb
bool __thiscall CGameGuard::SendUserIDToGameMonI(CGameGuard *__hidden this, const char *); // idb
const char *__thiscall CGameGuard::GetInfoFromGameMonI(CGameGuard *__hidden this); // idb
bool __thiscall CGameGuard::SendCSAuth2ToGameMonI(CGameGuard *__hidden this, struct _GG_AUTH_DATA *); // idb
int __thiscall CGameGuard::ResourceAuthI(CGameGuard *__hidden this, const char *, bool); // idb
bool __thiscall CGameGuard::CloseNPGameMonI(CGameGuard *__hidden this); // idb
char __thiscall CGameGuard::InitNPSC(CGameGuard *this);
char __thiscall CGameGuard::CloseNPSC(CGameGuard *this);
// DWORD __userpurge SpeedCheckEventThread@<eax>(int a1@<ebx>, LPVOID lpThreadParameter);
int __thiscall CGameGuard::CheckSingleInstance(CGameGuard *__hidden this, DWORD dwMilliseconds, int); // idb
int __thiscall CGameGuard::CheckGameMonSingleInstance(CGameGuard *__hidden this, unsigned int); // idb
unsigned int __thiscall CGameGuard::IsDebugger(CGameGuard *__hidden this); // idb
// bool __userpurge CommPipeCallback@<al>(int a1@<ebx>, struct CCommPipe *a2, unsigned int a3, unsigned int a4);
void __thiscall CGameGuard::FtpSendErl(CGameGuard *__hidden this); // idb
// bool __usercall InitToolhelp32@<al>(int a1@<ebx>);
// char __usercall GetProcessList@<al>(int a1@<ebx>);
// char __usercall GetModuleList@<al>(int a1@<ebx>);
// LONG __userpurge FvUnhandledExceptionFilter@<eax>(int a1@<ebx>, struct _EXCEPTION_POINTERS *ExceptionInfo);
int __cdecl NPDect(int a1);
int InitTimeAddr();
int CheckTimeAddr();
// int __usercall InitSocketAddr@<eax>(int a1@<ebx>);
int CheckSocketAddr();
int __cdecl EncryptPacket(int a1, int a2);
int __cdecl DecryptPacket(int a1, int a2);
int __cdecl EncryptPeerPacket(int a1, int a2);
int __cdecl DecryptPeerPacket(int a1, int a2);
char __cdecl CheckGameMonCrc(char *a1, char *a2, int a3);
// void __usercall _L63947(int a1@<ebp>);
int __cdecl ReadMemCrc(_DWORD *a1);
char __cdecl CheckVersion(int a1, unsigned __int16 a2, unsigned __int16 a3, unsigned __int16 a4, unsigned __int16 a5);
// const char *__userpurge MyGetProcAddress@<eax>(int a1@<ebx>, void *lp, int a3);
char CheckRsaBase();
char RemoveCompatibleMode();
char __cdecl DisableCompatibleMode(BYTE Data);
HMODULE CheckEncryptedClient();
int FixVC80DEP();
HANDLE __cdecl WriteSMMsg(const void *a1, unsigned int a2);
CNPDword *__thiscall CNPDword::CNPDword(CNPDword *this);
void __thiscall CNPDword::~CNPDword(CNPDword *__hidden this); // idb
void __thiscall CNPDword::Guard(CNPDword *__hidden this); // idb
void __thiscall CNPDword::Release(CNPDword *__hidden this); // idb
void __thiscall CNPDword::Set(CNPDword *__hidden this, unsigned int); // idb
unsigned int __thiscall CNPDword::Get(CNPDword *__hidden this); // idb
// CSafeAPI *__thiscall CSafeAPI::CSafeAPI(CSafeAPI *__hidden this); idb
// int __cdecl atexit(void (__cdecl *)());
// void __thiscall CSafeAPI::~CSafeAPI(CSafeAPI *__hidden this); idb
// int __stdcall WideCharToMultiByte(UINT CodePage, DWORD dwFlags, LPCWCH lpWideCharStr, int cchWideChar, LPSTR lpMultiByteStr, int cbMultiByte, LPCCH lpDefaultChar, LPBOOL lpUsedDefaultChar);
// size_t __cdecl _wcslen(const wchar_t *String);
// BOOL __stdcall TerminateProcess(HANDLE hProcess, UINT uExitCode);
// BOOL __stdcall SetEvent(HANDLE hEvent);
// CFileAuthClient *__thiscall CFileAuthClient::CFileAuthClient(CFileAuthClient *__hidden this); idb
// CCommPipe *__thiscall CCommPipe::CCommPipe(CCommPipe *__hidden this); idb
// void __stdcall InitializeCriticalSection(LPCRITICAL_SECTION lpCriticalSection);
// void *__cdecl operator new(unsigned int); idb
// LPTOP_LEVEL_EXCEPTION_FILTER __stdcall SetUnhandledExceptionFilter(LPTOP_LEVEL_EXCEPTION_FILTER lpTopLevelExceptionFilter);
// void __cdecl operator delete(void *); idb
// void __stdcall DeleteCriticalSection(LPCRITICAL_SECTION lpCriticalSection);
// BOOL __stdcall CloseHandle(HANDLE hObject);
// BOOL __stdcall SetEndOfFile(HANDLE hFile);
// BOOL __stdcall WriteFile(HANDLE hFile, LPCVOID lpBuffer, DWORD nNumberOfBytesToWrite, LPDWORD lpNumberOfBytesWritten, LPOVERLAPPED lpOverlapped);
// void __cdecl RC4(struct rc4_key_st *, unsigned int, unsigned __int8 *, unsigned __int8 *); idb
// int _sprintf(char *const Buffer, const char *const Format, ...);
// char *__cdecl _Dect(char *); idb
// void __stdcall GetLocalTime(LPSYSTEMTIME lpSystemTime);
// void __thiscall CCommPipe::~CCommPipe(CCommPipe *__hidden this); idb
// void __thiscall CFileAuthClient::~CFileAuthClient(CFileAuthClient *__hidden this); idb
// char *__cdecl _Dect1(char *); idb
// bool __thiscall CCommPipe::SendCommPipe(CCommPipe *__hidden this, unsigned int, unsigned int, unsigned int); idb
// DWORD __stdcall ResumeThread(HANDLE hThread);
// unsigned int __thiscall CCommPipe::RunCommPipe(CCommPipe *__hidden this); idb
// BOOL __stdcall ResetEvent(HANDLE hEvent);
// void *__thiscall CCommPipe::GetChildReadHandle(CCommPipe *__hidden this); idb
// void *__thiscall CCommPipe::GetChildWriteHandle(CCommPipe *__hidden this); idb
// BOOL __stdcall SetThreadPriority(HANDLE hThread, int nPriority);
// bool __thiscall CCommPipe::InitCommPipe(CCommPipe *__hidden this); idb
// HMODULE __stdcall GetModuleHandleA(LPCSTR lpModuleName);
// FARPROC __stdcall GetProcAddress(HMODULE hModule, LPCSTR lpProcName);
// BOOL __stdcall GetExitCodeProcess(HANDLE hProcess, LPDWORD lpExitCode);
// DWORD __stdcall WaitForMultipleObjects(DWORD nCount, const HANDLE *lpHandles, BOOL bWaitAll, DWORD dwMilliseconds);
// BOOL __stdcall CreateProcessA(LPCSTR lpApplicationName, LPSTR lpCommandLine, LPSECURITY_ATTRIBUTES lpProcessAttributes, LPSECURITY_ATTRIBUTES lpThreadAttributes, BOOL bInheritHandles, DWORD dwCreationFlags, LPVOID lpEnvironment, LPCSTR lpCurrentDirectory, LPSTARTUPINFOA lpStartupInfo, LPPROCESS_INFORMATION lpProcessInformation);
// char *__cdecl _Enct(char *); idb
// int _wsprintfA(LPSTR, LPCSTR, ...);
// BOOL __stdcall ReadFile(HANDLE hFile, LPVOID lpBuffer, DWORD nNumberOfBytesToRead, LPDWORD lpNumberOfBytesRead, LPOVERLAPPED lpOverlapped);
// DWORD __stdcall SetFilePointer(HANDLE hFile, LONG lDistanceToMove, PLONG lpDistanceToMoveHigh, DWORD dwMoveMethod);
// DWORD __stdcall GetFileSize(HANDLE hFile, LPDWORD lpFileSizeHigh);
// HANDLE __stdcall CreateEventA(LPSECURITY_ATTRIBUTES lpEventAttributes, BOOL bManualReset, BOOL bInitialState, LPCSTR lpName);
// DWORD __stdcall WaitForSingleObject(HANDLE hHandle, DWORD dwMilliseconds);
// HANDLE __stdcall OpenEventA(DWORD dwDesiredAccess, BOOL bInheritHandle, LPCSTR lpName);
// unsigned int __cdecl MemGetPrivateProfileInt(const char *, const char *, int, char *); idb
// int __cdecl __mbsicmp(const unsigned __int8 *Str1, const unsigned __int8 *Str2);
// unsigned int __cdecl MemGetPrivateProfileString(const char *, const char *, const char *, char *, unsigned int, char *); idb
// bool __thiscall CFileAuthClient::DecryptMem2(CFileAuthClient *__hidden this, const char *, char *, unsigned int, const char *); idb
// bool __thiscall CFileAuthClient::Auth(CFileAuthClient *__hidden this, const char *, bool); idb
// BOOL __stdcall CryptReleaseContext(HCRYPTPROV hProv, DWORD dwFlags);
// BOOL __stdcall CryptDestroyKey(HCRYPTKEY hKey);
// BOOL __stdcall CryptEncrypt(HCRYPTKEY hKey, HCRYPTHASH hHash, BOOL Final, DWORD dwFlags, BYTE *pbData, DWORD *pdwDataLen, DWORD dwBufLen);
// BOOL __stdcall CryptImportKey(HCRYPTPROV hProv, const BYTE *pbData, DWORD dwDataLen, HCRYPTKEY hPubKey, DWORD dwFlags, HCRYPTKEY *phKey);
// BOOL __stdcall CryptAcquireContextA(HCRYPTPROV *phProv, LPCSTR szContainer, LPCSTR szProvider, DWORD dwProvType, DWORD dwFlags);
// void __cdecl RC4_set_key(struct rc4_key_st *, int, unsigned __int8 *); idb
// int __cdecl _rand();
// void __cdecl _srand(unsigned int Seed);
// DWORD __stdcall GetTickCount();
// HANDLE __stdcall CreateFileA(LPCSTR lpFileName, DWORD dwDesiredAccess, DWORD dwShareMode, LPSECURITY_ATTRIBUTES lpSecurityAttributes, DWORD dwCreationDisposition, DWORD dwFlagsAndAttributes, HANDLE hTemplateFile);
// unsigned __int8 *__cdecl __mbsrchr(const unsigned __int8 *String, unsigned int C);
// DWORD __stdcall GetModuleFileNameA(HMODULE hModule, LPSTR lpFilename, DWORD nSize);
// LPSTR __stdcall lstrcatA(LPSTR lpString1, LPCSTR lpString2);
// DWORD __stdcall GetLastError();
// BOOL __stdcall CreateDirectoryA(LPCSTR lpPathName, LPSECURITY_ATTRIBUTES lpSecurityAttributes);
// int __cdecl __access(const char *FileName, int AccessMode);
// unsigned __int8 *__cdecl __mbsnbcpy(unsigned __int8 *Dest, const unsigned __int8 *Source, size_t Count);
// DWORD __stdcall GetCurrentThreadId();
// DWORD __stdcall GetCurrentProcessId();
// void __stdcall LeaveCriticalSection(LPCRITICAL_SECTION lpCriticalSection);
// int __cdecl _vsprintf(char *const Buffer, const char *const Format, va_list ArgList);
// void __stdcall EnterCriticalSection(LPCRITICAL_SECTION lpCriticalSection);
// int __stdcall NPGameMonCallback(unsigned int, unsigned int); idb
// LSTATUS __stdcall RegCloseKey(HKEY hKey);
// int __stdcall GetLocaleInfoA(LCID Locale, LCTYPE LCType, LPSTR lpLCData, int cchData);
// LSTATUS __stdcall RegQueryValueExA(HKEY hKey, LPCSTR lpValueName, LPDWORD lpReserved, LPDWORD lpType, LPBYTE lpData, LPDWORD lpcbData);
// LSTATUS __stdcall RegOpenKeyExA(HKEY hKey, LPCSTR lpSubKey, DWORD ulOptions, REGSAM samDesired, PHKEY phkResult);
// DWORD __stdcall GetCurrentDirectoryA(DWORD nBufferLength, LPSTR lpBuffer);
// BOOL __stdcall GetVersionExA(LPOSVERSIONINFOA lpVersionInformation);
// HANDLE __stdcall OpenMutexA(DWORD dwDesiredAccess, BOOL bInheritHandle, LPCSTR lpName);
// const char *__thiscall CCommPipe::GetUserInfo(CCommPipe *__hidden this); idb
// bool __thiscall CCommPipe::CloseCommPipe(CCommPipe *__hidden this); idb
// HANDLE __stdcall CreateThread(LPSECURITY_ATTRIBUTES lpThreadAttributes, SIZE_T dwStackSize, LPTHREAD_START_ROUTINE lpStartAddress, LPVOID lpParameter, DWORD dwCreationFlags, LPDWORD lpThreadId);
// HMODULE __stdcall LoadLibraryA(LPCSTR lpLibFileName);
// BOOL __stdcall FreeLibrary(HMODULE hLibModule);
// BOOL __stdcall TerminateThread(HANDLE hThread, DWORD dwExitCode);
// HANDLE __stdcall CreateMutexA(LPSECURITY_ATTRIBUTES lpMutexAttributes, BOOL bInitialOwner, LPCSTR lpName);
// BOOL __stdcall SetSecurityDescriptorDacl(PSECURITY_DESCRIPTOR pSecurityDescriptor, BOOL bDaclPresent, PACL pDacl, BOOL bDaclDefaulted);
// BOOL __stdcall InitializeSecurityDescriptor(PSECURITY_DESCRIPTOR pSecurityDescriptor, DWORD dwRevision);
// BOOL __stdcall ReleaseMutex(HANDLE hMutex);
// unsigned int *__thiscall CCommPipe::GetCSAuth2(CCommPipe *__hidden this); idb
// int __snprintf(char *const Buffer, const size_t BufferCount, const char *const Format, ...);
// BOOL __stdcall GetUserNameA(LPSTR lpBuffer, LPDWORD pcbBuffer);
// BOOL __stdcall GetComputerNameA(LPSTR lpBuffer, LPDWORD nSize);
// int __thiscall CSafeAPI::Init(CSafeAPI *__hidden this, const char *); idb
// HINSTANCE __thiscall CSafeAPI::GetModule(CSafeAPI *__hidden this); idb
// LSTATUS __stdcall RegSetValueExA(HKEY hKey, LPCSTR lpValueName, DWORD Reserved, DWORD dwType, const BYTE *lpData, DWORD cbData);
// int __stdcall lstrlenA(LPCSTR lpString);
// int __stdcall lstrcmpA(LPCSTR lpString1, LPCSTR lpString2);
// LSTATUS __stdcall RegCreateKeyExA(HKEY hKey, LPCSTR lpSubKey, DWORD Reserved, LPSTR lpClass, DWORD dwOptions, REGSAM samDesired, const LPSECURITY_ATTRIBUTES lpSecurityAttributes, PHKEY phkResult, LPDWORD lpdwDisposition);
// void __stdcall __noreturn ExitProcess(UINT uExitCode);
// DWORD __stdcall timeGetTime();
// BOOL __stdcall QueryPerformanceCounter(LARGE_INTEGER *lpPerformanceCount);
// int __stdcall send(SOCKET s, const char *buf, int len, int flags);
// int __stdcall WSASend(SOCKET s, LPWSABUF lpBuffers, DWORD dwBufferCount, LPDWORD lpNumberOfBytesSent, DWORD dwFlags, LPWSAOVERLAPPED lpOverlapped, LPWSAOVERLAPPED_COMPLETION_ROUTINE lpCompletionRoutine);
// int __cdecl PPEncryptClientPacket(_DWORD, _DWORD, _DWORD); weak
// int __cdecl PPDecryptServerPacket(_DWORD, _DWORD, _DWORD); weak
// int __cdecl PPDecryptClientPacket(_DWORD, _DWORD, _DWORD); weak
// void __thiscall CFvCrc32::~CFvCrc32(CFvCrc32 *__hidden this); idb
// bool __thiscall CFvCrc32::Crc32File(CFvCrc32 *__hidden this, const char *, unsigned int *); idb
// CFvCrc32 *__thiscall CFvCrc32::CFvCrc32(CFvCrc32 *__hidden this); idb
// unsigned __int8 *__cdecl __mbsstr(const unsigned __int8 *Str, const unsigned __int8 *Substr);
// BOOL __stdcall IsBadReadPtr(const void *lp, UINT_PTR ucb);
// UINT __stdcall GetSystemDirectoryA(LPSTR lpBuffer, UINT uSize);
// LSTATUS __stdcall RegDeleteValueA(HKEY hKey, LPCSTR lpValueName);
// LSTATUS __stdcall RegEnumValueA(HKEY hKey, DWORD dwIndex, LPSTR lpValueName, LPDWORD lpcchValueName, LPDWORD lpReserved, LPDWORD lpType, LPBYTE lpData, LPDWORD lpcbData);
// DWORD __stdcall GetModuleFileNameW(HMODULE hModule, LPWSTR lpFilename, DWORD nSize);
// BOOL __stdcall VirtualProtect(LPVOID lpAddress, SIZE_T dwSize, DWORD flNewProtect, PDWORD lpflOldProtect);
// BOOL __stdcall UnmapViewOfFile(LPCVOID lpBaseAddress);
// LPVOID __stdcall MapViewOfFile(HANDLE hFileMappingObject, DWORD dwDesiredAccess, DWORD dwFileOffsetHigh, DWORD dwFileOffsetLow, SIZE_T dwNumberOfBytesToMap);
// HANDLE __stdcall OpenFileMappingA(DWORD dwDesiredAccess, BOOL bInheritHandle, LPCSTR lpName);
// LPVOID __stdcall VirtualAlloc(LPVOID lpAddress, SIZE_T dwSize, DWORD flAllocationType, DWORD flProtect);
// BOOL __stdcall VirtualFree(LPVOID lpAddress, SIZE_T dwSize, DWORD dwFreeType);

//-------------------------------------------------------------------------
// Data declarations

int (__stdcall *pProcess32First)(void *, struct tagPROCESSENTRY32 *); // weak
int (__stdcall *pModule32Next)(void *, struct tagMODULEENTRY32 *); // weak
CHAR szLogFile; // idb
char byte_D; // weak
_UNKNOWN unk_6E; // weak
_UNKNOWN unk_6F; // weak
_UNKNOWN unk_72; // weak
_UNKNOWN unk_73; // weak
_UNKNOWN unk_78; // weak
_UNKNOWN unk_7A; // weak
_UNKNOWN unk_7C; // weak
_UNKNOWN unk_82; // weak
_UNKNOWN unk_8E; // weak
_UNKNOWN unk_99; // weak
_UNKNOWN unk_9A; // weak
_UNKNOWN unk_9B; // weak
_UNKNOWN unk_A0; // weak
_UNKNOWN unk_AA; // weak
_UNKNOWN unk_AB; // weak
_UNKNOWN unk_D2; // weak
_UNKNOWN unk_DC; // weak
_UNKNOWN unk_E6; // weak
void *(__stdcall *pCreateToolhelp32Snapshot)(unsigned int, unsigned int); // weak
_UNKNOWN safeWinInet; // weak
_UNKNOWN unk_1F4; // weak
char szGameMon[260]; // idb
int (__stdcall *pModule32First)(void *, struct tagMODULEENTRY32 *); // weak
int (__stdcall *pProcess32Next)(void *, struct tagPROCESSENTRY32 *); // weak
int nSendErl; // weak
int g_dwThreadId; // weak
DWORD g_dwWaitTime; // idb
int g_dwNoUpdate; // weak
int g_dwNoUseFaq; // weak
_UNKNOWN dwClientSequenceNumber; // weak
_UNKNOWN dwServerSequenceNumber; // weak
int dwWorkingPID; // weak
int bCheckGameMon; // weak
int dwDE; // weak
int dwRE; // weak
unsigned int dwGameMonPID; // weak
HANDLE hGameMonHandle; // idb
char bEncryptedClient; // weak
char bEncryptedClientArm; // weak
char bIsWin2K; // weak
CGameGuard *gg; // idb
int _dwCount__1__CheckNPGameMonI_CGameGuard__QAEKXZ_4KA; // weak
char _bInit__1__InitToolhelp32__YA_NXZ_4_NA; // weak
char _bInException__1__FvUnhandledExceptionFilter__YGJPAU_EXCEPTION_POINTERS___Z_4_NA; // weak
int lpGTC; // weak
int lpQPC; // weak
int lpTGT; // weak
int lpWSASend; // weak
int lpsend; // weak
int lpGTC2; // weak
int lpQPC2; // weak
int lpTGT2; // weak
int lpWSASend2; // weak
int lpsend2; // weak
char bInitTA; // weak
char bInitSA; // weak
char *CONTAINER_NAME = &`string'; // idb
int nSendErlIni = 1; // weak
int g_dwLoseAllowFactor = 4; // weak
_UNKNOWN loc_755; // weak
_UNKNOWN _L63493; // weak
char `string' = '\x01'; // idb
_UNKNOWN `string'; // weak
_UNKNOWN `string'; // weak
char `string' = '\x01'; // idb
char `string' = '\x01'; // idb
char `string' = '\x01'; // idb
char `string' = '\x01'; // idb
char `string' = '\x01'; // idb
char `string' = '\x01'; // idb
char `string' = '\x01'; // idb
char `string' = '\x01'; // idb
char `string' = '\x01'; // idb
char `string' = '\x01'; // idb
char `string' = '\x01'; // idb
char `string' = '\x01'; // idb
char `string'[27] =
{
  '\x01',
  '\xF6',
  'G',
  '\x18',
  '\n',
  '\f',
  '6',
  '\"',
  '\x1B',
  '\x8D',
  '\x9A',
  'm',
  '\xF6',
  '\xD2',
  'a',
  '\t',
  '\x1F',
  'Z',
  '\xDE',
  'K',
  '\xB7',
  '\xAE',
  '\x9F',
  'S',
  '\xF7',
  '\x7F',
  '\0'
}; // idb
char `string' = '\x01'; // idb
char `string' = '\x01'; // idb
char `string' = '\x01'; // idb
char `string' = '\x01'; // idb
char `string' = '\x01'; // idb
char `string' = '\x01'; // idb
char `string' = '\x01'; // idb
char `string'[34] =
{
  '\x01',
  '\x11',
  '\x98',
  '\x1C',
  'k',
  '\x9F',
  'i',
  'M',
  '\x81',
  '\xB6',
  '\xA5',
  '\xBC',
  '\x7F',
  ':',
  'p',
  'l',
  '\xC6',
  '\'',
  'W',
  '\x93',
  '\xF0',
  '\xED',
  '\x85',
  'u',
  '\xF1',
  '\xE9',
  '\xA8',
  '\xF4',
  '\xDF',
  '\x11',
  '\xD0',
  ',',
  '\'',
  '\0'
}; // idb
char `string' = '\x01'; // idb
char `string' = '\x01'; // idb
char `string' = '\x01'; // idb
char `string' = '\x01'; // idb
char `string' = '\x01'; // idb
char `string' = '\x01'; // idb
char `string' = '\x01'; // idb
char `string' = '\x01'; // idb
char `string' = '\x01'; // idb
char `string' = '\x01'; // idb
char `string' = '\x01'; // idb
char `string' = '\x01'; // idb
char `string' = '\x01'; // idb
char `string' = '\x01'; // idb
char `string' = '\x01'; // idb
char `string' = '\x01'; // idb
char `string' = '\x01'; // idb
char `string' = '\x01'; // idb
char `string' = '\x01'; // idb
char `string' = '\x01'; // idb
char `string' = '\x01'; // idb
char `string' = '\x01'; // idb
char `string' = '\x01'; // idb
char `string'[24] =
{
  '\x01',
  '\xAD',
  'l',
  'n',
  '\xD9',
  '\'',
  '}',
  'U',
  '\xD9',
  't',
  'H',
  '\x85',
  ' ',
  '_',
  '\x85',
  '\x8C',
  '\x84',
  '\xD1',
  ')',
  '9',
  'p',
  '\f',
  '\xD0',
  '\0'
}; // idb
char `string' = '\x01'; // idb
char `string' = '\x01'; // idb
char `string' = '\x01'; // idb
char `string' = '\x01'; // idb
char `string' = '\x01'; // idb
char `string' = '\x01'; // idb
char `string' = '\x01'; // idb
char `string' = '\x01'; // idb
char `string' = '\x01'; // idb
char `string' = '\x01'; // idb
char `string' = '\x01'; // idb
char `string' = '\x01'; // idb
char `string' = '\x01'; // idb
char `string' = '\x01'; // idb
char `string' = '\x01'; // idb
char `string' = '\x01'; // idb
char `string' = '\x01'; // idb
char `string' = '\x01'; // idb
char `string' = '\x01'; // idb
char `string'[36] =
{
  '\x01',
  '\xC4',
  '\xB1',
  'S',
  '^',
  '\xE2',
  '\x8C',
  '\x95',
  'a',
  '\x1D',
  '\x81',
  '{',
  '\xEA',
  '\x86',
  '\xB0',
  '\xAA',
  '\xEC',
  '\xBB',
  '\xF9',
  '\xCC',
  '\x98',
  'F',
  '\xAC',
  '\xFA',
  '\x81',
  '8',
  '\xE7',
  '\xDD',
  '\x04',
  '\xEC',
  '\x95',
  'D',
  '@',
  '\x04',
  '\x04',
  '\0'
}; // idb
char `string'[35] =
{
  '\x01',
  ']',
  '|',
  '\xB3',
  '\x03',
  '\x8B',
  'A',
  '\xC4',
  '\\',
  '\xD4',
  'l',
  't',
  '\xFE',
  '\x80',
  '\x80',
  'f',
  '\r',
  '\xC2',
  '<',
  '\xE8',
  '\x96',
  '\xBC',
  '\xAA',
  '\xF1',
  '\xE8',
  '\xF7',
  '\x8D',
  '\x94',
  '\\',
  '\xE5',
  '\xB4',
  '\xD0',
  't',
  '\xF4',
  '\0'
}; // idb
char `string' = '\x01'; // idb
char `string' = '\x01'; // idb
char `string' = '\x01'; // idb
char `string' = '\x01'; // idb
char `string' = '\x01'; // idb
char `string' = '\x01'; // idb
char `string' = '\x01'; // idb
char `string' = '\x01'; // idb
char `string' = '\x01'; // idb
char `string' = '\x01'; // idb
char `string' = '\x01'; // idb
char `string' = '\x01'; // idb
char `string' = '\x01'; // idb
char `string' = '\x01'; // idb
char `string' = '\x01'; // idb
char `string' = '\x01'; // idb
_UNKNOWN _L63751; // weak
char `string' = '\x01'; // idb
char `string' = '\x01'; // idb
char `string' = '\x01'; // idb
char `string' = '\x01'; // idb
char `string' = '\x01'; // idb
char `string' = '\x01'; // idb
char `string' = '\x01'; // idb
char `string' = '\x01'; // idb
char `string' = '\x01'; // idb
char `string' = '\x01'; // idb
char `string' = '\x01'; // idb
char `string'[58] =
{
  '\x01',
  'x',
  '\xCD',
  '\x95',
  '9',
  '\xA4',
  '\xAD',
  '\xFC',
  '\xA5',
  '\xDC',
  '\a',
  '\xDF',
  '&',
  '#',
  'B',
  '\xAF',
  '\xEF',
  '\x1B',
  '\xCC',
  '-',
  '\x9C',
  'C',
  '\xD0',
  'I',
  '\xC3',
  '(',
  '3',
  '\xF3',
  '\x86',
  '\xDA',
  '~',
  '\n',
  '\x8E',
  '{',
  '\xEC',
  '\x8D',
  '\xBC',
  '\xA3',
  '\xF0',
  '\xA9',
  '\xE3',
  '\x88',
  '\xD2',
  'V',
  '\xA8',
  '\xE5',
  '\xDA',
  '^',
  '\xC0',
  '\xED',
  '2',
  '\xA5',
  '\xCA',
  'J',
  '\r',
  '\x1C',
  '\x1C',
  '\0'
}; // idb
char `string' = '\x01'; // idb
char `string'[62] =
{
  '\x01',
  '\xE4',
  '\x11',
  'U',
  ']',
  '\x90',
  '!',
  '`',
  '\x01',
  '\xE8',
  ';',
  '\x13',
  '\xC2',
  'w',
  'N',
  '\x93',
  '\xCB',
  '\x8F',
  '\x90',
  'a',
  '8',
  '7',
  '\\',
  '\xD5',
  '\'',
  '\\',
  '\xCF',
  '\xBF',
  '\xA2',
  '\x8E',
  'r',
  '\xF6',
  '\xEA',
  '\xEF',
  '\xB0',
  '\xC1',
  'X',
  '\x97',
  '|',
  '5',
  'G',
  '\xBC',
  '\xEE',
  '\x1A',
  '\xCC',
  '1',
  '\xD6',
  'N',
  '\xD5',
  'F',
  '\x9E',
  '\n',
  '\\',
  '\xC1',
  '\xB6',
  '\xD1',
  'f',
  'V',
  '\xC9',
  'h',
  '\xE0',
  '\0'
}; // idb
char `string' = '\x01'; // idb
char `string' = '\x01'; // idb
char `string' = '\x01'; // idb
char `string'[8] = { '\x01', '\x15', '\xA4', '&', '\x99', '\0', '\xF8', '\0' }; // idb
char `string'[10] = { '\x01', '\xD0', '\xD5', '\xBD', 'S', 'l', '}', '\x10', '\xAE', '\0' }; // idb
char `string'[10] = { '\x01', '\x04', 'q', '\x89', '\xEF', '\xE0', '\x99', '\x04', '\xE3', '\0' }; // idb
char `string'[10] = { '\x01', '\x84', '\xF1', '\t', 'o', '`', '\x19', '\x84', '`', '\0' }; // idb
char `string'[10] = { '\x01', '\xF2', ';', '\xEF', '\xC5', '.', '\xA3', '\xC2', ';', '\0' }; // idb
char `string'[10] = { '\x01', '\xF8', 'M', '%', '\xAB', '4', 'u', '8', 'b', '\0' }; // idb
char `string'[10] = { '\x01', '\xF8', 'M', '%', '\xAB', '4', 'u', '8', 'c', '\0' }; // idb
char `string'[10] = { '\x01', '\xF2', ';', '\xEF', '\xC5', '.', '\xA3', '\xC2', '>', '\0' }; // idb
char `string'[8] = { '\x01', 'e', '\x94', '\xF6', ')', '\xB0', '\x89', '\0' }; // idb
char `string' = '\x01'; // idb
char `string' = '\x01'; // idb
char `string' = '\x01'; // idb
char `string' = '\x01'; // idb
char `string' = '\x01'; // idb
char `string' = '\x01'; // idb
char `string' = '\x01'; // idb
char `string' = '\x01'; // idb
unsigned __int8 `string' = 46u; // idb
char `string' = '\x01'; // idb
char `string' = '\x01'; // idb
char `string' = '\x01'; // idb
char `string' = '\x01'; // idb
char `string' = '\x01'; // idb
char `string' = '\x01'; // idb
char `string' = '\x01'; // idb
char `string' = '\x01'; // idb
char `string' = '\x01'; // idb
char `string' = '\x01'; // idb
char `string' = '\x01'; // idb
char `string' = '\x01'; // idb
char `string' = '\x01'; // idb
char `string' = '\x01'; // idb
char `string'[28] =
{
  '\x01',
  '\x82',
  '\xEB',
  '\xED',
  'n',
  '\xC0',
  '*',
  'v',
  'l',
  '\x86',
  '~',
  '\xEF',
  '\xB3',
  '\xFD',
  '\x1B',
  '\xF7',
  '\x8C',
  'm',
  'k',
  '|',
  '\xE6',
  '\xA7',
  '\xCF',
  '\x0E',
  '\xBF',
  '3',
  '\x1F',
  '\0'
}; // idb
char `string' = '\x01'; // idb
char `string'[35] =
{
  '\x01',
  '\x8D',
  '\f',
  'C',
  '\x13',
  '[',
  '\xD1',
  '4',
  'L',
  '\x84',
  '\x88',
  '\xA5',
  '\xD2',
  '|',
  '\xE5',
  '\xA1',
  '\xA8',
  '\xB7',
  '\xCD',
  'T',
  '\x9C',
  ')',
  '\'',
  'V',
  '\xAC',
  '\xA9',
  '\x0E',
  '\xC8',
  '!',
  '\x9D',
  '\b',
  '\x85',
  '\r',
  '\xD5',
  '\0'
}; // idb
char `string'[39] =
{
  '\x01',
  '\x81',
  '\xE8',
  '\xD3',
  'O',
  '/',
  '5',
  'H',
  '\xC0',
  '0',
  '}',
  '\x97',
  '\xB9',
  '\xA3',
  '\xD4',
  '9',
  '\xD7',
  '\xB5',
  '\xED',
  '\xB4',
  '\xC8',
  'u',
  '\x91',
  'j',
  '?',
  'p',
  '\xAE',
  '\xA4',
  '\x12',
  '\xD9',
  '`',
  '\x9F',
  'E',
  '\xCC',
  'D',
  '\x91',
  'i',
  'y',
  '\0'
}; // idb
char `string'[25] =
{
  '\x01',
  '\xE6',
  '\x17',
  'j',
  '\xFF',
  '=',
  'N',
  '\xA2',
  '\xC7',
  '\xB3',
  '\xA5',
  '\xFC',
  '\x82',
  '\x90',
  '\xA6',
  '\xF6',
  '\xDD',
  '\v',
  '\x1E',
  '\xF2',
  '?',
  'R',
  '\xAA',
  '\x82',
  '\0'
}; // idb
char `string' = '\x01'; // idb
char `string' = '\x01'; // idb
char `string' = '\x01'; // idb
char `string' = '\x01'; // idb
char `string' = '\x01'; // idb
char `string' = '\x01'; // idb
char `string' = '\x01'; // idb
char `string' = '\x01'; // idb
char `string' = '\x01'; // idb
char `string' = '\x01'; // idb
char `string' = '\x01'; // idb
char `string' = '\x01'; // idb
char `string' = '\x01'; // idb
char `string' = '\x01'; // idb
char `string' = '\x01'; // idb
char `string' = '\x01'; // idb
char `string' = '\x01'; // idb
char `string' = '\x01'; // idb
char `string' = '\x01'; // idb
char `string' = '\x01'; // idb
char `string' = '\x01'; // idb
char `string'[9] = { '\x01', 'V', 'g', 'j', '\xEC', '\xAC', '\x1C', '\xD3', '\0' }; // idb
char `string'[10] = { '\x01', '\x16', '\xA7', '+', '\xA0', '\xEA', '\xDA', '\x15', '\xF0', '\0' }; // idb
char `string'[11] = { '\x01', '\xC5', '\xB4', 'S', 'M', '\x91', '\xB8', '\xAC', '\xD4', '|', '\0' }; // idb
char `string'[13] =
{
  '\x01',
  '\xE7',
  '\x1A',
  '\x8F',
  '\xA0',
  '\xCC',
  'W',
  '\xEF',
  'r',
  '\x1A',
  '\xDE',
  'R',
  '\0'
}; // idb
char `string'[9] = { '\x01', '\xAA', 'c', 'f', '6', '8', ']', '\x85', '\0' }; // idb
char `string'[9] = { '\x01', '\xF2', ';', '\xEE', '\x9E', 'p', '\xFA', '\x86', '\0' }; // idb
char `string'[8] = { '\x01', 'K', 'F', '\b', '8', '3', 'h', '\0' }; // idb
char `string'[10] = { '\x01', '6', '\a', 'K', 'F', '\xD0', 'm', '\xF9', '\x89', '\0' }; // idb
char `string'[11] =
{
  '\x01',
  '\xD1',
  '\xD8',
  '\xC7',
  '\x1D',
  '\xC1',
  '7',
  '\x98',
  ']',
  '\xD6',
  '\0'
}; // idb
char `string' = '\x01'; // idb
char `string' = '\x01'; // idb
char `string' = '\x01'; // idb
char `string' = '\x01'; // idb
char `string' = '\x01'; // idb
char `string' = '\x01'; // idb
char `string' = '\x01'; // idb
char `string' = '\x01'; // idb
char `string' = '\x01'; // idb
char `string' = '\x01'; // idb
char `string' = '\x01'; // idb
char `string' = '\x01'; // idb
char `string' = '\x01'; // idb
char `string' = '\x01'; // idb
char `string' = '\x01'; // idb
char `string' = '\x01'; // idb
char `string' = '\x01'; // idb
char `string' = '\x01'; // idb
char `string' = '\x01'; // idb
char `string' = '\x01'; // idb
char `string' = '\x01'; // idb
char `string' = '\x01'; // idb
char `string' = '\x01'; // idb
char `string' = '\x01'; // idb
char `string' = '\x01'; // idb
char `string' = '\x01'; // idb
char `string' = '\x01'; // idb
char `string' = '\x01'; // idb
char `string' = '\x01'; // idb
char `string' = '\x01'; // idb
char `string' = '\x01'; // idb
char `string' = '\x01'; // idb
char `string' = '\x01'; // idb
char `string' = '\x01'; // idb
char `string' = '\x01'; // idb
char `string' = '\x01'; // idb
char `string' = '\x01'; // idb
char `string' = '\x01'; // idb
char `string' = '\x01'; // idb
char `string' = '\x01'; // idb
char `string' = '\x01'; // idb
char `string' = '\x01'; // idb
char `string' = '\x01'; // idb
char `string' = '\x01'; // idb
char `string' = '\x01'; // idb
char `string' = '\x01'; // idb
char `string' = '\x01'; // idb
char `string' = '\x01'; // idb
char `string' = '\x01'; // idb
char `string' = '\x01'; // idb
char `string' = '\x01'; // idb
char `string' = '\x01'; // idb
char `string' = '\x01'; // idb
_UNKNOWN _L63959; // weak
char `string' = '\x01'; // idb
char `string' = '\x01'; // idb
char `string' = '\x01'; // idb
char `string' = '\x01'; // idb
char `string' = '\x01'; // idb
char `string' = '\x01'; // idb
char `string' = '\x01'; // idb
char `string' = '\x01'; // idb
char `string' = '\x01'; // idb
char `string' = '\x01'; // idb
char `string' = '\x01'; // idb
char `string' = '\x01'; // idb
char `string' = '\x01'; // idb
_SCOPETABLE_ENTRY _T63988 = { -1, &_L63977, &_L63978 }; // weak
char `string' = '\x01'; // idb
char `string' = '\x01'; // idb
char `string'[14] =
{
  '\x01',
  'I',
  '@',
  '\xF0',
  'w',
  '\xCC',
  'O',
  '\xDF',
  '-',
  'i',
  '\xE5',
  '\x9B',
  '\x91',
  '\0'
}; // idb
char `string' = '\x01'; // idb
char `string' = '\x01'; // idb
char `string' = '\x01'; // idb
char `string' = '\x01'; // idb
char `string' = '\x01'; // idb
char `string' = '\x01'; // idb
char `string' = '\x01'; // idb
char `string' = '\x01'; // idb
char `string' = '\x01'; // idb
char `string' = '\x01'; // idb
char `string' = '\x01'; // idb
char `string' = '\x01'; // idb
char `string' = '\x01'; // idb
char `string' = '\x01'; // idb
char `string' = '\x01'; // idb
char `string' = '\x01'; // idb
char `string' = '\x01'; // idb
// extern _UNKNOWN _except_list; weak
// extern _UNKNOWN _except_handler3; weak


//----- (000003C4) --------------------------------------------------------
int _E4()
{
  _E1();
  return _E3();
}

//----- (000003D4) --------------------------------------------------------
CSafeAPI *_E1()
{
  return CSafeAPI::CSafeAPI((CSafeAPI *)&safeWinInet);
}

//----- (000003E4) --------------------------------------------------------
int _E3()
{
  return atexit(_E2);
}

//----- (000003F4) --------------------------------------------------------
void __cdecl _E2()
{
  CSafeAPI::~CSafeAPI((CSafeAPI *)&safeWinInet);
}

//----- (00000404) --------------------------------------------------------
unsigned int InitNPGameMon()
{
  unsigned int result; // eax

  if ( gg )
    result = CGameGuard::InitNPGameMonI(gg);
  else
    result = 0;
  return result;
}

//----- (00000424) --------------------------------------------------------
void __usercall SetHwndToGameMon(int a1@<ebx>, HWND a2)
{
  if ( gg )
    CGameGuard::SetHwndToGameMonI(gg, a1, a2);
}

//----- (00000444) --------------------------------------------------------
void __cdecl RunFAQWebPage(unsigned int a1)
{
  if ( gg )
    CGameGuard::RunFAQWebPageI(gg, a1);
}

//----- (00000474) --------------------------------------------------------
int __cdecl PreInitNPGameMonW(wchar_t *String)
{
  size_t v1; // eax
  CHAR MultiByteStr[32]; // [esp+4h] [ebp-20h] BYREF

  v1 = _wcslen(String);
  WideCharToMultiByte(0, 0, String, v1 + 1, MultiByteStr, 32, 0, 0);
  return PreInitNPGameMonA(MultiByteStr);
}

//----- (000004B4) --------------------------------------------------------
int __cdecl PreInitNPGameMonA(char *a1)
{
  void (__stdcall *v2)(LPTOP_LEVEL_EXCEPTION_FILTER); // ebp
  LONG (__stdcall *v3)(struct _EXCEPTION_POINTERS *); // edi
  char *v4; // esi
  CGameGuard *v5; // ecx
  void *v6; // eax

  if ( gg )
    return 0;
  v2 = (void (__stdcall *)(LPTOP_LEVEL_EXCEPTION_FILTER))SetUnhandledExceptionFilter;
  v3 = SetUnhandledExceptionFilter((LPTOP_LEVEL_EXCEPTION_FILTER)FvUnhandledExceptionFilter);
  v4 = (char *)operator new(0x1694u);
  if ( v4 )
  {
    *v4 = 0;
    v4[1] = 0;
    *((_DWORD *)v4 + 1) = 0;
    *((_DWORD *)v4 + 2) = 0;
    *((_DWORD *)v4 + 3) = 0;
    *((_DWORD *)v4 + 4) = 0;
    *((_DWORD *)v4 + 5) = 0;
    *((_DWORD *)v4 + 6) = 0;
    *((_DWORD *)v4 + 7) = 0;
    v4[32] = 0;
    v4[33] = 0;
    v4[34] = 0;
    v4[35] = 0;
    *((_DWORD *)v4 + 9) = -1;
    InitializeCriticalSection((LPCRITICAL_SECTION)(v4 + 40));
    *((_DWORD *)v4 + 1305) = 0;
    CCommPipe::CCommPipe((CCommPipe *)(v4 + 5224));
    CFileAuthClient::CFileAuthClient((CFileAuthClient *)(v4 + 5568));
    *((_DWORD *)v4 + 1410) = 0;
    *((_DWORD *)v4 + 1419) = 0;
    *((_DWORD *)v4 + 1420) = 0;
    v4[5748] = 0;
    v4[5749] = 0;
    *((_DWORD *)v4 + 1438) = 1000;
    *((_DWORD *)v4 + 1439) = 0;
    *((_DWORD *)v4 + 1440) = 0;
    *((_DWORD *)v4 + 1441) = 0;
    v4[5768] = 0;
    *((_DWORD *)v4 + 1443) = 0;
    *((_DWORD *)v4 + 1444) = 0;
    v4[5684] = 0;
    v5 = (CGameGuard *)v4;
  }
  else
  {
    v5 = 0;
  }
  gg = v5;
  *((_DWORD *)v5 + 4) = CGameGuard::PreInitNPGameMonI(v5, a1);
  if ( *((_DWORD *)gg + 6) )
    SetEvent(*((HANDLE *)gg + 6));
  v6 = (void *)*((_DWORD *)gg + 7);
  if ( v6 )
    TerminateProcess(v6, 0);
  if ( v3 )
    v2(v3);
  return *((_DWORD *)gg + 4);
}

//----- (000005F4) --------------------------------------------------------
unsigned int CheckNPGameMon()
{
  unsigned int result; // eax

  if ( gg )
    result = CGameGuard::CheckNPGameMonI(gg);
  else
    result = 0;
  return result;
}

//----- (00000614) --------------------------------------------------------
int __cdecl SendUserIDToGameMonW(wchar_t *String)
{
  int v2; // eax
  CHAR MultiByteStr[64]; // [esp+4h] [ebp-40h] BYREF

  if ( !String )
    return 0;
  v2 = _wcslen(String);
  WideCharToMultiByte(0, 0, String, v2, MultiByteStr, 64, 0, 0);
  return SendUserIDToGameMonA(MultiByteStr);
}

//----- (00000664) --------------------------------------------------------
int __cdecl SendUserIDToGameMonA(char *a1)
{
  int result; // eax

  if ( !gg )
    return 0;
  result = (int)a1;
  if ( a1 )
    result = CGameGuard::SendUserIDToGameMonI(gg, a1);
  return result;
}

//----- (00000694) --------------------------------------------------------
BOOL __cdecl SendCSAuthToGameMon(unsigned int a1)
{
  BOOL result; // eax

  if ( gg )
    result = CGameGuard::SendCSAuthToGameMonI(gg, a1);
  else
    result = 0;
  return result;
}

//----- (000006B4) --------------------------------------------------------
BOOL __cdecl SendCSAuth2ToGameMon(struct _GG_AUTH_DATA *a1)
{
  BOOL result; // eax

  if ( gg )
    result = CGameGuard::SendCSAuth2ToGameMonI(gg, a1);
  else
    result = 0;
  return result;
}

//----- (000006D4) --------------------------------------------------------
const char *GetInfoFromGameMon()
{
  const char *result; // eax

  if ( gg )
    result = CGameGuard::GetInfoFromGameMonI(gg);
  else
    result = 0;
  return result;
}

//----- (000006F4) --------------------------------------------------------
int __cdecl ResourceAuthW(wchar_t *String, bool a2)
{
  size_t v2; // eax
  CHAR MultiByteStr[260]; // [esp+4h] [ebp-104h] BYREF

  v2 = _wcslen(String);
  WideCharToMultiByte(0, 0, String, v2 + 1, MultiByteStr, 260, 0, 0);
  return ResourceAuthA(MultiByteStr, a2);
}

//----- (00000744) --------------------------------------------------------
int __cdecl ResourceAuthA(char *a1, bool a2)
{
  int result; // eax

  if ( gg )
    result = CGameGuard::ResourceAuthI(gg, a1, a2);
  else
    result = 0;
  return result;
}

//----- (00000764) --------------------------------------------------------
BOOL CloseNPGameMon()
{
  CGameGuard *v1; // esi
  bool v2; // [esp+0h] [ebp-4h]

  if ( !gg )
    return 0;
  v2 = CGameGuard::CloseNPGameMonI(gg);
  v1 = gg;
  if ( gg )
  {
    CGameGuard::~CGameGuard(gg);
    operator delete(v1);
  }
  gg = 0;
  return v2;
}

//----- (000007B4) --------------------------------------------------------
void __thiscall CGameGuard::~CGameGuard(CGameGuard *this)
{
  char *v2; // esi
  HANDLE v3; // eax
  unsigned int v4; // eax
  bool v5; // cc
  void *v6; // eax
  const char *v7; // eax
  signed int v8; // ecx
  signed int v9; // edi
  _BYTE *v10; // eax
  int v11; // ecx
  int v12; // [esp-2Ch] [ebp-40h]
  int v13; // [esp-28h] [ebp-3Ch]
  int v14; // [esp-24h] [ebp-38h]
  int v15; // [esp-20h] [ebp-34h]
  int v16; // [esp-1Ch] [ebp-30h]
  int v17; // [esp-18h] [ebp-2Ch]
  int v18; // [esp-14h] [ebp-28h]
  void *v19; // [esp-10h] [ebp-24h]
  DWORD NumberOfBytesWritten; // [esp+4h] [ebp-10h] BYREF
  unsigned int v21[2]; // [esp+8h] [ebp-Ch] BYREF
  int v22; // [esp+10h] [ebp-4h]

  v21[1] = (unsigned int)&_L63493;
  v21[0] = __readfsdword((unsigned int)&_except_list);
  __writefsdword((unsigned int)&_except_list, (unsigned int)v21);
  v22 = 1;
  CFileAuthClient::~CFileAuthClient((CGameGuard *)((char *)this + 5568));
  LOBYTE(v22) = 0;
  CCommPipe::~CCommPipe((CGameGuard *)((char *)this + 5224));
  v2 = (char *)this + 36;
  v3 = *(HANDLE *)v2;
  v22 = 2;
  if ( v3 != (HANDLE)-1 )
  {
    GetLocalTime((LPSYSTEMTIME)(v2 + 4124));
    v4 = *((_DWORD *)v2 + 1295);
    if ( !v4 || (v5 = *((_DWORD *)v2 + 1296) <= v4, v6 = &`string', v5) )
      v6 = &`string';
    v19 = v6;
    v18 = *((unsigned __int16 *)v2 + 2069);
    v17 = *((unsigned __int16 *)v2 + 2068);
    v16 = *((unsigned __int16 *)v2 + 2067);
    v15 = *((unsigned __int16 *)v2 + 2066);
    v14 = *((unsigned __int16 *)v2 + 2065);
    v13 = *((unsigned __int16 *)v2 + 2063);
    v12 = *((unsigned __int16 *)v2 + 2062);
    v7 = _Dect(&`string');
    _sprintf(v2 + 28, v7, v12, v13, v14, v15, v16, v17, v18, v19);
    v8 = strlen(v2 + 28);
    v9 = v8;
    if ( *((_DWORD *)v2 + 1294) )
    {
      if ( v8 > 0 )
      {
        v10 = v2 + 28;
        do
        {
          v11 = *((_DWORD *)v2 + 1294) + 2;
          *((_DWORD *)v2 + 1294) = v11;
          *v10++ ^= (_BYTE)v11 + 67;
        }
        while ( (int)&v10[-28 - (_DWORD)v2] < v9 );
      }
    }
    else
    {
      RC4((struct rc4_key_st *)(v2 + 4144), v8, (unsigned __int8 *)v2 + 28, (unsigned __int8 *)v2 + 28);
    }
    if ( *((_DWORD *)v2 + 1295) != 999 )
      WriteFile(*(HANDLE *)v2, v2 + 28, v9, &NumberOfBytesWritten, 0);
    SetEndOfFile(*(HANDLE *)v2);
    CloseHandle(*(HANDLE *)v2);
    *(_DWORD *)v2 = -1;
  }
  DeleteCriticalSection((LPCRITICAL_SECTION)(v2 + 4));
  __writefsdword((unsigned int)&_except_list, v21[0]);
}

//----- (00000954) --------------------------------------------------------
void __usercall _L63443(int a1@<ebp>)
{
  CLog::~CLog((CLog *)(*(_DWORD *)(a1 - 20) + 36));
}

//----- (00000A1C) --------------------------------------------------------
unsigned int __thiscall CGameGuard::InitNPGameMonI(CGameGuard *this)
{
  const char *v2; // eax
  const char *v4; // eax
  int v5; // [esp-4h] [ebp-8h]

  if ( *(_BYTE *)this )
  {
    v4 = _Dect1(&`string');
    CLog::Write((CGameGuard *)((char *)this + 36), v4);
  }
  else
  {
    v5 = *((_DWORD *)this + 4);
    v2 = _Dect1(&`string');
    CLog::Write((CGameGuard *)((char *)this + 36), v2, v5);
  }
  return *((_DWORD *)this + 4);
}

//----- (00000AA0) --------------------------------------------------------
const char *__thiscall CGameGuard::PreInitNPGameMonI(CGameGuard *this, const char *Source)
{
  DWORD (__stdcall *v3)(); // esi
  const char *v4; // eax
  void (__stdcall *v6)(LPSTR, LPCSTR); // esi
  const CHAR *v7; // eax
  HANDLE *v8; // ebx
  HANDLE v9; // eax
  unsigned __int8 *v10; // eax
  char *v11; // edx
  HANDLE v12; // eax
  const char *v13; // eax
  char *v14; // eax
  signed int v15; // edi
  _BYTE *v16; // eax
  int v17; // edx
  __int16 v18; // di
  unsigned int v19; // ecx
  unsigned int v20; // eax
  int (__cdecl *v21)(); // esi
  int k; // edi
  DWORD v23; // esi
  _DWORD *v24; // edi
  HANDLE v25; // eax
  HANDLE v26; // edx
  void (__stdcall *v27)(HANDLE, LPCVOID, DWORD, LPDWORD, LPOVERLAPPED); // esi
  int l; // eax
  unsigned __int8 *v29; // esi
  HCRYPTKEY v30; // eax
  const char *v31; // eax
  HANDLE v32; // eax
  unsigned __int8 *v33; // eax
  char *v34; // edx
  HANDLE v35; // eax
  const char *v36; // eax
  char *v37; // eax
  signed int v38; // edi
  _BYTE *v39; // eax
  int v40; // edx
  __int16 v41; // di
  unsigned int v42; // ecx
  unsigned int v43; // eax
  int (__cdecl *v44)(); // edi
  int i; // esi
  DWORD v46; // esi
  _DWORD *v47; // edi
  HANDLE v48; // eax
  HANDLE v49; // edx
  void (__stdcall *v50)(HANDLE, LPCVOID, DWORD, LPDWORD, LPOVERLAPPED); // esi
  int j; // eax
  const char *v52; // eax
  CGameGuard *v53; // esi
  const char *v54; // eax
  const char *v55; // eax
  CGameGuard *v56; // esi
  CFileAuthClient *v57; // edi
  char *v58; // eax
  const char *v59; // edi
  const char *v60; // eax
  const char *v61; // eax
  const char *v62; // eax
  const char *v63; // eax
  const CHAR *v64; // eax
  HANDLE v65; // eax
  void *v66; // edi
  const char *v67; // eax
  DWORD v68; // eax
  HANDLE (__stdcall *v69)(LPSECURITY_ATTRIBUTES, BOOL, BOOL, LPCSTR); // edi
  HANDLE v70; // eax
  DWORD (__stdcall *v71)(); // esi
  const char *v72; // eax
  HANDLE v73; // eax
  DWORD (__stdcall *v74)(); // esi
  HANDLE v75; // eax
  DWORD (__stdcall *v76)(); // esi
  const char *v77; // eax
  const char *v78; // eax
  CGameGuard *v79; // esi
  int v80; // edi
  const char *v81; // eax
  HANDLE v82; // eax
  void *v83; // edi
  const char *v84; // eax
  const char *v85; // eax
  const char *v86; // eax
  const char *v87; // eax
  const char *v88; // eax
  const char *v89; // eax
  int v90; // eax
  int v91; // edx
  const CHAR *v92; // eax
  const char *v93; // eax
  unsigned int v94; // kr3C_4
  const char *v95; // eax
  CHAR *v96; // edi
  const char *v97; // eax
  DWORD (__stdcall *v98)(); // esi
  const char *v99; // eax
  void *v100; // ecx
  const char *v101; // eax
  const char *v102; // eax
  void (__stdcall *v103)(HANDLE); // esi
  const char *v104; // eax
  void (__stdcall *v105)(HANDLE); // esi
  DWORD (__stdcall *v106)(); // edi
  const char *v107; // esi
  const char *v108; // eax
  char *v109; // eax
  CGameGuard *v110; // esi
  DWORD (__stdcall *v111)(); // edi
  int v112; // esi
  const char *v113; // eax
  const char *v114; // edi
  const char *v115; // eax
  const char *v116; // eax
  const char *v117; // eax
  const char *v118; // eax
  const char *v119; // eax
  const char *v120; // eax
  const char *v121; // eax
  const char *v122; // eax
  const char *v123; // eax
  const char *v124; // eax
  char v125; // al
  CGameGuard *v126; // esi
  const char *v127; // eax
  const char *v128; // eax
  const char *v129; // eax
  const char *v130; // eax
  const char *v131; // eax
  const char *v132; // eax
  const char *v133; // eax
  CGameGuard *v134; // esi
  DWORD (__stdcall *v135)(); // edi
  int v136; // esi
  const char *v137; // eax
  const char *v138; // eax
  const char *v139; // eax
  const char *v140; // eax
  DWORD v141; // edi
  const CHAR *v142; // eax
  void *v143; // edx
  unsigned int v144; // kr5C_4
  CHAR *v145; // edi
  const char *v146; // eax
  unsigned int v147; // kr60_4
  DWORD (__stdcall *v148)(); // esi
  const char *v149; // eax
  DWORD (__stdcall *v150)(); // esi
  const char *v151; // eax
  const char *v152; // eax
  unsigned int v153; // eax
  DWORD (__stdcall *v154)(); // esi
  const char *v155; // eax
  const char *v156; // eax
  const CHAR *v157; // eax
  HANDLE v158; // eax
  const char *v159; // eax
  const char *v160; // eax
  const char *v161; // eax
  const CHAR *v162; // eax
  HANDLE v163; // eax
  const char *v164; // eax
  const char *v165; // eax
  int v166; // edi
  const char *v167; // eax
  int v168; // edi
  const char *v169; // eax
  const char *v170; // eax
  const char *v171; // eax
  const char *v172; // eax
  int v173; // [esp-20h] [ebp-1974h]
  int v174; // [esp-1Ch] [ebp-1970h]
  int v175; // [esp-1Ch] [ebp-1970h]
  int v176; // [esp-1Ch] [ebp-1970h]
  int v177; // [esp-18h] [ebp-196Ch]
  int v178; // [esp-18h] [ebp-196Ch]
  DWORD v179; // [esp-18h] [ebp-196Ch]
  void *v180; // [esp-18h] [ebp-196Ch]
  int v181; // [esp-14h] [ebp-1968h]
  int v182; // [esp-14h] [ebp-1968h]
  int v183; // [esp-14h] [ebp-1968h]
  int v184; // [esp-14h] [ebp-1968h]
  void *v185; // [esp-14h] [ebp-1968h]
  int v186; // [esp-10h] [ebp-1964h]
  int v187; // [esp-10h] [ebp-1964h]
  const char *v188; // [esp-10h] [ebp-1964h]
  int v189; // [esp-10h] [ebp-1964h]
  const char *v190; // [esp-10h] [ebp-1964h]
  int v191; // [esp-10h] [ebp-1964h]
  int v192; // [esp-10h] [ebp-1964h]
  int v193; // [esp-Ch] [ebp-1960h]
  int v194; // [esp-Ch] [ebp-1960h]
  int v195; // [esp-Ch] [ebp-1960h]
  int v196; // [esp-Ch] [ebp-1960h]
  CHAR *v197; // [esp-Ch] [ebp-1960h]
  int v198; // [esp-Ch] [ebp-1960h]
  int v199; // [esp-Ch] [ebp-1960h]
  int v200; // [esp-Ch] [ebp-1960h]
  int v201; // [esp-8h] [ebp-195Ch]
  int v202; // [esp-8h] [ebp-195Ch]
  const char *v203; // [esp-8h] [ebp-195Ch]
  DWORD v204; // [esp-8h] [ebp-195Ch]
  DWORD v205; // [esp-8h] [ebp-195Ch]
  int v206; // [esp-8h] [ebp-195Ch]
  char *v207; // [esp-8h] [ebp-195Ch]
  const char *v208; // [esp-8h] [ebp-195Ch]
  int v209; // [esp-8h] [ebp-195Ch]
  int v210; // [esp-8h] [ebp-195Ch]
  DWORD v211; // [esp-8h] [ebp-195Ch]
  int v212; // [esp-8h] [ebp-195Ch]
  DWORD v213; // [esp-4h] [ebp-1958h]
  int v214; // [esp-4h] [ebp-1958h]
  HCRYPTKEY v215; // [esp-4h] [ebp-1958h]
  int v216; // [esp-4h] [ebp-1958h]
  DWORD v217; // [esp-4h] [ebp-1958h]
  DWORD v218; // [esp-4h] [ebp-1958h]
  HCRYPTPROV v219; // [esp-4h] [ebp-1958h]
  int v220; // [esp-4h] [ebp-1958h]
  int v221; // [esp-4h] [ebp-1958h]
  DWORD v222; // [esp-4h] [ebp-1958h]
  DWORD v223; // [esp-4h] [ebp-1958h]
  const char *v224; // [esp-4h] [ebp-1958h]
  DWORD v225; // [esp-4h] [ebp-1958h]
  DWORD v226; // [esp-4h] [ebp-1958h]
  int v227; // [esp-4h] [ebp-1958h]
  int v228; // [esp-4h] [ebp-1958h]
  DWORD v229; // [esp-4h] [ebp-1958h]
  int v230; // [esp-4h] [ebp-1958h]
  DWORD v231; // [esp-4h] [ebp-1958h]
  DWORD v232; // [esp-4h] [ebp-1958h]
  unsigned int v233; // [esp-4h] [ebp-1958h]
  DWORD v234; // [esp-4h] [ebp-1958h]
  char v235[2048]; // [esp+Ch] [ebp-1948h] BYREF
  char v236[2048]; // [esp+80Ch] [ebp-1148h] BYREF
  CHAR CommandLine[1024]; // [esp+100Ch] [ebp-948h] BYREF
  CHAR v238[256]; // [esp+140Ch] [ebp-548h] BYREF
  CHAR ApplicationName[260]; // [esp+150Ch] [ebp-448h] BYREF
  CHAR Filename[4]; // [esp+1610h] [ebp-344h] BYREF
  int v241; // [esp+1614h] [ebp-340h]
  int v242; // [esp+1618h] [ebp-33Ch]
  char v243[252]; // [esp+161Ch] [ebp-338h] BYREF
  char FileName[260]; // [esp+1718h] [ebp-23Ch] BYREF
  struct _STARTUPINFOA StartupInfo; // [esp+181Ch] [ebp-138h] BYREF
  char v246[32]; // [esp+1860h] [ebp-F4h] BYREF
  unsigned __int8 Str1[16]; // [esp+1880h] [ebp-D4h] BYREF
  char v248[16]; // [esp+1890h] [ebp-C4h] BYREF
  unsigned __int8 v249[4]; // [esp+18A0h] [ebp-B4h] BYREF
  int v250; // [esp+18A4h] [ebp-B0h]
  int v251; // [esp+18A8h] [ebp-ACh]
  int v252; // [esp+18ACh] [ebp-A8h]
  struct _SECURITY_ATTRIBUTES EventAttributes; // [esp+18B0h] [ebp-A4h] BYREF
  unsigned __int8 v254[4]; // [esp+18BCh] [ebp-98h] BYREF
  int v255; // [esp+18C0h] [ebp-94h]
  HANDLE Handles; // [esp+18C4h] [ebp-90h] BYREF
  DWORD NumberOfBytesRead; // [esp+18C8h] [ebp-8Ch] BYREF
  int Buffer; // [esp+18CCh] [ebp-88h] BYREF
  unsigned int v259; // [esp+18D0h] [ebp-84h] BYREF
  struct _PROCESS_INFORMATION ProcessInformation; // [esp+18D4h] [ebp-80h] BYREF
  DWORD NumberOfBytesWritten; // [esp+18E4h] [ebp-70h] BYREF
  BYTE pbData; // [esp+18E8h] [ebp-6Ch] BYREF
  char v263; // [esp+18E9h] [ebp-6Bh]
  char v264; // [esp+18EAh] [ebp-6Ah]
  char v265; // [esp+18EBh] [ebp-69h]
  char v266; // [esp+18ECh] [ebp-68h]
  char v267; // [esp+18EDh] [ebp-67h]
  char v268; // [esp+18EEh] [ebp-66h]
  char v269; // [esp+18EFh] [ebp-65h]
  char v270[8]; // [esp+18F0h] [ebp-64h] BYREF
  char v271; // [esp+18F8h] [ebp-5Ch]
  char v272; // [esp+18F9h] [ebp-5Bh]
  char v273; // [esp+18FAh] [ebp-5Ah]
  char v274; // [esp+18FBh] [ebp-59h]
  char v275; // [esp+18FCh] [ebp-58h]
  char v276; // [esp+18FDh] [ebp-57h]
  char v277; // [esp+18FEh] [ebp-56h]
  char v278; // [esp+18FFh] [ebp-55h]
  char v279; // [esp+1900h] [ebp-54h]
  char v280; // [esp+1901h] [ebp-53h]
  char v281; // [esp+1902h] [ebp-52h]
  char v282; // [esp+1903h] [ebp-51h]
  char v283; // [esp+1904h] [ebp-50h]
  char v284; // [esp+1905h] [ebp-4Fh]
  char v285; // [esp+1906h] [ebp-4Eh]
  char v286; // [esp+1907h] [ebp-4Dh]
  char v287; // [esp+1908h] [ebp-4Ch]
  char v288; // [esp+1909h] [ebp-4Bh]
  char v289; // [esp+190Ah] [ebp-4Ah]
  char v290; // [esp+190Bh] [ebp-49h]
  char v291; // [esp+190Ch] [ebp-48h]
  char v292; // [esp+190Dh] [ebp-47h]
  char v293; // [esp+190Eh] [ebp-46h]
  char v294; // [esp+190Fh] [ebp-45h]
  char v295; // [esp+1910h] [ebp-44h]
  char v296; // [esp+1911h] [ebp-43h]
  char v297; // [esp+1912h] [ebp-42h]
  char v298; // [esp+1913h] [ebp-41h]
  char v299; // [esp+1914h] [ebp-40h]
  char v300; // [esp+1915h] [ebp-3Fh]
  char v301; // [esp+1916h] [ebp-3Eh]
  char v302; // [esp+1917h] [ebp-3Dh]
  char v303; // [esp+1918h] [ebp-3Ch]
  char v304; // [esp+1919h] [ebp-3Bh]
  char v305; // [esp+191Ah] [ebp-3Ah]
  char v306; // [esp+191Bh] [ebp-39h]
  char v307; // [esp+191Ch] [ebp-38h]
  char v308; // [esp+191Dh] [ebp-37h]
  char v309; // [esp+191Eh] [ebp-36h]
  char v310; // [esp+191Fh] [ebp-35h]
  char v311; // [esp+1920h] [ebp-34h]
  char v312; // [esp+1921h] [ebp-33h]
  char v313; // [esp+1922h] [ebp-32h]
  char v314; // [esp+1923h] [ebp-31h]
  char v315; // [esp+1924h] [ebp-30h]
  char v316; // [esp+1925h] [ebp-2Fh]
  char v317; // [esp+1926h] [ebp-2Eh]
  char v318; // [esp+1927h] [ebp-2Dh]
  char v319; // [esp+1928h] [ebp-2Ch]
  char v320; // [esp+1929h] [ebp-2Bh]
  char v321; // [esp+192Ah] [ebp-2Ah]
  char v322; // [esp+192Bh] [ebp-29h]
  char v323; // [esp+192Ch] [ebp-28h]
  char v324; // [esp+192Dh] [ebp-27h]
  char v325; // [esp+192Eh] [ebp-26h]
  char v326; // [esp+192Fh] [ebp-25h]
  char v327; // [esp+1930h] [ebp-24h]
  char v328; // [esp+1931h] [ebp-23h]
  char v329; // [esp+1932h] [ebp-22h]
  char v330; // [esp+1933h] [ebp-21h]
  char v331; // [esp+1934h] [ebp-20h]
  char v332; // [esp+1935h] [ebp-1Fh]
  char v333; // [esp+1936h] [ebp-1Eh]
  char v334; // [esp+1937h] [ebp-1Dh]
  char v335; // [esp+1938h] [ebp-1Ch]
  char v336; // [esp+1939h] [ebp-1Bh]
  char v337; // [esp+193Ah] [ebp-1Ah]
  char v338; // [esp+193Bh] [ebp-19h]
  char v339; // [esp+193Fh] [ebp-15h]
  DWORD nNumberOfBytesToWrite; // [esp+1940h] [ebp-14h] BYREF
  HCRYPTKEY phKey; // [esp+1944h] [ebp-10h] BYREF
  HCRYPTPROV phProv; // [esp+1948h] [ebp-Ch] BYREF
  CGameGuard *v343; // [esp+194Ch] [ebp-8h]
  DWORD pdwDataLen; // [esp+1950h] [ebp-4h] BYREF

  v343 = this;
  if ( *(_BYTE *)this )
    return (_BYTE *)&loc_755;
  *((_BYTE *)this + 5749) = CGameGuard::IsWinNT(this);
  *((_DWORD *)this + 1410) = GetCurrentProcessId();
  g_dwThreadId = GetCurrentThreadId();
  __mbsnbcpy((unsigned __int8 *)this + 5644, (const unsigned __int8 *)Source, 0x20u);
  *((_BYTE *)this + 5675) = 0;
  CGameGuard::GetGameGuardDirectory(this, &szLogFile, 0x104u);
  if ( __access(&szLogFile, 0) == -1 && !CreateDirectoryA(&szLogFile, 0) )
  {
    v3 = GetLastError;
    GetLastError();
    v213 = v3();
    v4 = _Dect1(&`string');
    CLog::Write((CGameGuard *)((char *)this + 36), v4, v213);
    return (_BYTE *)&unk_6F;
  }
  v6 = (void (__stdcall *)(LPSTR, LPCSTR))lstrcatA;
  lstrcatA(&szLogFile, "\\");
  v7 = _Dect1(&`string');
  v6(&szLogFile, v7);
  v8 = (HANDLE *)((char *)this + 36);
  pbData = 6;
  v263 = 2;
  v264 = 0;
  v265 = 0;
  v266 = 0;
  v267 = -92;
  v268 = 0;
  v269 = 0;
  strcpy(v270, "RSA1");
  v270[5] = 2;
  v270[6] = 0;
  v270[7] = 0;
  v271 = 1;
  v272 = 0;
  v273 = 1;
  v274 = 0;
  v275 = 105;
  v276 = -77;
  v277 = -35;
  v278 = -24;
  v279 = 61;
  v280 = 112;
  v281 = -91;
  v282 = -5;
  v283 = -41;
  v284 = -72;
  v285 = -5;
  v286 = 96;
  v287 = 104;
  v288 = 15;
  v289 = -103;
  v290 = -62;
  v291 = -71;
  v292 = -28;
  v293 = 32;
  v294 = -125;
  v295 = -75;
  v296 = -26;
  v297 = 93;
  v298 = -65;
  v299 = 105;
  v300 = 98;
  v301 = 35;
  v302 = 41;
  v303 = 110;
  v304 = -26;
  v305 = 104;
  v306 = 11;
  v307 = -22;
  v308 = -22;
  v309 = 96;
  v310 = -34;
  v311 = -70;
  v312 = -121;
  v313 = 126;
  v314 = 57;
  v315 = 55;
  v316 = 38;
  v317 = 69;
  v318 = -41;
  v319 = 59;
  v320 = 42;
  v321 = -84;
  v322 = 121;
  v323 = -80;
  v324 = 64;
  v9 = *v8;
  v325 = -78;
  v326 = 38;
  v327 = -53;
  v328 = -37;
  v329 = -72;
  v330 = 77;
  v331 = 85;
  v332 = 18;
  v333 = 23;
  v334 = 101;
  v335 = 23;
  v336 = -55;
  v337 = -123;
  v338 = -70;
  if ( v9 != (HANDLE)-1 )
    goto LABEL_33;
  v8[1294] = 0;
  v8[1295] = _E3 + 4;
  if ( strlen(&szLogFile) <= 3
    || byte_D == 58
    || (GetModuleFileNameA(0, Filename, 0x104u),
        v10 = __mbsrchr((const unsigned __int8 *)Filename, 0x5Cu),
        v11 = (char *)(v10 + 1),
        !v10) )
  {
    v11 = Filename;
  }
  strcpy(v11, &szLogFile);
  v12 = CreateFileA(Filename, 0xC0000000, 1u, 0, 2u, 0x80000080, 0);
  *v8 = v12;
  if ( v12 == (HANDLE)-1 )
  {
LABEL_33:
    v29 = __mbsrchr((const unsigned __int8 *)&szLogFile, 0x2Eu);
    v259 = (unsigned int)v29;
    if ( v29 )
    {
      v30 = 1;
      phKey = 1;
      while ( 1 )
      {
        v215 = v30;
        v31 = _Dect1(&`string');
        _sprintf((char *const)v29, v31, v215);
        pbData = 6;
        v263 = 2;
        v264 = 0;
        v265 = 0;
        v266 = 0;
        v267 = -92;
        v268 = 0;
        v269 = 0;
        strcpy(v270, "RSA1");
        v270[5] = 2;
        v270[6] = 0;
        v270[7] = 0;
        v271 = 1;
        v272 = 0;
        v273 = 1;
        v274 = 0;
        v275 = 105;
        v276 = -77;
        v277 = -35;
        v278 = -24;
        v279 = 61;
        v280 = 112;
        v281 = -91;
        v282 = -5;
        v283 = -41;
        v284 = -72;
        v285 = -5;
        v286 = 96;
        v287 = 104;
        v288 = 15;
        v289 = -103;
        v290 = -62;
        v291 = -71;
        v292 = -28;
        v293 = 32;
        v294 = -125;
        v295 = -75;
        v296 = -26;
        v297 = 93;
        v298 = -65;
        v299 = 105;
        v300 = 98;
        v301 = 35;
        v302 = 41;
        v303 = 110;
        v304 = -26;
        v305 = 104;
        v306 = 11;
        v307 = -22;
        v308 = -22;
        v309 = 96;
        v310 = -34;
        v311 = -70;
        v312 = -121;
        v313 = 126;
        v314 = 57;
        v315 = 55;
        v316 = 38;
        v317 = 69;
        v318 = -41;
        v319 = 59;
        v320 = 42;
        v321 = -84;
        v322 = 121;
        v323 = -80;
        v324 = 64;
        v325 = -78;
        v326 = 38;
        v327 = -53;
        v32 = *v8;
        v328 = -37;
        v329 = -72;
        v330 = 77;
        v331 = 85;
        v332 = 18;
        v333 = 23;
        v334 = 101;
        v335 = 23;
        v336 = -55;
        v337 = -123;
        v338 = -70;
        if ( v32 == (HANDLE)-1 )
        {
          v8[1294] = 0;
          v8[1295] = _E3 + 4;
          if ( strlen(&szLogFile) <= 3
            || byte_D == 58
            || (GetModuleFileNameA(0, Filename, 0x104u),
                v33 = __mbsrchr((const unsigned __int8 *)Filename, 0x5Cu),
                v34 = (char *)(v33 + 1),
                !v33) )
          {
            v34 = Filename;
          }
          strcpy(v34, &szLogFile);
          v35 = CreateFileA(Filename, 0xC0000000, 1u, 0, 2u, 0x80000080, 0);
          *v8 = v35;
          if ( v35 != (HANDLE)-1 )
          {
            GetLocalTime((LPSYSTEMTIME)(v8 + 1031));
            v216 = *((unsigned __int16 *)v8 + 2069);
            v202 = *((unsigned __int16 *)v8 + 2068);
            v194 = *((unsigned __int16 *)v8 + 2067);
            v187 = *((unsigned __int16 *)v8 + 2066);
            v182 = *((unsigned __int16 *)v8 + 2065);
            v178 = *((unsigned __int16 *)v8 + 2063);
            v175 = *((unsigned __int16 *)v8 + 2062);
            v36 = _Dect(&`string');
            _sprintf((char *const)v8 + 28, v36, v175, v178, v182, v187, v194, v202, v216);
            v37 = (char *)v8[1295];
            phKey = strlen((const char *)v8 + 28);
            if ( v37 == (_BYTE *)_E3 + 3 )
              phKey = 0;
            if ( v8[1294] )
            {
              v38 = phKey;
              if ( (int)phKey > 0 )
              {
                v39 = v8 + 7;
                do
                {
                  v40 = (int)v8[1294] + 2;
                  v8[1294] = (HANDLE)v40;
                  *v39++ ^= (_BYTE)v40 + 67;
                }
                while ( (int)&v39[-28 - (_DWORD)v8] < v38 );
              }
            }
            else
            {
              v41 = *((_WORD *)v8 + 2069);
              v42 = (unsigned __int16)((v41 * *((_WORD *)v8 + 2062) * *((_WORD *)v8 + 2063) * *((_WORD *)v8 + 2065) + 1)
                                     * (*((_WORD *)v8 + 2068) + v41 + GetTickCount() + *((_WORD *)v8 + 2067))) | 0xEC000000;
              v8[1035] = (HANDLE)(v42 | (((v42 % 0xA) ^ 0x55) << 16));
              v43 = GetTickCount();
              _srand(v43);
              v44 = _rand;
              for ( i = 0; i < 16; ++i )
                v249[i] = v44();
              RC4_set_key((struct rc4_key_st *)(v8 + 1036), 16, v249);
              phProv = 0;
              nNumberOfBytesToWrite = 0;
              if ( CryptAcquireContextA(&phProv, 0, "Microsoft Base Cryptographic Provider v1.0", 1u, 0xF0000000) )
              {
                if ( CryptImportKey(phProv, &pbData, 0x54u, 0, 0, &nNumberOfBytesToWrite) )
                {
                  pdwDataLen = 0;
                  CryptEncrypt(nNumberOfBytesToWrite, 0, 1, 0, 0, &pdwDataLen, 0);
                  v46 = pdwDataLen;
                  if ( pdwDataLen )
                  {
                    v47 = operator new(pdwDataLen);
                    pdwDataLen = 16;
                    *v47 = *(_DWORD *)v249;
                    v47[1] = v250;
                    v47[2] = v251;
                    v47[3] = v252;
                    *(_BYTE *)v47 ^= 0x3Fu;
                    if ( CryptEncrypt(nNumberOfBytesToWrite, 0, 1, 0, (BYTE *)v47, &pdwDataLen, v46) )
                    {
                      v48 = *v8;
                      Buffer = 13429760;
                      WriteFile(v48, &Buffer, 4u, &pdwDataLen, 0);
                      WriteFile(*v8, v47, v46, &pdwDataLen, 0);
                    }
                    operator delete(v47);
                  }
                  else
                  {
                    v49 = *v8;
                    v50 = (void (__stdcall *)(HANDLE, LPCVOID, DWORD, LPDWORD, LPOVERLAPPED))WriteFile;
                    NumberOfBytesWritten = 13430016;
                    WriteFile(v49, &NumberOfBytesWritten, 4u, &pdwDataLen, 0);
                    for ( j = 0; j < 16; ++j )
                      v248[j] = *(&v274 + j) ^ v249[j];
                    v50(*v8, v248, 0x10u, &pdwDataLen, 0);
                  }
                  CryptDestroyKey(nNumberOfBytesToWrite);
                }
                CryptReleaseContext(phProv, 0);
              }
              RC4((struct rc4_key_st *)(v8 + 1036), phKey, (unsigned __int8 *)v8 + 28, (unsigned __int8 *)v8 + 28);
              v38 = phKey;
            }
            WriteFile(*v8, v8 + 7, v38, &NumberOfBytesRead, 0);
            phKey = 10;
          }
        }
        v30 = ++phKey;
        if ( (int)phKey >= 10 )
          break;
        v29 = (unsigned __int8 *)v259;
      }
    }
  }
  else
  {
    GetLocalTime((LPSYSTEMTIME)(v8 + 1031));
    v214 = *((unsigned __int16 *)v8 + 2069);
    v201 = *((unsigned __int16 *)v8 + 2068);
    v193 = *((unsigned __int16 *)v8 + 2067);
    v186 = *((unsigned __int16 *)v8 + 2066);
    v181 = *((unsigned __int16 *)v8 + 2065);
    v177 = *((unsigned __int16 *)v8 + 2063);
    v174 = *((unsigned __int16 *)v8 + 2062);
    v13 = _Dect(&`string');
    _sprintf((char *const)v8 + 28, v13, v174, v177, v181, v186, v193, v201, v214);
    v14 = (char *)v8[1295];
    nNumberOfBytesToWrite = strlen((const char *)v8 + 28);
    if ( v14 == (_BYTE *)_E3 + 3 )
      nNumberOfBytesToWrite = 0;
    if ( v8[1294] )
    {
      v15 = nNumberOfBytesToWrite;
      if ( (int)nNumberOfBytesToWrite > 0 )
      {
        v16 = v8 + 7;
        do
        {
          v17 = (int)v8[1294] + 2;
          v8[1294] = (HANDLE)v17;
          *v16++ ^= (_BYTE)v17 + 67;
        }
        while ( (int)&v16[-28 - (_DWORD)v8] < v15 );
      }
    }
    else
    {
      v18 = *((_WORD *)v8 + 2069);
      v19 = (unsigned __int16)((v18 * *((_WORD *)v8 + 2062) * *((_WORD *)v8 + 2063) * *((_WORD *)v8 + 2065) + 1)
                             * (*((_WORD *)v8 + 2068) + v18 + GetTickCount() + *((_WORD *)v8 + 2067))) | 0xEC000000;
      v8[1035] = (HANDLE)(v19 | (((v19 % 0xA) ^ 0x55) << 16));
      v20 = GetTickCount();
      _srand(v20);
      v21 = _rand;
      for ( k = 0; k < 16; ++k )
        v254[k] = v21();
      RC4_set_key((struct rc4_key_st *)(v8 + 1036), 16, v254);
      phProv = 0;
      phKey = 0;
      if ( CryptAcquireContextA(&phProv, 0, "Microsoft Base Cryptographic Provider v1.0", 1u, 0xF0000000) )
      {
        if ( CryptImportKey(phProv, &pbData, 0x54u, 0, 0, &phKey) )
        {
          pdwDataLen = 0;
          CryptEncrypt(phKey, 0, 1, 0, 0, &pdwDataLen, 0);
          v23 = pdwDataLen;
          if ( pdwDataLen )
          {
            v24 = operator new(pdwDataLen);
            pdwDataLen = 16;
            *v24 = *(_DWORD *)v254;
            v24[1] = v255;
            v24[2] = Handles;
            v24[3] = NumberOfBytesRead;
            *(_BYTE *)v24 ^= 0x3Fu;
            if ( CryptEncrypt(phKey, 0, 1, 0, (BYTE *)v24, &pdwDataLen, v23) )
            {
              v25 = *v8;
              Buffer = 13429760;
              WriteFile(v25, &Buffer, 4u, &pdwDataLen, 0);
              WriteFile(*v8, v24, v23, &pdwDataLen, 0);
            }
            operator delete(v24);
          }
          else
          {
            v26 = *v8;
            v27 = (void (__stdcall *)(HANDLE, LPCVOID, DWORD, LPDWORD, LPOVERLAPPED))WriteFile;
            v259 = 13430016;
            WriteFile(v26, &v259, 4u, &pdwDataLen, 0);
            for ( l = 0; l < 16; ++l )
              v249[l] = *(&v274 + l) ^ v254[l];
            v27(*v8, v249, 0x10u, &pdwDataLen, 0);
          }
          CryptDestroyKey(phKey);
        }
        CryptReleaseContext(phProv, 0);
      }
      RC4(
        (struct rc4_key_st *)(v8 + 1036),
        nNumberOfBytesToWrite,
        (unsigned __int8 *)v8 + 28,
        (unsigned __int8 *)v8 + 28);
      v15 = nNumberOfBytesToWrite;
    }
    WriteFile(*v8, v8 + 7, v15, &NumberOfBytesWritten, 0);
  }
  v52 = _Dect(&`string');
  CLog::Write((CLog *)v8, v52, 47, "Thu Aug 30 10:21:54 2007");
  v53 = v343;
  v203 = Source;
  v195 = *((_DWORD *)v343 + 1410);
  v54 = _Dect1(&`string');
  CLog::Write((CLog *)v8, v54, v195, v203, InitNPGameMon);
  GetProcessList((int)v8);
  GetModuleList((int)v8);
  v55 = _Dect1(&`string');
  CLog::Write((CLog *)v8, v55);
  CGameGuard::GetGameGuardDirectory(v53, FileName, 0x104u);
  strcat(FileName, "\\");
  strcat(FileName, (const char *)v343 + 5644);
  strcat(FileName, _Dect1(&`string'));
  if ( __access(FileName, 0) == -1 )
  {
    CGameGuard::GetGameDirectory(v343, FileName, 0x104u);
    strcat(FileName, "\\");
    strcat(FileName, (const char *)v343 + 5644);
    strcat(FileName, _Dect1(&`string'));
  }
  v56 = v343;
  v57 = (CGameGuard *)((char *)v343 + 5568);
  if ( CFileAuthClient::Auth((CGameGuard *)((char *)v343 + 5568), FileName, 1) )
  {
    v58 = _Dect1(CONTAINER_NAME);
    if ( CFileAuthClient::DecryptMem2(v57, FileName, v235, 0x7FFu, v58 + 5) )
    {
      v59 = _Dect(&`string');
      v188 = _Dect(&`string');
      v60 = _Dect1(&`string');
      MemGetPrivateProfileString(v59, v60, v188, (char *)Str1, 0x20u, v235);
      if ( !__mbsicmp(Str1, (const unsigned __int8 *)v56 + 5644) )
      {
        v61 = _Dect1(&`string');
        nSendErlIni = MemGetPrivateProfileInt(v59, v61, 1, v235);
        v62 = _Dect1(&`string');
        g_dwNoUseFaq = MemGetPrivateProfileInt(v59, v62, 0, v235);
      }
    }
  }
  if ( *((_BYTE *)v56 + 5768) )
    DisableCompatibleMode(1u);
  if ( !CGameGuard::CheckSingleInstance(v56, 0x251Cu, 1) )
  {
    v63 = _Dect1(&`string');
    CLog::Write((CLog *)v8, v63);
    if ( !dwRE )
      return (_BYTE *)&unk_73;
  }
  if ( !CGameGuard::CheckGameMonSingleInstance(v56, 0) && !dwRE )
  {
    v64 = _Dect1(&`string');
    v65 = OpenEventA(0x100002u, 0, v64);
    v66 = v65;
    if ( !v65 )
      return (_BYTE *)&unk_6E;
    if ( WaitForSingleObject(v65, 0) == 258 )
    {
      SetEvent(v66);
      CloseHandle(v66);
    }
    if ( !CGameGuard::CheckGameMonSingleInstance(v56, 0x251Cu) )
      return (_BYTE *)&unk_6E;
    v67 = _Dect1(&`string');
    CLog::Write((CLog *)v8, v67);
  }
  v68 = GetTickCount();
  v69 = CreateEventA;
  NumberOfBytesWritten = v68 & 0xFFF00000;
  EventAttributes.nLength = 12;
  EventAttributes.lpSecurityDescriptor = 0;
  EventAttributes.bInheritHandle = 1;
  v70 = CreateEventA(&EventAttributes, 0, 0, 0);
  *((_DWORD *)v56 + 1441) = v70;
  if ( !v70 )
  {
    v71 = GetLastError;
    GetLastError();
    v217 = v71();
    v72 = _Dect1(`string');
LABEL_91:
    CLog::Write((CLog *)v8, v72, v217);
    return (_BYTE *)&unk_AB;
  }
  v73 = v69(&EventAttributes, 1, 0, 0);
  *((_DWORD *)v56 + 6) = v73;
  if ( !v73 )
  {
    v74 = GetLastError;
    GetLastError();
    v217 = v74();
    v72 = _Dect1(`string');
    goto LABEL_91;
  }
  v75 = v69(&EventAttributes, 0, 0, 0);
  *((_DWORD *)v56 + 1440) = v75;
  if ( !v75 )
  {
    v76 = GetLastError;
    GetLastError();
    v217 = v76();
    v72 = _Dect1(&`string');
    goto LABEL_91;
  }
  v77 = _Dect1(&`string');
  CLog::Write((CLog *)v8, v77);
  CGameGuard::GetGameDirectory(v343, ApplicationName, 0x104u);
  strcat(ApplicationName, "\\");
  strcat(ApplicationName, _Dect1(&`string'));
  if ( __access(ApplicationName, 0) == -1 )
  {
    v78 = _Dect1(&`string');
    CLog::Write((CLog *)v8, v78, ApplicationName);
    return (_BYTE *)&unk_99;
  }
  v79 = v343;
  v339 = 0;
  if ( !CFileAuthClient::Auth((CGameGuard *)((char *)v343 + 5568), ApplicationName, 1) )
  {
    HIBYTE(Source) = 0;
    if ( *((_DWORD *)v79 + 1409) == 8 && GetLastError() == -2146893818 )
      HIBYTE(Source) = 1;
    GetLastError();
    v80 = *((_DWORD *)v79 + 1409);
    v204 = GetLastError();
    v81 = _Dect1(&`string');
    CLog::Write((CLog *)v8, v81, v80, v204, ApplicationName);
    v82 = CreateFileA(ApplicationName, 0x80000000, 3u, 0, 3u, 0x80u, 0);
    v83 = v82;
    if ( v82 == (HANDLE)-1 )
    {
      v205 = GetLastError();
      v84 = _Dect1(&`string');
      CLog::Write((CLog *)v8, v84, v205, ApplicationName);
    }
    else
    {
      v218 = GetFileSize(v82, 0);
      v85 = _Dect1(&`string');
      CLog::Write((CLog *)v8, v85, v218);
      SetFilePointer(v83, -4, 0, 2u);
      phProv = 0;
      ReadFile(v83, &phProv, 4u, &NumberOfBytesRead, 0);
      v219 = phProv;
      v86 = _Dect1(&`string');
      CLog::Write((CLog *)v8, v86, v219);
      CloseHandle(v83);
    }
    if ( !HIBYTE(Source) )
      goto LABEL_110;
    if ( *((_BYTE *)v79 + 5749) || !CheckRsaBase() )
      return (_BYTE *)&unk_9B;
    if ( !CFileAuthClient::Auth((CGameGuard *)((char *)v79 + 5568), ApplicationName, 1) )
    {
      if ( *((_DWORD *)v79 + 1409) == 8 && GetLastError() == -2146893818 )
        return (_BYTE *)&unk_9B;
      v339 = 1;
    }
    v87 = _Dect1(&`string');
    CLog::Write((CLog *)v8, v87);
    if ( v339 )
    {
LABEL_110:
      v88 = _Dect1(&`string');
      CLog::Write((CLog *)v8, v88);
      return (_BYTE *)&unk_7C;
    }
  }
  v89 = _Dect1(&`string');
  CLog::Write((CLog *)v8, v89);
  memset(&StartupInfo, 0, sizeof(StartupInfo));
  v90 = *((_DWORD *)v79 + 1410);
  ProcessInformation.hProcess = 0;
  ProcessInformation.hThread = 0;
  StartupInfo.cb = 68;
  ProcessInformation.dwProcessId = 0;
  v220 = dwDE;
  v91 = *((_DWORD *)v79 + 1441);
  ProcessInformation.dwThreadId = 0;
  v206 = v90;
  v196 = *((_DWORD *)v79 + 6);
  v189 = v91;
  v179 = NumberOfBytesWritten;
  v92 = _Dect1(&`string');
  _wsprintfA(v238, v92, v179, (char *)v79 + 5644, v189, v196, v206, v220);
  v93 = _Dect1(&`string');
  CLog::Write((CLog *)v8, v93, v238);
  Source = _Enct(v238);
  pdwDataLen = (DWORD)CommandLine;
  v94 = strlen(v238) + 1;
  v95 = _Dect1(&`string');
  CLog::Write((CLog *)v8, v95, v94 - 1);
  if ( (int)(v94 - 1 + 4) <= 0 )
  {
    v96 = (CHAR *)pdwDataLen;
  }
  else
  {
    v96 = (CHAR *)pdwDataLen;
    phProv = v94 - 1 + 4;
    do
    {
      v221 = *(unsigned __int8 *)Source++;
      v96 += _wsprintfA(v96, "\\x%02x", v221);
      --phProv;
    }
    while ( phProv );
  }
  *v96 = 0;
  v97 = _Dect1(&`string');
  CLog::Write((CLog *)v8, v97, CommandLine);
  phProv = 0;
  if ( dwRE )
  {
LABEL_124:
    v105 = (void (__stdcall *)(HANDLE))CloseHandle;
    CloseHandle(ProcessInformation.hProcess);
    v105(ProcessInformation.hThread);
    CGameGuard::GetGameGuardDirectory(v343, FileName, 0x104u);
    strcat(FileName, "\\");
    strcat(FileName, (const char *)v343 + 5644);
    strcat(FileName, _Dect1(&`string'));
    if ( !CFileAuthClient::Auth((CGameGuard *)((char *)v343 + 5568), FileName, 1) )
    {
      v106 = GetLastError;
      GetLastError();
      v107 = (const char *)*((_DWORD *)v343 + 1409);
      v225 = v106();
      v208 = v107;
      v108 = _Dect1(`string');
LABEL_142:
      CLog::Write((CLog *)v8, v108, v208, v225);
      return (_BYTE *)&unk_78;
    }
    v109 = _Dect1(CONTAINER_NAME);
    v110 = v343;
    if ( !CFileAuthClient::DecryptMem2((CGameGuard *)((char *)v343 + 5568), FileName, v236, 0x7FFu, v109 + 5) )
    {
      v111 = GetLastError;
      GetLastError();
      v112 = *((_DWORD *)v110 + 1409);
      v226 = v111();
      v113 = _Dect1(&`string');
      CLog::Write((CLog *)v8, v113, v112, v226);
      return (_BYTE *)&unk_82;
    }
    v114 = _Dect(&`string');
    v190 = _Dect(&`string');
    v115 = _Dect1(&`string');
    MemGetPrivateProfileString(v114, v115, v190, v246, 0x20u, v236);
    if ( __mbsicmp((const unsigned __int8 *)v246, (const unsigned __int8 *)v110 + 5644) )
    {
      v116 = _Dect1(&`string');
      CLog::Write((CLog *)v8, v116);
      return (_BYTE *)&unk_8E;
    }
    v117 = _Dect1(&`string');
    nSendErlIni = MemGetPrivateProfileInt(v114, v117, 1, v236);
    v118 = _Dect1(&`string');
    g_dwWaitTime = MemGetPrivateProfileInt(v114, v118, 100000, v236);
    v119 = _Dect1(&`string');
    g_dwNoUpdate = MemGetPrivateProfileInt(v114, v119, 0, v236);
    v120 = _Dect1(&`string');
    Source = (const char *)MemGetPrivateProfileInt(v114, v120, 0, v236);
    v121 = _Dect1(&`string');
    NumberOfBytesWritten = MemGetPrivateProfileInt(v114, v121, 0, v236);
    v122 = _Dect1(&`string');
    g_dwNoUseFaq = MemGetPrivateProfileInt(v114, v122, 0, v236);
    v123 = _Dect1(&`string');
    v259 = MemGetPrivateProfileInt(v114, v123, 0, v236);
    v124 = _Dect1(&`string');
    v125 = MemGetPrivateProfileInt(v114, v124, 0, v236);
    v126 = v343;
    *((_BYTE *)v343 + 34) = (v125 & 2) == 0;
    v127 = _Dect1(&`string');
    *((_DWORD *)v126 + 1438) = MemGetPrivateProfileInt(v114, v127, 1000, v236);
    v128 = _Dect1(&`string');
    *((_DWORD *)v126 + 1439) = MemGetPrivateProfileInt(v114, v128, 0, v236);
    memset(v236, 0, sizeof(v236));
    v129 = _Dect1(&`string');
    CLog::Write((CLog *)v8, v129);
    CGameGuard::GetGameGuardDirectory(v126, szGameMon, 0x104u);
    strcat(szGameMon, "\\");
    strcat(szGameMon, _Dect1(&`string'));
    if ( gg )
    {
      v227 = *((unsigned __int8 *)GetProcAddress + 4);
      v209 = *((unsigned __int8 *)GetProcAddress + 3);
      v198 = *((unsigned __int8 *)GetProcAddress + 2);
      v191 = *((unsigned __int8 *)GetProcAddress + 1);
      v183 = *(unsigned __int8 *)GetProcAddress;
      v130 = _Dect1(&`string');
      CLog::Write((CGameGuard *)((char *)gg + 36), v130, v183, v191, v198, v209, v227);
      if ( gg )
      {
        v228 = *((unsigned __int8 *)GetModuleHandleA + 4);
        v210 = *((unsigned __int8 *)GetModuleHandleA + 3);
        v199 = *((unsigned __int8 *)GetModuleHandleA + 2);
        v192 = *((unsigned __int8 *)GetModuleHandleA + 1);
        v184 = *(unsigned __int8 *)GetModuleHandleA;
        v131 = _Dect1(&`string');
        CLog::Write((CGameGuard *)((char *)gg + 36), v131, v184, v192, v199, v210, v228);
      }
    }
    v132 = _Dect1(&`string');
    CLog::Write((CLog *)v8, v132);
    if ( __access(szGameMon, 0) == -1 )
    {
      CGameGuard::GetGameGuardDirectory(v343, szGameMon, 0x104u);
      strcat(szGameMon, "\\");
      strcat(szGameMon, _Dect1(&`string'));
      if ( __access(szGameMon, 0) == -1 )
      {
        v133 = _Dect1(&`string');
        CLog::Write((CLog *)v8, v133, szGameMon);
        return (_BYTE *)&unk_9A;
      }
    }
    v134 = v343;
    if ( !CFileAuthClient::Auth((CGameGuard *)((char *)v343 + 5568), szGameMon, 1) )
    {
      v135 = GetLastError;
      GetLastError();
      v136 = *((_DWORD *)v134 + 1409);
      v211 = v135();
      v137 = _Dect1(&`string');
      CLog::Write((CLog *)v8, v137, v136, v211, szGameMon);
      return (_BYTE *)&unk_7A;
    }
    v138 = _Dect1(&`string');
    CLog::Write((CLog *)v8, v138);
    if ( !CCommPipe::InitCommPipe((CGameGuard *)((char *)v134 + 5224)) )
    {
      v139 = _Dect1(&`string');
      CLog::Write((CLog *)v8, v139);
      return (_BYTE *)&unk_A0;
    }
    SetThreadPriority(*((HANDLE *)v134 + 1306), 2);
    v140 = _Dect1(&`string');
    CLog::Write((CLog *)v8, v140);
    v141 = GetTickCount() & 0xFFF00000;
    if ( (unsigned int)Source < 0x2F )
    {
      v225 = 47;
      v208 = Source;
      v108 = _Dect1(&`string');
      goto LABEL_142;
    }
    v229 = NumberOfBytesWritten;
    v212 = *((_DWORD *)v134 + 1441);
    v200 = *((_DWORD *)v134 + 1440);
    v185 = CCommPipe::GetChildWriteHandle((CGameGuard *)((char *)v134 + 5224));
    v180 = CCommPipe::GetChildReadHandle((CGameGuard *)((char *)v134 + 5224));
    v176 = *((unsigned __int8 *)v134 + 5749);
    v173 = *((_DWORD *)v134 + 1410);
    v142 = _Dect1(&`string');
    _wsprintfA(v238, v142, v141, v173, v176, v180, v185, (char *)v134 + 5644, v200, v212, v229);
    v143 = (void *)*((_DWORD *)v134 + 1441);
    memset(&StartupInfo, 0, sizeof(StartupInfo));
    ProcessInformation.hProcess = 0;
    StartupInfo.cb = 68;
    ProcessInformation.hThread = 0;
    ProcessInformation.dwProcessId = 0;
    ProcessInformation.dwThreadId = 0;
    ResetEvent(v143);
    Source = _Enct(v238);
    pdwDataLen = (DWORD)CommandLine;
    v144 = strlen(v238) + 1;
    if ( (int)(v144 - 1 + 4) <= 0 )
    {
      v145 = (CHAR *)pdwDataLen;
    }
    else
    {
      v145 = (CHAR *)pdwDataLen;
      nNumberOfBytesToWrite = v144 - 1 + 4;
      do
      {
        v230 = *(unsigned __int8 *)Source++;
        v145 += _wsprintfA(v145, "\\x%02x", v230);
        --nNumberOfBytesToWrite;
      }
      while ( nNumberOfBytesToWrite );
    }
    *v145 = 0;
    v146 = _Dect1(&`string');
    CLog::Write((CLog *)v8, v146);
    if ( !dwDE )
    {
      if ( dwRE )
      {
        v147 = strlen(CommandLine) + 1;
        v241 = 2027;
        v242 = *((_DWORD *)v343 + 1410);
        Source = v243;
        *(_DWORD *)Filename = v147 - 1 + 13;
        strcpy(v243, CommandLine);
        if ( !WriteSMMsg(Filename, v147 - 1 + 13) )
        {
          v148 = GetLastError;
          GetLastError();
          v207 = szGameMon;
          v197 = (CHAR *)v148();
          v149 = _Dect1(`string');
LABEL_155:
          CLog::Write((CLog *)v8, v149, v197, v207, v238);
          return (_BYTE *)&unk_AA;
        }
        v134 = v343;
      }
      else
      {
        if ( !CreateProcessA(szGameMon, CommandLine, 0, 0, 0, 4u, 0, 0, &StartupInfo, &ProcessInformation) )
        {
          v150 = GetLastError;
          GetLastError();
          v207 = (char *)v150();
          v197 = szGameMon;
          goto LABEL_154;
        }
        v231 = ProcessInformation.dwProcessId;
        v151 = _Dect1(&`string');
        CLog::Write((CLog *)v8, v151, v231);
      }
    }
    bCheckGameMon = g_dwNoUpdate;
    if ( !g_dwNoUpdate )
    {
      bCheckGameMon = v259;
      if ( !v259 )
      {
        bCheckGameMon = dwRE;
        if ( !dwRE )
        {
          LOBYTE(bCheckGameMon) = CheckGameMonCrc(szGameMon, &`string', phProv);
          bCheckGameMon = (unsigned __int8)bCheckGameMon;
        }
      }
    }
    v152 = _Dect1(&`string');
    CLog::Write((CLog *)v8, v152);
    v153 = CCommPipe::RunCommPipe((CGameGuard *)((char *)v134 + 5224));
    if ( !v153 )
    {
      v154 = GetLastError;
      GetLastError();
      v232 = v154();
      v155 = _Dect1(&`string');
      CLog::Write((CLog *)v8, v155, v232);
      return (_BYTE *)&unk_A0;
    }
    v233 = v153;
    v156 = _Dect1(&`string');
    CLog::Write((CLog *)v8, v156, v233);
    if ( dwDE || dwRE )
    {
      if ( WaitForSingleObject(*((HANDLE *)v134 + 1440), g_dwWaitTime) )
        goto LABEL_171;
    }
    else
    {
      ResumeThread(ProcessInformation.hThread);
      Handles = (HANDLE)*((_DWORD *)v134 + 1440);
      NumberOfBytesRead = (DWORD)ProcessInformation.hProcess;
      if ( WaitForMultipleObjects(2u, &Handles, 0, g_dwWaitTime) )
      {
        v157 = _Dect1(&`string');
        v158 = OpenEventA(0x100000u, 0, v157);
        if ( v158 )
        {
          CloseHandle(v158);
          if ( WaitForSingleObject(*((HANDLE *)v134 + 1440), g_dwWaitTime) )
          {
            v234 = g_dwWaitTime;
            v159 = _Dect1(`string');
LABEL_172:
            CLog::Write((CLog *)v8, v159, v234);
            return (_BYTE *)&unk_72;
          }
          goto LABEL_173;
        }
LABEL_171:
        v234 = g_dwWaitTime;
        v159 = _Dect1(&`string');
        goto LABEL_172;
      }
    }
LABEL_173:
    v160 = _Dect1(&`string');
    CLog::Write((CLog *)v8, v160);
    if ( WaitForSingleObject(*((HANDLE *)v134 + 1441), 0) )
    {
      v161 = _Dect1(&`string');
      CLog::Write((CLog *)v8, v161);
      return (_BYTE *)&unk_72;
    }
    v162 = _Dect1(&`string');
    v163 = OpenEventA(0x100000u, 0, v162);
    if ( v163 )
    {
      CloseHandle(v163);
      v164 = _Dect1(&`string');
      CLog::Write((CLog *)v8, v164);
    }
    else
    {
      dwGameMonPID = ProcessInformation.dwProcessId;
      hGameMonHandle = ProcessInformation.hProcess;
    }
    v165 = _Dect1(&`string');
    CLog::Write((CLog *)v8, v165);
    if ( !bCheckGameMon )
      return (_BYTE *)&unk_7A;
    CheckEncryptedClient();
    v166 = InitTimeAddr();
    if ( !v166 )
      CommPipeCallback((int)v8, (CGameGuard *)((char *)v134 + 5224), 0x62Du, 0xBu);
    v167 = _Dect1(&`string');
    CLog::Write((CLog *)v8, v167, v166);
    v168 = InitSocketAddr((int)v8);
    if ( !v168 )
      CCommPipe::SendCommPipe((CGameGuard *)((char *)v134 + 5224), 0x8B1u, 0x630u, 0xDu);
    v169 = _Dect1(&`string');
    CLog::Write((CLog *)v8, v169, v168);
    if ( *((_BYTE *)v134 + 34) && !CGameGuard::InitNPSC(v134) )
    {
      v170 = _Dect1(&`string');
      CLog::Write((CLog *)v8, v170);
      return (_BYTE *)&unk_DC;
    }
    v171 = _Dect1(&`string');
    CLog::Write((CLog *)v8, v171);
    CCommPipe::SendCommPipe((CGameGuard *)((char *)v134 + 5224), 0x8B1u, 0x611u, *((_DWORD *)v134 + 1410));
    CCommPipe::SendCommPipe((CGameGuard *)((char *)v134 + 5224), 0x8B1u, 0x617u, phProv);
    v172 = _Dect1(&`string');
    CLog::Write((CLog *)v8, v172);
    *(_BYTE *)v134 = 1;
    return (_BYTE *)&loc_755;
  }
  if ( !CreateProcessA(ApplicationName, CommandLine, 0, 0, 1, 0, 0, 0, &StartupInfo, &ProcessInformation) )
  {
    v98 = GetLastError;
    GetLastError();
    v207 = (char *)v98();
    v197 = ApplicationName;
LABEL_154:
    v149 = _Dect1(&`string');
    goto LABEL_155;
  }
  v222 = ProcessInformation.dwProcessId;
  v99 = _Dect1(&`string');
  CLog::Write((CLog *)v8, v99, v222);
  v100 = (void *)*((_DWORD *)v79 + 1441);
  Source = 0;
  Handles = v100;
  NumberOfBytesRead = (DWORD)ProcessInformation.hProcess;
  if ( !WaitForMultipleObjects(2u, &Handles, 0, 0xFFFFFFFF) )
  {
    v104 = _Dect1(&`string');
    CLog::Write((CLog *)v8, v104);
    phProv = ReadMemCrc(&ProcessInformation);
    goto LABEL_124;
  }
  if ( !GetExitCodeProcess(ProcessInformation.hProcess, (LPDWORD)&Source) )
  {
    v223 = GetLastError();
    v101 = _Dect1(&`string');
    CLog::Write((CLog *)v8, v101, v223);
  }
  v224 = Source;
  v102 = _Dect1(&`string');
  CLog::Write((CLog *)v8, v102, v224);
  v103 = (void (__stdcall *)(HANDLE))CloseHandle;
  CloseHandle(ProcessInformation.hProcess);
  v103(ProcessInformation.hThread);
  return Source;
}
// D: using guessed type char byte_D;
// 334: using guessed type int g_dwThreadId;
// 33C: using guessed type int g_dwNoUpdate;
// 340: using guessed type int g_dwNoUseFaq;
// 350: using guessed type int bCheckGameMon;
// 354: using guessed type int dwDE;
// 358: using guessed type int dwRE;
// 35C: using guessed type unsigned int dwGameMonPID;
// 3A4: using guessed type int nSendErlIni;

//----- (00003390) --------------------------------------------------------
void __thiscall CCriticalSector::~CCriticalSector(LPCRITICAL_SECTION lpCriticalSection)
{
  DeleteCriticalSection(lpCriticalSection);
}

//----- (000033A0) --------------------------------------------------------
void __thiscall CLog::~CLog(CLog *this)
{
  HANDLE v2; // eax
  unsigned __int16 *v3; // edi
  unsigned int v4; // eax
  bool v5; // cc
  void *v6; // eax
  const char *v7; // eax
  signed int v8; // ecx
  DWORD v9; // edi
  char *v10; // eax
  int v11; // edx
  int v12; // [esp-2Ch] [ebp-40h]
  int v13; // [esp-28h] [ebp-3Ch]
  int v14; // [esp-24h] [ebp-38h]
  int v15; // [esp-20h] [ebp-34h]
  int v16; // [esp-1Ch] [ebp-30h]
  int v17; // [esp-18h] [ebp-2Ch]
  int v18; // [esp-14h] [ebp-28h]
  void *v19; // [esp-10h] [ebp-24h]
  DWORD NumberOfBytesWritten; // [esp+4h] [ebp-10h] BYREF
  unsigned int v21[2]; // [esp+8h] [ebp-Ch] BYREF
  int v22; // [esp+10h] [ebp-4h]

  v22 = -1;
  v21[1] = (unsigned int)&_L63751;
  v21[0] = __readfsdword((unsigned int)&_except_list);
  __writefsdword((unsigned int)&_except_list, (unsigned int)v21);
  v2 = *(HANDLE *)this;
  v22 = 0;
  if ( v2 != (HANDLE)-1 )
  {
    v3 = (unsigned __int16 *)((char *)this + 4124);
    GetLocalTime((LPSYSTEMTIME)((char *)this + 4124));
    v4 = *((_DWORD *)this + 1295);
    if ( !v4 || (v5 = *((_DWORD *)this + 1296) <= v4, v6 = &`string', v5) )
      v6 = &`string';
    v19 = v6;
    v18 = *((unsigned __int16 *)this + 2069);
    v17 = *((unsigned __int16 *)this + 2068);
    v16 = *((unsigned __int16 *)this + 2067);
    v15 = *((unsigned __int16 *)this + 2066);
    v14 = *((unsigned __int16 *)this + 2065);
    v13 = *((unsigned __int16 *)this + 2063);
    v12 = *v3;
    v7 = _Dect(&`string');
    _sprintf((char *const)this + 28, v7, v12, v13, v14, v15, v16, v17, v18, v19);
    v8 = strlen((const char *)this + 28);
    v9 = v8;
    if ( *((_DWORD *)this + 1294) )
    {
      if ( v8 > 0 )
      {
        v10 = (char *)this + 28;
        do
        {
          v11 = *((_DWORD *)this + 1294) + 2;
          *((_DWORD *)this + 1294) = v11;
          *v10++ ^= v11 + 67;
        }
        while ( (int)&v10[-28 - (_DWORD)this] < v8 );
      }
    }
    else
    {
      RC4((CLog *)((char *)this + 4144), v8, (unsigned __int8 *)this + 28, (unsigned __int8 *)this + 28);
    }
    if ( *((_DWORD *)this + 1295) != 999 )
      WriteFile(*(HANDLE *)this, (char *)this + 28, v9, &NumberOfBytesWritten, 0);
    SetEndOfFile(*(HANDLE *)this);
    CloseHandle(*(HANDLE *)this);
    *(_DWORD *)this = -1;
  }
  DeleteCriticalSection((LPCRITICAL_SECTION)((char *)this + 4));
  __writefsdword((unsigned int)&_except_list, v21[0]);
}

//----- (00003510) --------------------------------------------------------
void __usercall _L63726(int a1@<ebp>)
{
  CCriticalSector::~CCriticalSector((LPCRITICAL_SECTION)(*(_DWORD *)(a1 - 20) + 4));
}

//----- (00003550) --------------------------------------------------------
char CLog::Write(CLog *this, const char *Format, ...)
{
  unsigned int v2; // eax
  unsigned int v3; // ecx
  struct _RTL_CRITICAL_SECTION *v4; // ebp
  void (*v5)(char *const, const char *const, ...); // edi
  const char *v6; // eax
  signed int v7; // ecx
  DWORD v8; // edi
  char *v9; // eax
  int v10; // edx
  int v12; // [esp-18h] [ebp-102Ch]
  int v13; // [esp-14h] [ebp-1028h]
  int v14; // [esp-10h] [ebp-1024h]
  int v15; // [esp-Ch] [ebp-1020h]
  DWORD NumberOfBytesWritten; // [esp+10h] [ebp-1004h] BYREF
  char Buffer[4096]; // [esp+14h] [ebp-1000h] BYREF
  va_list ArgList; // [esp+1020h] [ebp+Ch] BYREF

  va_start(ArgList, Format);
  if ( *(_DWORD *)this == -1 )
    return 0;
  v2 = *((_DWORD *)this + 1295);
  if ( v2 && *Format != 33 )
  {
    v3 = *((_DWORD *)this + 1296);
    if ( v3 > v2 )
      return 0;
    *((_DWORD *)this + 1296) = v3 + 1;
  }
  v4 = (struct _RTL_CRITICAL_SECTION *)((char *)this + 4);
  EnterCriticalSection((LPCRITICAL_SECTION)((char *)this + 4));
  _vsprintf(Buffer, Format, ArgList);
  GetLocalTime((LPSYSTEMTIME)((char *)this + 4124));
  v5 = (void (*)(char *const, const char *const, ...))_sprintf;
  if ( *(_BYTE *)_sprintf == 0xCC || *(_BYTE *)WriteFile == 0xCC )
  {
    LeaveCriticalSection((LPCRITICAL_SECTION)((char *)this + 4));
    return 0;
  }
  v15 = *((unsigned __int16 *)this + 2069);
  v14 = *((unsigned __int16 *)this + 2068);
  v13 = *((unsigned __int16 *)this + 2067);
  v12 = *((unsigned __int16 *)this + 2066);
  v6 = _Dect(&`string');
  v5((char *const)this + 28, v6, v12, v13, v14, v15, Buffer);
  v7 = strlen((const char *)this + 28);
  v8 = v7;
  if ( *((_DWORD *)this + 1294) )
  {
    if ( v7 > 0 )
    {
      v9 = (char *)this + 28;
      do
      {
        v10 = *((_DWORD *)this + 1294) + 2;
        *((_DWORD *)this + 1294) = v10;
        *v9++ ^= v10 + 67;
      }
      while ( (int)&v9[-28 - (_DWORD)this] < v7 );
      v4 = (struct _RTL_CRITICAL_SECTION *)((char *)this + 4);
    }
  }
  else
  {
    RC4((CLog *)((char *)this + 4144), v7, (unsigned __int8 *)this + 28, (unsigned __int8 *)this + 28);
  }
  WriteFile(*(HANDLE *)this, (char *)this + 28, v8, &NumberOfBytesWritten, 0);
  LeaveCriticalSection(v4);
  return 1;
}

//----- (000036F0) --------------------------------------------------------
void __userpurge CGameGuard::SetHwndToGameMonI(CGameGuard *this@<ecx>, int a2@<ebx>, HWND a3)
{
  CLog *v4; // edi
  const char *v5; // eax
  const char *v6; // eax
  const char *v7; // eax
  const char *v8; // eax
  int v9; // [esp-8h] [ebp-10h]
  int v10; // [esp-4h] [ebp-Ch]

  v4 = (CGameGuard *)((char *)this + 36);
  v5 = _Dect1(&`string');
  CLog::Write(v4, v5);
  GetProcessList(a2);
  GetModuleList(a2);
  *((_DWORD *)this + 1) = a3;
  CCommPipe::SendCommPipe((CGameGuard *)((char *)this + 5224), 0x8B1u, 0x612u, (unsigned int)a3);
  if ( *((_DWORD *)this + 2) )
  {
    v10 = *((_DWORD *)this + 3);
    v9 = *((_DWORD *)this + 2);
    v6 = _Dect1(&`string');
    CLog::Write(v4, v6, v9, v10);
    if ( !NPGameMonCallback(*((_DWORD *)this + 2), *((_DWORD *)this + 3)) )
    {
      v7 = _Dect1(&`string');
      CLog::Write(v4, v7);
    }
  }
  v8 = _Dect1(&`string');
  CLog::Write(v4, v8);
}

//----- (00003814) --------------------------------------------------------
void __thiscall CGameGuard::RunFAQWebPageI(CGameGuard *this, unsigned int a2)
{
  int v2; // eax
  void (*v3)(char *const, const char *const, ...); // ebp
  CGameGuard *v4; // esi
  const char *v5; // eax
  const char *v6; // eax
  const char *v7; // eax
  const char *v8; // eax
  const CHAR *v9; // eax
  const unsigned __int8 *v10; // eax
  int (__cdecl *v11)(const unsigned __int8 *, const unsigned __int8 *); // esi
  const char *v12; // eax
  const unsigned __int8 *v13; // eax
  const unsigned __int8 *v14; // eax
  const unsigned __int8 *v15; // eax
  const char *v16; // [esp-8h] [ebp-4F4h]
  const char *v17; // [esp-8h] [ebp-4F4h]
  const char *v18; // [esp-8h] [ebp-4F4h]
  char *v19; // [esp-4h] [ebp-4F0h]
  DWORD v20; // [esp-4h] [ebp-4F0h]
  DWORD v21; // [esp-4h] [ebp-4F0h]
  __int128 v22; // [esp+10h] [ebp-4DCh] BYREF
  HKEY phkResult; // [esp+20h] [ebp-4CCh] BYREF
  CGameGuard *v24; // [esp+24h] [ebp-4C8h]
  CHAR LCData[8]; // [esp+28h] [ebp-4C4h] BYREF
  DWORD cbData; // [esp+30h] [ebp-4BCh] BYREF
  struct _PROCESS_INFORMATION ProcessInformation; // [esp+34h] [ebp-4B8h] BYREF
  struct _PROCESS_INFORMATION v28; // [esp+44h] [ebp-4A8h] BYREF
  CHAR CommandLine; // [esp+54h] [ebp-498h] BYREF
  char v30[256]; // [esp+55h] [ebp-497h] BYREF
  __int16 v31; // [esp+155h] [ebp-397h]
  char v32; // [esp+157h] [ebp-395h]
  struct _STARTUPINFOA v33; // [esp+158h] [ebp-394h] BYREF
  struct _STARTUPINFOA StartupInfo; // [esp+19Ch] [ebp-350h] BYREF
  CHAR Buffer; // [esp+1E0h] [ebp-30Ch] BYREF
  char v36[256]; // [esp+1E1h] [ebp-30Bh] BYREF
  __int16 v37; // [esp+2E1h] [ebp-20Bh]
  char v38; // [esp+2E3h] [ebp-209h]
  BYTE Data; // [esp+2E4h] [ebp-208h] BYREF
  char v40[516]; // [esp+2E5h] [ebp-207h] BYREF
  __int16 v41; // [esp+4E9h] [ebp-3h]
  char v42; // [esp+4EBh] [ebp-1h]

  v24 = this;
  if ( !g_dwNoUseFaq )
  {
    v22 = 0ui64;
    Buffer = 0;
    memset(v36, 0, sizeof(v36));
    v37 = 0;
    v38 = 0;
    GetCurrentDirectoryA(0x104u, &Buffer);
    strcat(&Buffer, _Dect1(&`string'));
    v2 = __access(&Buffer, 0);
    v3 = (void (*)(char *const, const char *const, ...))_sprintf;
    if ( v2 != -1 )
    {
      _sprintf((char *const)&v22, "%ld", &v22);
      CommandLine = 0;
      memset(v30, 0, sizeof(v30));
      v4 = v24;
      v31 = 0;
      v32 = 0;
      v19 = (char *)v24 + 5644;
      v5 = _Dect1(&`string');
      v3(&CommandLine, v5, &Buffer, &v22, v19);
      memset(&StartupInfo, 0, sizeof(StartupInfo));
      ProcessInformation.hProcess = 0;
      ProcessInformation.hThread = 0;
      ProcessInformation.dwProcessId = 0;
      ProcessInformation.dwThreadId = 0;
      StartupInfo.cb = 68;
      if ( CreateProcessA(0, &CommandLine, 0, 0, 0, 0, 0, 0, &StartupInfo, &ProcessInformation) )
      {
        v7 = _Dect1(&`string');
        CLog::Write((CGameGuard *)((char *)v4 + 36), v7, &CommandLine);
        WaitForSingleObject(ProcessInformation.hProcess, 0xFFFFFFFF);
      }
      else
      {
        v20 = GetLastError();
        v6 = _Dect1(&`string');
        CLog::Write((CGameGuard *)((char *)v4 + 36), v6, v20);
      }
    }
    v22 = 0ui64;
    switch ( a2 )
    {
      case 0x73u:
        v8 = _Dect1(`string');
        break;
      case 0x96u:
      case 0x99u:
      case 0x7Cu:
        v8 = _Dect1(&`string');
        break;
      case 0x72u:
      case 0x64u:
        v8 = _Dect1(`string');
        break;
      case 0x4E21u:
        v8 = _Dect1(`string');
        break;
      case 0x4E22u:
        v8 = _Dect1(`string');
        break;
      case 0x4E23u:
        v8 = _Dect1(`string');
        break;
      case 0x4E24u:
        v8 = _Dect1(`string');
        break;
      case 0x4E25u:
        v8 = _Dect1(`string');
        break;
      case 0x4E26u:
        v8 = _Dect1(`string');
        break;
      case 0x4E27u:
        v8 = _Dect1(`string');
        break;
      default:
        return;
    }
    strcpy((char *)&v22, v8);
    memset(&v33, 0, sizeof(v33));
    v28.hProcess = 0;
    Data = 0;
    v28.hThread = 0;
    v28.dwProcessId = 0;
    v28.dwThreadId = 0;
    memset(v40, 0, sizeof(v40));
    v41 = 0;
    v33.cb = 68;
    phkResult = 0;
    cbData = 260;
    v42 = 0;
    v9 = _Dect1(&`string');
    RegOpenKeyExA(HKEY_LOCAL_MACHINE, v9, 0, 1u, &phkResult);
    if ( !phkResult || RegQueryValueExA(phkResult, 0, 0, 0, &Data, &cbData) )
      goto LABEL_43;
    GetLocaleInfoA(0x800u, 1u, LCData, 6);
    CommandLine = 0;
    memset(v30, 0, sizeof(v30));
    v31 = 0;
    v32 = 0;
    v10 = (const unsigned __int8 *)_Dect1(&`string');
    v11 = __mbsicmp;
    if ( __mbsicmp((const unsigned __int8 *)LCData, v10) )
    {
      v13 = (const unsigned __int8 *)_Dect1(&`string');
      if ( v11((const unsigned __int8 *)LCData, v13) )
      {
        v14 = (const unsigned __int8 *)_Dect1(&`string');
        if ( v11((const unsigned __int8 *)LCData, v14) )
        {
          v15 = (const unsigned __int8 *)_Dect1(&`string');
          if ( v11((const unsigned __int8 *)LCData, v15) )
          {
            v16 = _Dect1(&`string');
            v3(&CommandLine, v16, &v22);
            goto LABEL_40;
          }
        }
        v12 = _Dect1(&`string');
      }
      else
      {
        v12 = _Dect1(`string');
      }
    }
    else
    {
      v12 = _Dect1(`string');
    }
    v3(&CommandLine, v12, &v22);
LABEL_40:
    strcat((char *)&Data, &CommandLine);
    if ( CreateProcessA(0, (LPSTR)&Data, 0, 0, 0, 0, 0, 0, &v33, &v28) )
    {
      v18 = _Dect1(&`string');
      CLog::Write((CGameGuard *)((char *)v24 + 36), v18, &Data);
    }
    else
    {
      v21 = GetLastError();
      v17 = _Dect1(&`string');
      CLog::Write((CGameGuard *)((char *)v24 + 36), v17, v21);
    }
LABEL_43:
    RegCloseKey(phkResult);
  }
}
// 340: using guessed type int g_dwNoUseFaq;

//----- (00003F54) --------------------------------------------------------
char __thiscall CGameGuard::IsWinNT(CGameGuard *this)
{
  const CHAR *v2; // eax
  HMODULE v3; // esi
  const CHAR *v4; // eax
  FARPROC (__stdcall *v5)(HMODULE, LPCSTR); // edi
  const CHAR *v6; // eax
  DWORD v7; // eax
  struct _OSVERSIONINFOA VersionInformation; // [esp+Ch] [ebp-94h] BYREF

  VersionInformation.dwOSVersionInfoSize = 148;
  GetVersionExA(&VersionInformation);
  v2 = _Dect1(&`string');
  v3 = GetModuleHandleA(v2);
  v4 = _Dect1(&`string');
  v5 = GetProcAddress;
  if ( GetProcAddress(v3, v4) && (v6 = _Dect1(&`string'), v5(v3, v6)) )
  {
    v7 = VersionInformation.dwMajorVersion;
    if ( VersionInformation.dwMajorVersion < 5
      || VersionInformation.dwMajorVersion == 5 && !VersionInformation.dwMinorVersion )
    {
      *((_BYTE *)this + 5768) = 1;
      return 1;
    }
  }
  else
  {
    v7 = VersionInformation.dwMajorVersion;
  }
  if ( VersionInformation.dwPlatformId != 2 )
    return 0;
  bIsWin2K = 1;
  if ( v7 == 5 && !VersionInformation.dwMinorVersion )
    g_dwLoseAllowFactor *= 2;
  return 1;
}
// 366: using guessed type char bIsWin2K;
// 3A8: using guessed type int g_dwLoseAllowFactor;

//----- (00004064) --------------------------------------------------------
char __thiscall CGameGuard::GetGameGuardDirectory(CGameGuard *this, LPSTR lpFilename, unsigned int a3)
{
  CGameGuard::GetGameDirectory(this, lpFilename, a3);
  strcat(lpFilename, _Dect1(&`string'));
  return 1;
}

//----- (000040C4) --------------------------------------------------------
char __thiscall CGameGuard::GetGameDirectory(CGameGuard *this, LPSTR lpFilename, unsigned int nSize)
{
  char result; // al
  unsigned __int8 *v4; // eax
  unsigned int v5; // eax
  CHAR *v6; // edi
  unsigned __int8 *v7; // esi
  char v8; // cl

  if ( GetModuleFileNameA(0, lpFilename, nSize) )
  {
    v4 = __mbsrchr((const unsigned __int8 *)lpFilename, 0x5Cu);
    if ( v4 )
    {
      *v4 = 0;
      result = 1;
    }
    else
    {
      v5 = strlen((const char *)&`string') + 1;
      qmemcpy(lpFilename, &`string', 4 * (v5 >> 2));
      v7 = &`string' + 4 * (v5 >> 2);
      v6 = &lpFilename[4 * (v5 >> 2)];
      v8 = v5;
      result = 1;
      qmemcpy(v6, v7, v8 & 3);
    }
  }
  else
  {
    strcpy(lpFilename, (const char *)&`string');
    result = 0;
  }
  return result;
}

//----- (00004158) --------------------------------------------------------
unsigned int __thiscall CGameGuard::CheckNPGameMonI(CGameGuard *this)
{
  unsigned int result; // eax
  const char *v3; // eax
  const char *v4; // eax
  const char *v5; // eax
  const CHAR *v6; // eax
  HANDLE (__stdcall *v7)(DWORD, BOOL, LPCSTR); // esi
  HANDLE v8; // eax
  const CHAR *v9; // eax
  void (__stdcall *v10)(HANDLE); // edi
  const CHAR *v11; // eax
  HANDLE v12; // eax
  const CHAR *v13; // eax
  const char *v14; // eax
  const char *v15; // eax
  DWORD v16; // [esp-4h] [ebp-14h]
  DWORD v17; // [esp-4h] [ebp-14h]
  DWORD ExitCode; // [esp+Ch] [ebp-4h] BYREF

  ++_dwCount__1__CheckNPGameMonI_CGameGuard__QAEKXZ_4KA;
  if ( *((_BYTE *)this + 1) )
    return 1877;
  if ( *(_BYTE *)this )
  {
    if ( bCheckGameMon )
    {
      if ( hGameMonHandle && (ExitCode = 0, GetExitCodeProcess(hGameMonHandle, &ExitCode)) && ExitCode != 259 )
      {
        v5 = _Dect1(&`string');
        CLog::Write((CGameGuard *)((char *)this + 36), v5);
        result = 620;
      }
      else
      {
        v6 = _Dect1(&`string');
        v7 = OpenMutexA;
        v8 = OpenMutexA(0x100000u, 0, v6);
        if ( v8 || (v9 = _Dect1(&`string'), (v8 = v7(0x100000u, 0, v9)) != 0) )
        {
          v10 = (void (__stdcall *)(HANDLE))CloseHandle;
          CloseHandle(v8);
          v11 = _Dect1(&`string');
          v12 = v7(0x100000u, 0, v11);
          if ( v12 || (v13 = _Dect1(&`string'), (v12 = v7(0x100000u, 0, v13)) != 0) )
          {
            v10(v12);
            result = 1877;
          }
          else
          {
            v16 = GetLastError();
            v14 = _Dect1(&`string');
            CLog::Write((CGameGuard *)((char *)this + 36), v14, v16);
            result = 630;
          }
        }
        else
        {
          v17 = GetLastError();
          v15 = _Dect1(&`string');
          CLog::Write((CGameGuard *)((char *)this + 36), v15, v17);
          result = 660;
        }
      }
    }
    else
    {
      v4 = _Dect1(&`string');
      CLog::Write((CGameGuard *)((char *)this + 36), v4);
      result = 650;
    }
  }
  else if ( (unsigned int)_dwCount__1__CheckNPGameMonI_CGameGuard__QAEKXZ_4KA >= 3 )
  {
    v3 = _Dect1(&`string');
    CLog::Write((CGameGuard *)((char *)this + 36), v3);
    result = 610;
  }
  else
  {
    result = 1877;
  }
  return result;
}
// 350: using guessed type int bCheckGameMon;
// 36C: using guessed type int _dwCount__1__CheckNPGameMonI_CGameGuard__QAEKXZ_4KA;

//----- (000043F4) --------------------------------------------------------
bool __thiscall CGameGuard::SendCSAuthToGameMonI(CGameGuard *this, unsigned int a2)
{
  const char *v3; // eax

  if ( !*(_BYTE *)this )
    return 0;
  v3 = _Dect1(&`string');
  CLog::Write((CGameGuard *)((char *)this + 36), v3, a2);
  return CCommPipe::SendCommPipe((CGameGuard *)((char *)this + 5224), 0x8B1u, 0x616u, a2);
}

//----- (00004454) --------------------------------------------------------
bool __thiscall CGameGuard::SendUserIDToGameMonI(CGameGuard *this, const char *a2)
{
  if ( !*(_BYTE *)this )
    return 0;
  strcpy((char *)this + 5684, a2);
  return CCommPipe::SendCommPipe((CGameGuard *)((char *)this + 5224), 0x8B1u, 0x613u, (unsigned int)a2);
}

//----- (000044B4) --------------------------------------------------------
const char *__thiscall CGameGuard::GetInfoFromGameMonI(CGameGuard *this)
{
  const char *result; // eax

  if ( *(_BYTE *)this )
    result = CCommPipe::GetUserInfo((CGameGuard *)((char *)this + 5224));
  else
    result = 0;
  return result;
}

//----- (000044D4) --------------------------------------------------------
bool __thiscall CGameGuard::SendCSAuth2ToGameMonI(CGameGuard *this, struct _GG_AUTH_DATA *a2)
{
  bool result; // al

  if ( *(_BYTE *)this )
    result = CCommPipe::SendCommPipe((CGameGuard *)((char *)this + 5224), 0x8B1u, 0x619u, (unsigned int)a2);
  else
    result = 0;
  return result;
}

//----- (00004504) --------------------------------------------------------
int __thiscall CGameGuard::ResourceAuthI(CGameGuard *this, const char *a2, bool a3)
{
  return 0;
}

//----- (00004514) --------------------------------------------------------
bool __thiscall CGameGuard::CloseNPGameMonI(CGameGuard *this)
{
  const char *v3; // eax
  char v4; // al
  void *v5; // eax
  void (__stdcall *v6)(HANDLE); // edi
  const char *v7; // eax

  if ( *((_BYTE *)this + 1) )
    return 1;
  v3 = _Dect1(&`string');
  CLog::Write((CGameGuard *)((char *)this + 36), v3);
  v4 = *((_BYTE *)this + 32);
  *((_BYTE *)this + 1) = 1;
  if ( v4 )
  {
    CGameGuard::CloseNPSC(this);
    *((_BYTE *)this + 32) = 0;
  }
  v5 = (void *)*((_DWORD *)this + 1440);
  v6 = (void (__stdcall *)(HANDLE))CloseHandle;
  if ( v5 )
  {
    CloseHandle(v5);
    *((_DWORD *)this + 1440) = 0;
  }
  if ( *((_DWORD *)this + 6) )
  {
    v6(*((HANDLE *)this + 6));
    *((_DWORD *)this + 6) = 0;
  }
  if ( *((_DWORD *)this + 1441) )
  {
    v6(*((HANDLE *)this + 1441));
    *((_DWORD *)this + 1441) = 0;
  }
  if ( *((_BYTE *)this + 5768) )
  {
    DisableCompatibleMode(0);
    RemoveCompatibleMode();
  }
  if ( nSendErlIni )
  {
    if ( nSendErl )
      CGameGuard::FtpSendErl(this);
  }
  v7 = _Dect1(&`string');
  CLog::Write((CGameGuard *)((char *)this + 36), v7);
  *(_BYTE *)this = 0;
  return CCommPipe::CloseCommPipe((CGameGuard *)((char *)this + 5224));
}
// 32C: using guessed type int nSendErl;
// 3A4: using guessed type int nSendErlIni;

//----- (00004628) --------------------------------------------------------
char __thiscall CGameGuard::InitNPSC(CGameGuard *this)
{
  CLog *v3; // ebp
  const char *v4; // eax
  const char *v5; // eax
  DWORD (__stdcall *v6)(); // esi
  int v7; // ebx
  const char *v8; // eax
  HMODULE v9; // eax
  const char *v10; // eax
  const char *v11; // eax
  int v12; // ecx
  HANDLE v13; // eax
  HANDLE v14; // eax
  const char *v15; // eax
  int v16; // eax
  const char *v17; // eax
  DWORD v18; // [esp-4h] [ebp-118h]
  DWORD v19; // [esp-4h] [ebp-118h]
  DWORD v20; // [esp-4h] [ebp-118h]
  DWORD ThreadId; // [esp+Ch] [ebp-108h] BYREF
  CHAR LibFileName[260]; // [esp+10h] [ebp-104h] BYREF

  if ( *((_BYTE *)this + 32) )
    return 1;
  v3 = (CGameGuard *)((char *)this + 36);
  v4 = _Dect1(&`string');
  CLog::Write((CGameGuard *)((char *)this + 36), v4);
  CGameGuard::GetGameGuardDirectory(this, LibFileName, 0x104u);
  strcat(LibFileName, "\\");
  strcat(LibFileName, _Dect1(&`string'));
  v5 = _Dect1(&`string');
  CLog::Write((CGameGuard *)((char *)this + 36), v5, LibFileName);
  if ( !CFileAuthClient::Auth((CGameGuard *)((char *)this + 5568), LibFileName, 1) )
  {
    v6 = GetLastError;
    GetLastError();
    v7 = *((_DWORD *)this + 1409);
    v18 = v6();
    v8 = _Dect1(&`string');
    CLog::Write(v3, v8, v7, v18);
    return 0;
  }
  v9 = LoadLibraryA(LibFileName);
  *((_DWORD *)this + 1419) = v9;
  if ( v9 )
  {
    *((_DWORD *)this + 1443) = MyGetProcAddress((int)this, v9, 2);
    v11 = MyGetProcAddress((int)this, *((void **)this + 1419), 1);
    v12 = *((_DWORD *)this + 1443);
    *((_DWORD *)this + 1444) = v11;
    if ( v12 && v11 )
    {
      v13 = CreateEventA(0, 0, 0, 0);
      *((_DWORD *)this + 5) = v13;
      if ( v13 )
      {
        *((_BYTE *)this + 32) = 1;
        v14 = CreateThread(0, 0, (LPTHREAD_START_ROUTINE)SpeedCheckEventThread, this, 0, &ThreadId);
        *((_DWORD *)this + 1420) = v14;
        if ( v14 )
        {
          v20 = ThreadId;
          v15 = _Dect1(&`string');
          CLog::Write((CGameGuard *)((char *)this + 36), v15, v20);
          v16 = (*((int (__cdecl **)(_DWORD, _DWORD, _DWORD, _DWORD))this + 1443))(
                  *((_DWORD *)this + 1410),
                  *((_DWORD *)this + 1439),
                  *((_DWORD *)this + 1438),
                  *((_DWORD *)this + 5));
          if ( v16 == 107 )
          {
            v17 = _Dect1(&`string');
            CLog::Write((CGameGuard *)((char *)this + 36), v17);
            return 1;
          }
          v19 = v16;
          v10 = _Dect1(`string');
        }
        else
        {
          v19 = GetLastError();
          v10 = _Dect1(`string');
        }
      }
      else
      {
        v19 = GetLastError();
        v10 = _Dect1(`string');
      }
    }
    else
    {
      v19 = GetLastError();
      v10 = _Dect1(&`string');
    }
  }
  else
  {
    v19 = GetLastError();
    v10 = _Dect1(`string');
  }
  CLog::Write((CGameGuard *)((char *)this + 36), v10, v19);
  return 0;
}

//----- (000049BC) --------------------------------------------------------
char __thiscall CGameGuard::CloseNPSC(CGameGuard *this)
{
  const char *v3; // eax
  void *v4; // eax
  const char *v5; // eax
  const char *v6; // eax

  if ( !*((_BYTE *)this + 32) )
    return 1;
  v3 = _Dect1(&`string');
  CLog::Write((CGameGuard *)((char *)this + 36), v3);
  (*((void (__cdecl **)(_DWORD, char *))this + 1444))(*((_DWORD *)this + 1410), (char *)this + 5684);
  v4 = (void *)*((_DWORD *)this + 5);
  *((_BYTE *)this + 32) = 0;
  if ( v4 )
    SetEvent(v4);
  if ( WaitForSingleObject(*((HANDLE *)this + 1420), 0x7D0u) == 258 )
  {
    v5 = _Dect1(&`string');
    CLog::Write((CGameGuard *)((char *)this + 36), v5);
    TerminateThread(*((HANDLE *)this + 1420), 0);
  }
  CloseHandle(*((HANDLE *)this + 1420));
  if ( *((_DWORD *)this + 1419) )
    FreeLibrary(*((HMODULE *)this + 1419));
  *((_DWORD *)this + 1443) = 0;
  *((_DWORD *)this + 1444) = 0;
  v6 = _Dect1(&`string');
  CLog::Write((CGameGuard *)((char *)this + 36), v6);
  return 1;
}

//----- (00004ADC) --------------------------------------------------------
DWORD __userpurge SpeedCheckEventThread@<eax>(int a1@<ebx>, LPVOID lpThreadParameter)
{
  DWORD (__stdcall *v2)(HANDLE, DWORD); // edi
  const char *v3; // eax
  unsigned int v5; // [esp-8h] [ebp-10h]
  int v6; // [esp-4h] [ebp-Ch]

  v2 = WaitForSingleObject;
  while ( 1 )
  {
    while ( v2(*((HANDLE *)lpThreadParameter + 5), 0xDE3u) )
    {
      if ( CheckTimeAddr() )
      {
        if ( CheckSocketAddr() )
        {
          if ( CGameGuard::IsDebugger((CGameGuard *)lpThreadParameter) || *((_BYTE *)lpThreadParameter + 33) )
          {
            if ( gg )
            {
              v6 = *((unsigned __int8 *)lpThreadParameter + 33);
              v5 = CGameGuard::IsDebugger((CGameGuard *)lpThreadParameter);
              v3 = _Dect1(&`string');
              CLog::Write((CGameGuard *)((char *)gg + 36), v3, v5, v6);
            }
            CommPipeCallback(a1, (struct CCommPipe *)((char *)lpThreadParameter + 5224), 0x1F4u, 0);
          }
        }
        else
        {
          CCommPipe::SendCommPipe((CCommPipe *)((char *)lpThreadParameter + 5224), 0x8B1u, 0x630u, 0xCu);
        }
      }
      else
      {
        CommPipeCallback(a1, (struct CCommPipe *)((char *)lpThreadParameter + 5224), 0x62Du, 0xAu);
      }
    }
    if ( !*((_BYTE *)lpThreadParameter + 32) )
      break;
    CommPipeCallback(a1, (struct CCommPipe *)((char *)lpThreadParameter + 5224), 0x62Du, 0);
  }
  return 0;
}

//----- (00004BE0) --------------------------------------------------------
int __thiscall CGameGuard::CheckSingleInstance(CGameGuard *this, DWORD dwMilliseconds, int a3)
{
  struct _SECURITY_ATTRIBUTES *v4; // edi
  const CHAR *v5; // eax
  HANDLE (__stdcall *v6)(LPSECURITY_ATTRIBUTES, BOOL, LPCSTR); // ebx
  HANDLE v7; // esi
  const CHAR *v8; // eax
  DWORD (__stdcall *v9)(); // esi
  const char *v10; // eax
  DWORD v12; // [esp-4h] [ebp-34h]
  int v13[3]; // [esp+10h] [ebp-20h] BYREF
  char pSecurityDescriptor[20]; // [esp+1Ch] [ebp-14h] BYREF

  v13[0] = 12;
  v13[1] = (int)pSecurityDescriptor;
  v13[2] = 0;
  v4 = 0;
  if ( InitializeSecurityDescriptor(pSecurityDescriptor, 1u) && SetSecurityDescriptorDacl(pSecurityDescriptor, 1, 0, 0) )
    v4 = (struct _SECURITY_ATTRIBUTES *)v13;
  v5 = _Dect1(&`string');
  v6 = CreateMutexA;
  v7 = CreateMutexA(v4, 0, v5);
  if ( !v7 )
  {
    v8 = _Dect1(&`string');
    v7 = v6(v4, 0, v8);
    if ( !v7 )
    {
      v9 = GetLastError;
      GetLastError();
      v12 = v9();
      v10 = _Dect1(&`string');
      CLog::Write((CGameGuard *)((char *)this + 36), v10, v12);
      return 0;
    }
  }
  if ( GetLastError() == 183 )
    goto LABEL_8;
  if ( a3 )
  {
    if ( WaitForSingleObject(v7, dwMilliseconds) == 258 )
    {
LABEL_8:
      CloseHandle(v7);
      return 0;
    }
  }
  else
  {
    CloseHandle(v7);
  }
  return 1;
}

//----- (00004D44) --------------------------------------------------------
int __thiscall CGameGuard::CheckGameMonSingleInstance(CGameGuard *this, unsigned int dwMilliseconds)
{
  struct _SECURITY_ATTRIBUTES *v3; // edi
  const CHAR *v4; // eax
  HANDLE (__stdcall *v5)(LPSECURITY_ATTRIBUTES, BOOL, LPCSTR); // ebx
  HANDLE v6; // esi
  const CHAR *v7; // eax
  DWORD (__stdcall *v8)(); // esi
  const char *v9; // eax
  int result; // eax
  const char *v11; // eax
  DWORD v12; // [esp-4h] [ebp-34h]
  int v13[3]; // [esp+10h] [ebp-20h] BYREF
  char pSecurityDescriptor[20]; // [esp+1Ch] [ebp-14h] BYREF

  v13[0] = 12;
  v13[1] = (int)pSecurityDescriptor;
  v13[2] = 0;
  v3 = 0;
  if ( InitializeSecurityDescriptor(pSecurityDescriptor, 1u) && SetSecurityDescriptorDacl(pSecurityDescriptor, 1, 0, 0) )
    v3 = (struct _SECURITY_ATTRIBUTES *)v13;
  v4 = _Dect1(&`string');
  v5 = CreateMutexA;
  v6 = CreateMutexA(v3, 0, v4);
  if ( v6 || (v7 = _Dect1(&`string'), (v6 = v5(v3, 0, v7)) != 0) )
  {
    if ( GetLastError() == 183 && WaitForSingleObject(v6, dwMilliseconds) == 258 )
    {
      v11 = _Dect1(&`string');
      CLog::Write((CGameGuard *)((char *)this + 36), v11);
      CloseHandle(v6);
      result = 0;
    }
    else
    {
      ReleaseMutex(v6);
      CloseHandle(v6);
      result = 1;
    }
  }
  else
  {
    v8 = GetLastError;
    GetLastError();
    v12 = v8();
    v9 = _Dect1(&`string');
    CLog::Write((CGameGuard *)((char *)this + 36), v9, v12);
    result = 0;
  }
  return result;
}

//----- (00004EA4) --------------------------------------------------------
unsigned int __thiscall CGameGuard::IsDebugger(CGameGuard *this)
{
  if ( bEncryptedClientArm )
    return 0;
  if ( *((_BYTE *)this + 5749) )
    return NtCurrentTeb()->ProcessEnvironmentBlock->BeingDebugged;
  return LOBYTE(NtCurrentTeb()->ClientId.UniqueProcess);
}
// 365: using guessed type char bEncryptedClientArm;

//----- (00004EF4) --------------------------------------------------------
bool __userpurge CommPipeCallback@<al>(int a1@<ebx>, struct CCommPipe *a2, unsigned int a3, unsigned int a4)
{
  CGameGuard *v4; // eax
  unsigned int *v5; // edi
  const char *v6; // eax
  unsigned int v7; // esi
  bool v8; // zf
  bool result; // al
  bool v10; // zf
  const char *v11; // eax
  const char *v12; // eax
  const char *v13; // eax
  const char *v14; // eax
  const char *v15; // eax
  unsigned int v16; // [esp-4h] [ebp-Ch]

  v4 = gg;
  v5 = (unsigned int *)a4;
  if ( gg )
  {
    v6 = _Dect1(&`string');
    CLog::Write((CGameGuard *)((char *)gg + 36), v6, a3, a4);
    v4 = gg;
  }
  switch ( a3 )
  {
    case 0x60Fu:
      v7 = 1001;
      v8 = *(_BYTE *)v4 == 0;
      goto LABEL_5;
    case 0x610u:
      v7 = 1002;
      v10 = *(_BYTE *)v4 == 0;
      goto LABEL_8;
    case 0x615u:
      dwWorkingPID = a4;
      if ( dwGameMonPID )
      {
        if ( a4 != dwGameMonPID )
        {
          if ( v4 )
          {
            v16 = dwGameMonPID;
            v15 = _Dect1(&`string');
            CLog::Write((CGameGuard *)((char *)gg + 36), v15, a4, v16);
            v4 = gg;
          }
          nSendErl = 2;
          v7 = 1014;
          v5 = (_DWORD *)&unk_E6;
          v10 = *((_DWORD *)v4 + 1) == 0;
LABEL_8:
          if ( v10 )
          {
            *((_DWORD *)v4 + 2) = v7;
            result = 1;
            *((_DWORD *)gg + 3) = v5;
            return result;
          }
          goto LABEL_14;
        }
      }
      else
      {
        dwGameMonPID = a4;
      }
      if ( CheckVersion((int)szGameMon, 0x7D6u, 0xAu, 5u, 1u) )
        return 1;
      v4 = gg;
      if ( gg )
      {
        v14 = _Dect1(&`string');
        CLog::Write((CGameGuard *)((char *)gg + 36), v14);
        v4 = gg;
      }
      v7 = 1014;
      v5 = (_DWORD *)&unk_E6;
      v8 = *((_DWORD *)v4 + 1) == 0;
LABEL_5:
      if ( v8 )
      {
        *((_DWORD *)v4 + 2) = v7;
        *((_DWORD *)gg + 3) = v5;
        return 1;
      }
LABEL_14:
      if ( NPGameMonCallback(v7, (unsigned int)v5) )
        return 1;
      if ( gg )
      {
        v12 = _Dect1(&`string');
        CLog::Write((CGameGuard *)((char *)gg + 36), v12, v7, v5);
      }
      *((_BYTE *)gg + 35) = 1;
      return 0;
    case 0x618u:
      if ( a4 < 800 * g_dwLoseAllowFactor )
        return 1;
      GetProcessList(a1);
      GetModuleList(a1);
      if ( gg )
      {
        v11 = _Dect1(&`string');
        CLog::Write((CGameGuard *)((char *)gg + 36), v11, a4);
      }
      v7 = 1001;
      goto LABEL_14;
    case 0x619u:
      v5 = CCommPipe::GetCSAuth2(a2);
      v7 = 1017;
      goto LABEL_14;
    case 0x62Du:
      v7 = 1011;
      goto LABEL_22;
    case 0x62Eu:
      v7 = 1012;
      v8 = *((_DWORD *)v4 + 1) == 0;
      goto LABEL_5;
    case 0x62Fu:
      v7 = 1013;
      v10 = *((_DWORD *)v4 + 1) == 0;
      goto LABEL_8;
    case 0x630u:
      v7 = 1015;
LABEL_22:
      if ( *((_DWORD *)v4 + 1) )
        goto LABEL_14;
      *((_DWORD *)v4 + 2) = v7;
      *((_DWORD *)gg + 3) = a4;
      return 1;
    case 0x637u:
      v7 = 1014;
      v5 = (_DWORD *)&unk_D2;
      v8 = *((_DWORD *)v4 + 1) == 0;
      goto LABEL_5;
    case 0x638u:
      v7 = 1014;
      v5 = (_DWORD *)&unk_DC;
      v10 = *((_DWORD *)v4 + 1) == 0;
      goto LABEL_8;
    case 0x639u:
      v7 = 1014;
      v5 = (_DWORD *)&unk_E6;
      if ( *((_DWORD *)v4 + 1) )
        goto LABEL_14;
      *((_DWORD *)v4 + 2) = 1014;
      result = 1;
      *((_DWORD *)gg + 3) = 230;
      return result;
    case 0x63Au:
      if ( v4 )
      {
        v13 = _Dect1(&`string');
        CLog::Write((CGameGuard *)((char *)gg + 36), v13, a4);
      }
      v7 = 1016;
      goto LABEL_14;
    default:
      if ( a3 == 500 )
      {
        v7 = 1014;
        v5 = (_DWORD *)&unk_1F4;
      }
      else
      {
        v7 = 1000;
      }
      v10 = *((_DWORD *)v4 + 1) == 0;
      goto LABEL_8;
  }
}
// 32C: using guessed type int nSendErl;
// 34C: using guessed type int dwWorkingPID;
// 35C: using guessed type unsigned int dwGameMonPID;
// 3A8: using guessed type int g_dwLoseAllowFactor;

//----- (000052EC) --------------------------------------------------------
void __thiscall CGameGuard::FtpSendErl(CGameGuard *this)
{
  char *v1; // esi
  const char *v2; // eax
  char v3; // bl
  const CHAR *v4; // eax
  void (*v5)(LPSTR, LPCSTR, ...); // edi
  const CHAR *v6; // eax
  void (__stdcall *v7)(HKEY, LPCSTR, LPDWORD, LPDWORD, LPBYTE, LPDWORD); // ebp
  const CHAR *v8; // eax
  const CHAR *v9; // eax
  void (__stdcall *v10)(HKEY, LPCSTR, DWORD, DWORD, const BYTE *, DWORD); // edi
  const CHAR *v11; // eax
  const char *v12; // eax
  unsigned int v13; // eax
  bool v14; // cc
  void *v15; // eax
  const char *v16; // eax
  signed int v17; // ecx
  DWORD v18; // edi
  char *v19; // eax
  int v20; // edx
  const char *v21; // eax
  HINSTANCE v22; // eax
  const char *v23; // esi
  HINSTANCE v24; // eax
  const char *v25; // edi
  HINSTANCE v26; // eax
  const char *v27; // ebp
  HINSTANCE v28; // eax
  const char *v29; // eax
  char *v30; // eax
  int v31; // ebx
  char *v32; // eax
  int v33; // esi
  char *v34; // eax
  const char *v35; // eax
  char *v36; // [esp-1Ch] [ebp-2FCh]
  char *v37; // [esp-14h] [ebp-2F4h]
  int v38; // [esp-10h] [ebp-2F0h]
  int v39; // [esp-4h] [ebp-2E4h]
  char *v40; // [esp-4h] [ebp-2E4h]
  int v41; // [esp+0h] [ebp-2E0h]
  int v42; // [esp+0h] [ebp-2E0h]
  int v43; // [esp+4h] [ebp-2DCh]
  int v44; // [esp+4h] [ebp-2DCh]
  int v45; // [esp+8h] [ebp-2D8h]
  char *v46; // [esp+8h] [ebp-2D8h]
  int v47; // [esp+8h] [ebp-2D8h]
  int v48; // [esp+Ch] [ebp-2D4h]
  char *v49; // [esp+Ch] [ebp-2D4h]
  int v50; // [esp+Ch] [ebp-2D4h]
  int v51; // [esp+10h] [ebp-2D0h]
  int v52; // [esp+10h] [ebp-2D0h]
  int v53; // [esp+14h] [ebp-2CCh]
  int v54; // [esp+14h] [ebp-2CCh]
  DWORD v55; // [esp+18h] [ebp-2C8h]
  void *v56; // [esp+18h] [ebp-2C8h]
  char *v57; // [esp+18h] [ebp-2C8h]
  char *v58; // [esp+18h] [ebp-2C8h]
  char *v59; // [esp+18h] [ebp-2C8h]
  char *v60; // [esp+18h] [ebp-2C8h]
  int v61; // [esp+18h] [ebp-2C8h]
  BYTE v62[4]; // [esp+2Ch] [ebp-2B4h] BYREF
  DWORD cbData; // [esp+30h] [ebp-2B0h] BYREF
  HKEY phkResult; // [esp+34h] [ebp-2ACh] BYREF
  DWORD nSize; // [esp+38h] [ebp-2A8h] BYREF
  DWORD NumberOfBytesWritten; // [esp+3Ch] [ebp-2A4h] BYREF
  DWORD dwDisposition; // [esp+40h] [ebp-2A0h] BYREF
  CGameGuard *v68; // [esp+44h] [ebp-29Ch]
  struct _SYSTEMTIME SystemTime; // [esp+48h] [ebp-298h] BYREF
  BYTE Data[64]; // [esp+5Ch] [ebp-284h] BYREF
  CHAR String2[64]; // [esp+9Ch] [ebp-244h] BYREF
  CHAR v72[128]; // [esp+DCh] [ebp-204h] BYREF
  CHAR Buffer[128]; // [esp+15Ch] [ebp-184h] BYREF
  char v74[260]; // [esp+1DCh] [ebp-104h] BYREF

  v68 = this;
  v1 = (char *)this + 36;
  v2 = _Dect1(&`string');
  CLog::Write((CLog *)v1, v2);
  *(_DWORD *)v62 = 0;
  v3 = 0;
  v4 = _Dect1(&`string');
  if ( !RegCreateKeyExA(HKEY_CURRENT_USER, v4, 0, 0, 0, 0xF003Fu, 0, &phkResult, &dwDisposition) )
  {
    v5 = (void (*)(LPSTR, LPCSTR, ...))_wsprintfA;
    if ( dwDisposition == 2 )
    {
      cbData = 64;
      v6 = _Dect1(&`string');
      v7 = (void (__stdcall *)(HKEY, LPCSTR, LPDWORD, LPDWORD, LPBYTE, LPDWORD))RegQueryValueExA;
      RegQueryValueExA(phkResult, v6, 0, 0, Data, &cbData);
      v5(String2, "%hs", "Thu Aug 30 10:21:54 2007");
      if ( cbData && !lstrcmpA((LPCSTR)Data, String2) )
        v3 = 1;
      cbData = 4;
      v8 = _Dect1(&`string');
      v7(phkResult, v8, 0, 0, v62, &cbData);
    }
    v5((LPSTR)Data, "%hs", "Thu Aug 30 10:21:54 2007");
    v55 = lstrlenA((LPCSTR)Data) + 1;
    cbData = v55;
    v9 = _Dect1(&`string');
    v10 = (void (__stdcall *)(HKEY, LPCSTR, DWORD, DWORD, const BYTE *, DWORD))RegSetValueExA;
    RegSetValueExA(phkResult, v9, 0, 1u, Data, v55);
    cbData = 4;
    if ( v3 )
      ++*(_DWORD *)v62;
    else
      *(_DWORD *)v62 = 0;
    v11 = _Dect1(&`string');
    v10(phkResult, v11, 0, 4u, v62, 4u);
    RegCloseKey(phkResult);
  }
  if ( *(_DWORD *)v62 != 1 && *(_DWORD *)v62 <= 5u && (!v3 || nSendErl < 9) )
  {
    v12 = _Dect1(&`string');
    CLog::Write((CLog *)v1, v12);
    if ( *(_DWORD *)v1 != -1 )
    {
      GetLocalTime((LPSYSTEMTIME)(v1 + 4124));
      v13 = *((_DWORD *)v1 + 1295);
      if ( !v13 || (v14 = *((_DWORD *)v1 + 1296) <= v13, v15 = &`string', v14) )
        v15 = &`string';
      v56 = v15;
      v53 = *((unsigned __int16 *)v1 + 2069);
      v51 = *((unsigned __int16 *)v1 + 2068);
      v48 = *((unsigned __int16 *)v1 + 2067);
      v45 = *((unsigned __int16 *)v1 + 2066);
      v43 = *((unsigned __int16 *)v1 + 2065);
      v41 = *((unsigned __int16 *)v1 + 2063);
      v39 = *((unsigned __int16 *)v1 + 2062);
      v16 = _Dect(&`string');
      _sprintf(v1 + 28, v16, v39, v41, v43, v45, v48, v51, v53, v56);
      v17 = strlen(v1 + 28);
      v18 = v17;
      if ( *((_DWORD *)v1 + 1294) )
      {
        if ( v17 > 0 )
        {
          v19 = v1 + 28;
          do
          {
            v20 = *((_DWORD *)v1 + 1294) + 2;
            *((_DWORD *)v1 + 1294) = v20;
            v3 = (v20 + 67) ^ *v19;
            *v19++ = v3;
          }
          while ( (int)&v19[-28 - (_DWORD)v1] < v17 );
        }
      }
      else
      {
        RC4((struct rc4_key_st *)(v1 + 4144), v17, (unsigned __int8 *)v1 + 28, (unsigned __int8 *)v1 + 28);
      }
      if ( *((_DWORD *)v1 + 1295) != 999 )
        WriteFile(*(HANDLE *)v1, v1 + 28, v18, &NumberOfBytesWritten, 0);
      SetEndOfFile(*(HANDLE *)v1);
      CloseHandle(*(HANDLE *)v1);
      *(_DWORD *)v1 = -1;
    }
    if ( CSafeAPI::GetModule((CSafeAPI *)&safeWinInet)
      || (v21 = _Dect1(&`string'), CSafeAPI::Init((CSafeAPI *)&safeWinInet, v21)) )
    {
      v57 = _Dect1(&`string');
      v22 = CSafeAPI::GetModule((CSafeAPI *)&safeWinInet);
      v23 = MyGetProcAddress(v3, v22, (int)v57);
      v58 = _Dect1(&`string');
      v24 = CSafeAPI::GetModule((CSafeAPI *)&safeWinInet);
      v25 = MyGetProcAddress(v3, v24, (int)v58);
      v59 = _Dect1(&`string');
      v26 = CSafeAPI::GetModule((CSafeAPI *)&safeWinInet);
      v27 = MyGetProcAddress(v3, v26, (int)v59);
      v60 = _Dect1(&`string');
      v28 = CSafeAPI::GetModule((CSafeAPI *)&safeWinInet);
      v29 = MyGetProcAddress(v3, v28, (int)v60);
      NumberOfBytesWritten = (DWORD)v29;
      if ( v23 )
      {
        if ( v25 )
        {
          if ( v27 )
          {
            if ( v29 )
            {
              v30 = _Dect(&`string');
              v31 = ((int (__stdcall *)(char *, _DWORD, _DWORD, _DWORD, _DWORD))v23)(v30, 0, 0, 0, 0);
              if ( v31 )
              {
                v49 = _Dect1(&`string');
                v46 = _Dect(&`string');
                v32 = _Dect(&`string');
                v33 = ((int (__stdcall *)(int, char *, int, char *, char *, int, int, _DWORD))v25)(
                        v31,
                        v32,
                        6060,
                        v46,
                        v49,
                        1,
                        0x8000000,
                        0);
                if ( v33 )
                {
                  Buffer[0] = 0;
                  nSize = 128;
                  GetComputerNameA(Buffer, &nSize);
                  v72[0] = 0;
                  nSize = 128;
                  GetUserNameA(v72, &nSize);
                  GetLocalTime(&SystemTime);
                  switch ( nSendErl )
                  {
                    case 1:
                      v34 = _Dect(`string');
                      break;
                    case 2:
                      v34 = _Dect(`string');
                      break;
                    case 3:
                      v34 = _Dect(`string');
                      break;
                    case 4:
                      v34 = _Dect(`string');
                      break;
                    case 5:
                      v34 = _Dect(`string');
                      break;
                    case 6:
                      v34 = _Dect(`string');
                      break;
                    case 7:
                      v34 = _Dect(`string');
                      break;
                    case 8:
                      v34 = _Dect(`string');
                      break;
                    case 9:
                      v34 = _Dect(`string');
                      break;
                    default:
                      v34 = _Dect(&`string');
                      break;
                  }
                  v61 = SystemTime.wMilliseconds;
                  v54 = SystemTime.wSecond;
                  v52 = SystemTime.wMinute;
                  v50 = SystemTime.wHour;
                  v47 = SystemTime.wDay;
                  v44 = SystemTime.wMonth;
                  v42 = SystemTime.wYear;
                  v40 = (char *)v68 + 5684;
                  v38 = *((_DWORD *)gg + 4);
                  v37 = v34;
                  v36 = (char *)v68 + 5644;
                  v35 = _Dect1(&`string');
                  __snprintf(v74, 0x104u, v35, v36, 47, v37, v38, Buffer, v72, v40, v42, v44, v47, v50, v52, v54, v61);
                  ((void (__stdcall *)(int, CHAR *, char *, int, _DWORD))NumberOfBytesWritten)(
                    v33,
                    &szLogFile,
                    v74,
                    67108866,
                    0);
                  GetLastError();
                  ((void (__stdcall *)(int))v27)(v31);
                  ((void (__stdcall *)(int))v27)(v33);
                }
                else
                {
                  ((void (__stdcall *)(int))v27)(v31);
                }
              }
            }
          }
        }
      }
    }
  }
}
// 32C: using guessed type int nSendErl;

//----- (00005AF0) --------------------------------------------------------
bool __usercall InitToolhelp32@<al>(int a1@<ebx>)
{
  bool result; // al
  const CHAR *v2; // eax
  HMODULE v3; // esi
  char *v4; // eax
  char *v5; // eax
  char *v6; // eax
  char *v7; // eax
  char *v8; // eax

  if ( _bInit__1__InitToolhelp32__YA_NXZ_4_NA )
    return 1;
  v2 = _Dect1(&`string');
  v3 = GetModuleHandleA(v2);
  if ( !v3 )
    return 0;
  v4 = _Dect1(&`string');
  pCreateToolhelp32Snapshot = (void *(__stdcall *)(unsigned int, unsigned int))MyGetProcAddress(a1, v3, (int)v4);
  if ( !pCreateToolhelp32Snapshot )
    return 0;
  v5 = _Dect1(&`string');
  pProcess32First = (int (__stdcall *)(void *, struct tagPROCESSENTRY32 *))MyGetProcAddress(a1, v3, (int)v5);
  if ( !pProcess32First )
    return 0;
  v6 = _Dect1(&`string');
  pProcess32Next = (int (__stdcall *)(void *, struct tagPROCESSENTRY32 *))MyGetProcAddress(a1, v3, (int)v6);
  if ( !pProcess32Next )
    return 0;
  v7 = _Dect1(&`string');
  pModule32First = (int (__stdcall *)(void *, struct tagMODULEENTRY32 *))MyGetProcAddress(a1, v3, (int)v7);
  if ( !pModule32First )
    return 0;
  v8 = _Dect1(&`string');
  pModule32Next = (int (__stdcall *)(void *, struct tagMODULEENTRY32 *))MyGetProcAddress(a1, v3, (int)v8);
  if ( !pModule32Next )
    return 0;
  result = 1;
  _bInit__1__InitToolhelp32__YA_NXZ_4_NA = 1;
  return result;
}
// 0: using guessed type int (__stdcall *pProcess32First)(void *, struct tagPROCESSENTRY32 *);
// 4: using guessed type int (__stdcall *pModule32Next)(void *, struct tagMODULEENTRY32 *);
// 110: using guessed type void *(__stdcall *pCreateToolhelp32Snapshot)(unsigned int, unsigned int);
// 324: using guessed type int (__stdcall *pModule32First)(void *, struct tagMODULEENTRY32 *);
// 328: using guessed type int (__stdcall *pProcess32Next)(void *, struct tagPROCESSENTRY32 *);
// 370: using guessed type char _bInit__1__InitToolhelp32__YA_NXZ_4_NA;

//----- (00005C54) --------------------------------------------------------
char __usercall GetProcessList@<al>(int a1@<ebx>)
{
  void *v1; // eax
  void *v2; // esi
  const char *v3; // eax
  const char *v4; // eax
  DWORD v6; // [esp+0h] [ebp-138h]
  DWORD v7; // [esp+4h] [ebp-134h]
  LONG v8; // [esp+8h] [ebp-130h]
  struct tagPROCESSENTRY32 v9; // [esp+10h] [ebp-128h] BYREF

  LOBYTE(v1) = InitToolhelp32(a1);
  if ( (_BYTE)v1 )
  {
    v9.dwSize = 0;
    memset(&v9.cntUsage, 0, 0x124u);
    v1 = pCreateToolhelp32Snapshot(2u, 0);
    v2 = v1;
    if ( v1 != (void *)-1 )
    {
      v9.dwSize = 296;
      if ( pProcess32First(v1, &v9) )
      {
        if ( !gg )
          goto LABEL_8;
        v3 = _Dect1(&`string');
        CLog::Write((CGameGuard *)((char *)gg + 36), v3);
        do
        {
          if ( gg )
          {
            v8 = v9.pcPriClassBase;
            v7 = v9.cntThreads;
            v6 = v9.th32ProcessID;
            v4 = _Dect1(&`string');
            CLog::Write((CGameGuard *)((char *)gg + 36), v4, v9.szExeFile, v6, v7, v8);
          }
LABEL_8:
          ;
        }
        while ( pProcess32Next(v2, &v9) );
      }
      LOBYTE(v1) = CloseHandle(v2);
    }
  }
  return (char)v1;
}
// 0: using guessed type int (__stdcall *pProcess32First)(void *, struct tagPROCESSENTRY32 *);
// 110: using guessed type void *(__stdcall *pCreateToolhelp32Snapshot)(unsigned int, unsigned int);
// 328: using guessed type int (__stdcall *pProcess32Next)(void *, struct tagPROCESSENTRY32 *);

//----- (00005D8C) --------------------------------------------------------
char __usercall GetModuleList@<al>(int a1@<ebx>)
{
  void *v1; // eax
  unsigned int v2; // eax
  void *v3; // esi
  const char *v4; // eax
  const char *v5; // eax
  BYTE *v7; // [esp+0h] [ebp-234h]
  DWORD v8; // [esp+4h] [ebp-230h]
  struct tagMODULEENTRY32 v9; // [esp+10h] [ebp-224h] BYREF

  LOBYTE(v1) = InitToolhelp32(a1);
  if ( (_BYTE)v1 )
  {
    v9.dwSize = 0;
    memset(&v9.th32ModuleID, 0, 0x220u);
    v2 = GetCurrentProcessId();
    v1 = pCreateToolhelp32Snapshot(8u, v2);
    v3 = v1;
    if ( v1 != (void *)-1 )
    {
      v9.dwSize = 548;
      if ( pModule32First(v1, &v9) )
      {
        if ( !gg )
          goto LABEL_8;
        v4 = _Dect1(&`string');
        CLog::Write((CGameGuard *)((char *)gg + 36), v4);
        do
        {
          if ( gg )
          {
            v8 = v9.modBaseSize;
            v7 = v9.modBaseAddr;
            v5 = _Dect1(&`string');
            CLog::Write((CGameGuard *)((char *)gg + 36), v5, v9.szModule, v7, v8, v9.szExePath);
          }
LABEL_8:
          ;
        }
        while ( pModule32Next(v3, &v9) );
      }
      LOBYTE(v1) = CloseHandle(v3);
    }
  }
  return (char)v1;
}
// 4: using guessed type int (__stdcall *pModule32Next)(void *, struct tagMODULEENTRY32 *);
// 110: using guessed type void *(__stdcall *pCreateToolhelp32Snapshot)(unsigned int, unsigned int);
// 324: using guessed type int (__stdcall *pModule32First)(void *, struct tagMODULEENTRY32 *);

//----- (00005ED4) --------------------------------------------------------
LONG __userpurge FvUnhandledExceptionFilter@<eax>(int a1@<ebx>, struct _EXCEPTION_POINTERS *ExceptionInfo)
{
  PEXCEPTION_RECORD v3; // esi
  const char *v4; // eax
  unsigned __int8 *v5; // ebx
  int (*v6)(char *const, const char *const, ...); // ebp
  int v7; // edi
  int i; // esi
  const char *v9; // eax
  CGameGuard *v10; // eax
  int v11; // ebx
  const char *v12; // eax
  DWORD v13; // [esp-20h] [ebp-A0h]
  PVOID v14; // [esp-1Ch] [ebp-9Ch]
  DWORD v15; // [esp-18h] [ebp-98h]
  int v16; // [esp-14h] [ebp-94h]
  int v17; // [esp-14h] [ebp-94h]
  char Buffer[128]; // [esp+0h] [ebp-80h] BYREF

  if ( _bInException__1__FvUnhandledExceptionFilter__YGJPAU_EXCEPTION_POINTERS___Z_4_NA )
    return 1;
  _bInException__1__FvUnhandledExceptionFilter__YGJPAU_EXCEPTION_POINTERS___Z_4_NA = 1;
  v3 = ExceptionInfo->ExceptionRecord;
  if ( gg )
  {
    v16 = g_dwThreadId;
    v15 = GetCurrentThreadId();
    v14 = v3->ExceptionAddress;
    v13 = v3->ExceptionCode;
    v4 = _Dect1(&`string');
    CLog::Write((CGameGuard *)((char *)gg + 36), v4, v13, v14, v15, v16);
  }
  v5 = (unsigned __int8 *)v3->ExceptionAddress;
  v6 = _sprintf;
  v7 = 0;
  for ( i = 0; i < 32; ++i )
  {
    v17 = v5[i];
    v9 = _Dect(&`string');
    v7 += v6(&Buffer[v7], v9, v17);
  }
  v10 = gg;
  Buffer[v7] = 0;
  v11 = a1;
  if ( v10 )
  {
    v12 = _Dect1(&`string');
    CLog::Write((CGameGuard *)((char *)gg + 36), v12, Buffer);
  }
  GetProcessList(v11);
  GetModuleList(v11);
  if ( gg )
  {
    if ( !*(_BYTE *)gg )
    {
      *((_DWORD *)gg + 4) += 10000;
      ExitProcess(0x64u);
    }
  }
  return 0;
}
// 5ED4: could not find valid save-restore pair for ebx
// 334: using guessed type int g_dwThreadId;
// 371: using guessed type char _bInException__1__FvUnhandledExceptionFilter__YGJPAU_EXCEPTION_POINTERS___Z_4_NA;

//----- (0000603C) --------------------------------------------------------
int __cdecl NPDect(int a1)
{
  return a1;
}

//----- (0000604C) --------------------------------------------------------
int InitTimeAddr()
{
  const CHAR *v0; // eax
  HMODULE (__stdcall *v1)(LPCSTR); // edi
  HMODULE v2; // ebx
  const CHAR *v3; // eax
  HMODULE v4; // ebp
  const CHAR *v5; // eax
  HMODULE v6; // esi
  char *v8; // eax
  const char *v9; // eax
  const char *v10; // eax
  const char *v11; // eax
  char *v12; // eax
  const char *v13; // eax
  const char *v14; // eax
  const char *v15; // eax
  DWORD (__stdcall *v16)(); // esi
  const CHAR *v17; // eax
  HMODULE v18; // edi
  char *v19; // eax
  const char *v20; // eax
  const char *v21; // eax
  const char *v22; // eax
  const char *v23; // [esp-8h] [ebp-1Ch]
  const char *v24; // [esp-8h] [ebp-1Ch]
  const char *v25; // [esp-8h] [ebp-1Ch]
  BOOL (__stdcall *v26)(LARGE_INTEGER *); // [esp-4h] [ebp-18h]
  DWORD (__stdcall *v27)(); // [esp-4h] [ebp-18h]
  int v28; // [esp+10h] [ebp-4h]

  v28 = 0;
  v0 = _Dect1(&`string');
  v1 = GetModuleHandleA;
  v2 = GetModuleHandleA(v0);
  v3 = _Dect1(&`string');
  v4 = v1(v3);
  v5 = _Dect1(&`string');
  v6 = v1(v5);
  if ( !v6 )
    return 2;
  v8 = _Dect1(&`string');
  v9 = MyGetProcAddress((int)v2, v6, (int)v8);
  lpQPC = (int)v9;
  if ( v9 )
  {
    lpQPC2 = (int)QueryPerformanceCounter;
    if ( gg )
    {
      v26 = QueryPerformanceCounter;
      v23 = v9;
      v10 = _Dect1(&`string');
      CLog::Write((CGameGuard *)((char *)gg + 36), v10, v23, v26);
      v9 = (const char *)lpQPC;
    }
    if ( v9 < (const char *)v6 && !v4 && (!v2 || v9 < (const char *)v2) )
    {
      if ( gg )
      {
        v11 = _Dect1(&`string');
        CLog::Write((CGameGuard *)((char *)gg + 36), v11, v6);
      }
      v28 = 1;
    }
  }
  v12 = _Dect1(&`string');
  v13 = MyGetProcAddress((int)v2, v6, (int)v12);
  lpGTC = (int)v13;
  if ( v13 )
  {
    lpGTC2 = (int)GetTickCount;
    if ( gg )
    {
      v27 = GetTickCount;
      v24 = v13;
      v14 = _Dect1(&`string');
      CLog::Write((CGameGuard *)((char *)gg + 36), v14, v24, v27);
      v13 = (const char *)lpGTC;
    }
    if ( v13 < (const char *)v6 && !v4 && (!v2 || lpQPC < (unsigned int)v2) )
    {
      if ( gg )
      {
        v15 = _Dect1(&`string');
        CLog::Write((CGameGuard *)((char *)gg + 36), v15, v6);
      }
      ++v28;
    }
  }
  v16 = timeGetTime;
  timeGetTime();
  v17 = _Dect1(&`string');
  v18 = v1(v17);
  if ( v18 )
  {
    v19 = _Dect1(&`string');
    v20 = MyGetProcAddress((int)v2, v18, (int)v19);
    lpTGT = (int)v20;
    if ( v20 )
    {
      lpTGT2 = (int)v16;
      if ( gg )
      {
        v25 = v20;
        v21 = _Dect1(&`string');
        CLog::Write((CGameGuard *)((char *)gg + 36), v21, v25, v16);
        v20 = (const char *)lpTGT;
      }
      if ( v20 < (const char *)v18 && !v4 && (!v2 || lpQPC < (unsigned int)v2) )
      {
        if ( gg )
        {
          v22 = _Dect1(&`string');
          CLog::Write((CGameGuard *)((char *)gg + 36), v22, v18);
        }
        ++v28;
      }
    }
  }
  bInitTA = 1;
  return v28 == 0;
}
// 374: using guessed type int lpGTC;
// 378: using guessed type int lpQPC;
// 37C: using guessed type int lpTGT;
// 388: using guessed type int lpGTC2;
// 38C: using guessed type int lpQPC2;
// 390: using guessed type int lpTGT2;
// 39C: using guessed type char bInitTA;

//----- (000063B8) --------------------------------------------------------
int CheckTimeAddr()
{
  int v1; // esi
  const char *v2; // eax
  const char *v3; // eax
  const char *v4; // eax
  BOOL (__stdcall *v5)(LARGE_INTEGER *); // [esp-8h] [ebp-8h]
  DWORD (__stdcall *v6)(); // [esp-8h] [ebp-8h]
  DWORD (__stdcall *v7)(); // [esp-8h] [ebp-8h]

  if ( bEncryptedClient )
    return 1;
  if ( !bInitTA )
    return 2;
  v1 = 0;
  if ( (BOOL (__stdcall *)(LARGE_INTEGER *))lpQPC2 != QueryPerformanceCounter )
  {
    if ( gg )
    {
      v5 = QueryPerformanceCounter;
      v2 = _Dect1(&`string');
      CLog::Write((CGameGuard *)((char *)gg + 36), v2, v5);
    }
    v1 = 1;
  }
  if ( (DWORD (__stdcall *)())lpGTC2 != GetTickCount )
  {
    if ( gg )
    {
      v6 = GetTickCount;
      v3 = _Dect1(&`string');
      CLog::Write((CGameGuard *)((char *)gg + 36), v3, v6);
    }
    ++v1;
  }
  if ( (DWORD (__stdcall *)())lpTGT2 != timeGetTime )
  {
    if ( gg )
    {
      v7 = timeGetTime;
      v4 = _Dect1(&`string');
      CLog::Write((CGameGuard *)((char *)gg + 36), v4, v7);
    }
    ++v1;
  }
  return v1 == 0;
}
// 364: using guessed type char bEncryptedClient;
// 388: using guessed type int lpGTC2;
// 38C: using guessed type int lpQPC2;
// 390: using guessed type int lpTGT2;
// 39C: using guessed type char bInitTA;

//----- (000064D4) --------------------------------------------------------
int __usercall InitSocketAddr@<eax>(int a1@<ebx>)
{
  int v1; // edi
  const CHAR *v2; // eax
  HMODULE v3; // esi
  char *v5; // eax
  const char *v6; // eax
  const char *v7; // eax
  const char *v8; // eax
  char *v9; // eax
  const char *v10; // eax
  const char *v11; // eax
  const char *v12; // eax
  const char *v13; // [esp-8h] [ebp-10h]
  const char *v14; // [esp-8h] [ebp-10h]
  int (__stdcall *v15)(SOCKET, LPWSABUF, DWORD, LPDWORD, DWORD, LPWSAOVERLAPPED, LPWSAOVERLAPPED_COMPLETION_ROUTINE); // [esp-4h] [ebp-Ch]
  int (__stdcall *v16)(SOCKET, const char *, int, int); // [esp-4h] [ebp-Ch]

  v1 = 0;
  v2 = _Dect1(&`string');
  v3 = GetModuleHandleA(v2);
  if ( !v3 )
    return 2;
  v5 = _Dect1(&`string');
  v6 = MyGetProcAddress(a1, v3, (int)v5);
  lpWSASend = (int)v6;
  if ( v6 )
  {
    lpWSASend2 = (int)WSASend;
    if ( gg )
    {
      v15 = WSASend;
      v13 = v6;
      v7 = _Dect1(&`string');
      CLog::Write((CGameGuard *)((char *)gg + 36), v7, v13, v15);
      v6 = (const char *)lpWSASend;
    }
    if ( v6 < (const char *)v3 )
    {
      if ( gg )
      {
        v8 = _Dect1(&`string');
        CLog::Write((CGameGuard *)((char *)gg + 36), v8, v3);
      }
      v1 = 1;
    }
  }
  v9 = _Dect1(&`string');
  v10 = MyGetProcAddress(a1, v3, (int)v9);
  lpsend = (int)v10;
  if ( v10 )
  {
    lpsend2 = (int)send;
    if ( gg )
    {
      v16 = send;
      v14 = v10;
      v11 = _Dect1(&`string');
      CLog::Write((CGameGuard *)((char *)gg + 36), v11, v14, v16);
      v10 = (const char *)lpsend;
    }
    if ( v10 < (const char *)v3 )
    {
      if ( gg )
      {
        v12 = _Dect1(&`string');
        CLog::Write((CGameGuard *)((char *)gg + 36), v12, v3);
      }
      ++v1;
    }
  }
  bInitSA = 1;
  return v1 == 0;
}
// 380: using guessed type int lpWSASend;
// 384: using guessed type int lpsend;
// 394: using guessed type int lpWSASend2;
// 398: using guessed type int lpsend2;
// 39D: using guessed type char bInitSA;

//----- (000066B4) --------------------------------------------------------
int CheckSocketAddr()
{
  int v1; // esi
  const char *v2; // eax
  const char *v3; // eax
  int (__stdcall *v4)(SOCKET, LPWSABUF, DWORD, LPDWORD, DWORD, LPWSAOVERLAPPED, LPWSAOVERLAPPED_COMPLETION_ROUTINE); // [esp-8h] [ebp-8h]
  int (__stdcall *v5)(SOCKET, const char *, int, int); // [esp-8h] [ebp-8h]

  if ( !bInitSA )
    return 2;
  v1 = 0;
  if ( (int (__stdcall *)(SOCKET, LPWSABUF, DWORD, LPDWORD, DWORD, LPWSAOVERLAPPED, LPWSAOVERLAPPED_COMPLETION_ROUTINE))lpWSASend2 != WSASend )
  {
    if ( gg )
    {
      v4 = WSASend;
      v2 = _Dect1(&`string');
      CLog::Write((CGameGuard *)((char *)gg + 36), v2, v4);
    }
    v1 = 1;
  }
  if ( (int (__stdcall *)(SOCKET, const char *, int, int))lpsend2 != send )
  {
    if ( gg )
    {
      v5 = send;
      v3 = _Dect1(&`string');
      CLog::Write((CGameGuard *)((char *)gg + 36), v3, v5);
    }
    ++v1;
  }
  return v1 == 0;
}
// 394: using guessed type int lpWSASend2;
// 398: using guessed type int lpsend2;
// 39D: using guessed type char bInitSA;

//----- (00006780) --------------------------------------------------------
int __cdecl EncryptPacket(int a1, int a2)
{
  return PPEncryptClientPacket(a1, a2, &dwClientSequenceNumber);
}
// 85A0: using guessed type int __cdecl PPEncryptClientPacket(_DWORD, _DWORD, _DWORD);

//----- (000067A0) --------------------------------------------------------
int __cdecl DecryptPacket(int a1, int a2)
{
  return PPDecryptServerPacket(a1, a2, &dwServerSequenceNumber);
}
// 85A4: using guessed type int __cdecl PPDecryptServerPacket(_DWORD, _DWORD, _DWORD);

//----- (000067C0) --------------------------------------------------------
int __cdecl EncryptPeerPacket(int a1, int a2)
{
  return PPEncryptClientPacket(a1, a2, &a2);
}
// 85A0: using guessed type int __cdecl PPEncryptClientPacket(_DWORD, _DWORD, _DWORD);

//----- (000067E0) --------------------------------------------------------
int __cdecl DecryptPeerPacket(int a1, int a2)
{
  return PPDecryptClientPacket(a1, a2, &a2);
}
// 85A8: using guessed type int __cdecl PPDecryptClientPacket(_DWORD, _DWORD, _DWORD);

//----- (00006800) --------------------------------------------------------
char __cdecl CheckGameMonCrc(char *a1, char *a2, int a3)
{
  DWORD (__stdcall *v3)(); // edi
  int v4; // esi
  const char *v5; // eax
  const CHAR *v6; // eax
  LSTATUS v7; // eax
  const CHAR *v8; // eax
  unsigned int v9; // eax
  const char *v10; // eax
  char result; // al
  DWORD v12; // [esp-8h] [ebp-434h]
  const char *v13; // [esp-4h] [ebp-430h]
  const char *v14; // [esp-4h] [ebp-430h]
  unsigned int v15; // [esp+0h] [ebp-42Ch]
  unsigned int v16; // [esp+0h] [ebp-42Ch]
  int v17; // [esp+4h] [ebp-428h]
  LSTATUS v18; // [esp+4h] [ebp-428h]
  unsigned int v19; // [esp+8h] [ebp-424h] BYREF
  BYTE Data[4]; // [esp+Ch] [ebp-420h] BYREF
  HKEY phkResult; // [esp+10h] [ebp-41Ch] BYREF
  DWORD dwDisposition; // [esp+14h] [ebp-418h] BYREF
  DWORD cbData; // [esp+18h] [ebp-414h] BYREF
  char v24[1024]; // [esp+1Ch] [ebp-410h] BYREF
  int v25; // [esp+41Ch] [ebp-10h]
  unsigned int v26[2]; // [esp+420h] [ebp-Ch] BYREF
  int v27; // [esp+428h] [ebp-4h]

  v27 = -1;
  v26[1] = (unsigned int)&_L63959;
  v26[0] = __readfsdword((unsigned int)&_except_list);
  __writefsdword((unsigned int)&_except_list, (unsigned int)v26);
  cbData = 4;
  *(_DWORD *)Data = 0;
  v19 = 1;
  CFvCrc32::CFvCrc32((CFvCrc32 *)v24);
  v27 = 0;
  if ( !CFvCrc32::Crc32File((CFvCrc32 *)v24, a1, &v19) )
  {
    v3 = GetLastError;
    GetLastError();
    if ( gg )
    {
      v4 = v25;
      v12 = v3();
      v5 = _Dect1(&`string');
      CLog::Write((CGameGuard *)((char *)gg + 36), v5, a1, v4, v12);
    }
  }
  v6 = _Dect1(&`string');
  v7 = RegCreateKeyExA(HKEY_CURRENT_USER, v6, 0, 0, 0, 0xF003Fu, 0, &phkResult, &dwDisposition);
  if ( v7 )
  {
    if ( gg )
    {
      v18 = v7;
      v10 = _Dect1(&`string');
      CLog::Write((CGameGuard *)((char *)gg + 36), v10, v18);
    }
    v9 = v19;
  }
  else
  {
    if ( dwDisposition == 2 )
    {
      v8 = _Dect1(a2);
      RegQueryValueExA(phkResult, v8, 0, 0, Data, &cbData);
    }
    RegCloseKey(phkResult);
    v9 = v19;
    if ( v19 != *(_DWORD *)Data )
    {
      if ( gg )
      {
        v17 = *(_DWORD *)Data;
        v15 = v19;
        v13 = _Dect1(&`string');
        CLog::Write((CGameGuard *)((char *)gg + 36), v13, v15, v17);
      }
LABEL_16:
      v27 = -1;
      CFvCrc32::~CFvCrc32((CFvCrc32 *)v24);
      result = 0;
      __writefsdword((unsigned int)&_except_list, v26[0]);
      return result;
    }
  }
  if ( v9 != a3 )
  {
    if ( gg )
    {
      v16 = v9;
      v14 = _Dect1(&`string');
      CLog::Write((CGameGuard *)((char *)gg + 36), v14, v16, a3);
    }
    goto LABEL_16;
  }
  v27 = -1;
  CFvCrc32::~CFvCrc32((CFvCrc32 *)v24);
  result = 1;
  __writefsdword((unsigned int)&_except_list, v26[0]);
  return result;
}

//----- (00006A10) --------------------------------------------------------
void __usercall _L63947(int a1@<ebp>)
{
  CFvCrc32::~CFvCrc32((CFvCrc32 *)(a1 - 1040));
}

//----- (00006AEC) --------------------------------------------------------
int __cdecl ReadMemCrc(_DWORD *a1)
{
  const CHAR *v1; // eax
  HMODULE v2; // esi
  char *v3; // eax
  const char *v4; // edi
  char *v5; // eax
  const char *v6; // ecx
  int v7; // eax
  char v9[36]; // [esp+14h] [ebp-40h] BYREF
  int v10; // [esp+38h] [ebp-1Ch]

  v1 = _Dect1(&`string');
  v2 = GetModuleHandleA(v1);
  v3 = _Dect1(&`string');
  v4 = MyGetProcAddress(0, v2, (int)v3);
  v5 = _Dect1(&`string');
  v6 = MyGetProcAddress(0, v2, (int)v5);
  v7 = 0;
  if ( v6 )
    v7 = ((int (__stdcall *)(_DWORD, int, char *, int, _DWORD))v6)(*a1, 0x400000, v9, 64, 0);
  if ( v4 )
  {
    if ( v7 )
      return ~v10;
    v7 = ((int (__stdcall *)(_DWORD, int, char *, int, _DWORD))v4)(a1[2], 0x400000, v9, 64, 0);
  }
  if ( v7 )
    return ~v10;
  return 0;
}

//----- (00006BD8) --------------------------------------------------------
char __cdecl CheckVersion(int a1, unsigned __int16 a2, unsigned __int16 a3, unsigned __int16 a4, unsigned __int16 a5)
{
  const CHAR *v5; // eax
  HMODULE v6; // ebx
  char *v7; // eax
  const char *v8; // esi
  char *v9; // eax
  const char *v10; // edi
  char *v11; // eax
  const char *v12; // eax
  const char *v13; // ebp
  unsigned int v14; // eax
  unsigned int v15; // esi
  unsigned int v16; // esi
  const char *v17; // eax
  char v19; // [esp+29h] [ebp-11h]
  void *v20; // [esp+2Ah] [ebp-10h]
  int v21; // [esp+2Eh] [ebp-Ch] BYREF
  int v22; // [esp+32h] [ebp-8h] BYREF
  int v23; // [esp+36h] [ebp-4h] BYREF

  v19 = 1;
  v5 = _Dect1(&`string');
  v6 = LoadLibraryA(v5);
  if ( !v6 )
    return 1;
  v7 = _Dect1(&`string');
  v8 = MyGetProcAddress((int)v6, v6, (int)v7);
  v9 = _Dect1(&`string');
  v10 = MyGetProcAddress((int)v6, v6, (int)v9);
  v11 = _Dect1(&`string');
  v12 = MyGetProcAddress((int)v6, v6, (int)v11);
  v13 = v12;
  if ( v8 )
  {
    if ( v10 )
    {
      if ( v12 )
      {
        v14 = ((int (__stdcall *)(int, int *))v8)(a1, &v21);
        v15 = v14;
        if ( v14 )
        {
          v20 = operator new(v14);
          if ( ((int (__stdcall *)(int, int, unsigned int, void *))v10)(a1, v21, v15, v20) )
          {
            ((void (__stdcall *)(void *, const CHAR *, int *, int *))v13)(v20, "\\", &v22, &v23);
            if ( *(_DWORD *)v22 == -17890115 )
            {
              v16 = *(unsigned __int16 *)(v22 + 12)
                  + 100
                  * (HIWORD(*(_DWORD *)(v22 + 12))
                   + 100 * (*(unsigned __int16 *)(v22 + 8) + 100 * HIWORD(*(_DWORD *)(v22 + 8))));
              if ( gg )
              {
                v17 = _Dect1(&`string');
                CLog::Write((CGameGuard *)((char *)gg + 36), v17, a1, v16, a5 + 100 * (a4 + 100 * (a3 + 100 * a2)));
              }
              if ( v16 < a5 + 100 * (a4 + 100 * (a3 + 100 * (unsigned int)a2)) )
                v19 = 0;
            }
          }
          operator delete(v20);
        }
      }
    }
  }
  FreeLibrary(v6);
  return v19;
}

//----- (00006E0C) --------------------------------------------------------
const char *__userpurge MyGetProcAddress@<eax>(int a1@<ebx>, void *lp, int a3)
{
  const char *result; // eax
  char *v4; // eax
  int v5; // esi
  _DWORD *v6; // esi
  char *v7; // edi
  int v8; // ecx
  unsigned int v9; // ecx
  _BYTE *v10; // eax
  _DWORD *v11; // eax
  unsigned __int8 *v12; // esi
  unsigned int i; // eax
  unsigned __int8 *v14; // eax
  HMODULE v15; // eax
  int v16; // [esp-10h] [ebp-F8h]
  _DWORD v17[3]; // [esp-Ch] [ebp-F4h] BYREF
  unsigned __int8 Str[128]; // [esp+4h] [ebp-E4h] BYREF
  unsigned __int8 *v19; // [esp+84h] [ebp-64h]
  unsigned __int8 *v20; // [esp+88h] [ebp-60h]
  char v21; // [esp+8Ch] [ebp-5Ch]
  unsigned int v22; // [esp+90h] [ebp-58h]
  char v23; // [esp+94h] [ebp-54h]
  unsigned int v24; // [esp+98h] [ebp-50h]
  _DWORD *v25; // [esp+9Ch] [ebp-4Ch]
  unsigned __int16 *v26; // [esp+A0h] [ebp-48h]
  char *v27; // [esp+A4h] [ebp-44h]
  char *v28; // [esp+A8h] [ebp-40h]
  _DWORD *v29; // [esp+ACh] [ebp-3Ch]
  char *v30; // [esp+B0h] [ebp-38h]
  unsigned int v31; // [esp+B4h] [ebp-34h]
  void *v32; // [esp+B8h] [ebp-30h]
  int v33; // [esp+BCh] [ebp-2Ch]
  _DWORD *v34; // [esp+C0h] [ebp-28h]
  int v35; // [esp+C4h] [ebp-24h]
  const char *v36; // [esp+C8h] [ebp-20h]
  int v37; // [esp+CCh] [ebp-1Ch]
  _DWORD *v38; // [esp+D0h] [ebp-18h]
  unsigned int v39[3]; // [esp+D8h] [ebp-10h] BYREF
  int v40; // [esp+E4h] [ebp-4h]

  v40 = -1;
  v39[2] = (unsigned int)&_T63988;
  v39[1] = (unsigned int)&_except_handler3;
  v39[0] = __readfsdword((unsigned int)&_except_list);
  __writefsdword((unsigned int)&_except_list, (unsigned int)v39);
  v17[2] = a1;
  v38 = v17;
  if ( IsBadReadPtr(lp, 4u) )
  {
    result = 0;
    __writefsdword((unsigned int)&_except_list, v39[0]);
    return result;
  }
  v36 = 0;
  v37 = 0;
  v40 = 0;
  v32 = lp;
  if ( *(_WORD *)lp != 23117 )
    goto LABEL_28;
  v4 = (char *)lp + *((_DWORD *)lp + 15);
  v30 = v4;
  if ( *(_DWORD *)v4 != 17744 )
    goto LABEL_28;
  v33 = 0;
  v35 = 0;
  if ( *((_WORD *)v4 + 12) == 523 )
  {
    v28 = v4;
    v5 = *((_DWORD *)v4 + 34);
    v33 = v5;
    v35 = *((_DWORD *)v4 + 35);
  }
  else
  {
    v33 = *((_DWORD *)v4 + 30);
    v35 = *((_DWORD *)v4 + 31);
    v5 = v33;
  }
  if ( !v5 )
    goto LABEL_28;
  v6 = (char *)lp + v5;
  v29 = v6;
  v31 = 0;
  v7 = (char *)a3;
  if ( (unsigned int)a3 < 0x10000 )
  {
    v31 = a3;
    v8 = a3 - 1;
    goto LABEL_30;
  }
  v9 = 0;
  v24 = 0;
  v10 = (_BYTE *)a3;
  v27 = (char *)a3;
  while ( *v10 )
  {
    v27 = ++v10;
    v24 = ++v9;
    if ( v9 >= 0x100 )
      goto LABEL_28;
  }
  v11 = (char *)lp + v6[8];
  v25 = v11;
  v23 = 0;
  v31 = 0;
  while ( v31 < v6[6] )
  {
    v12 = (unsigned __int8 *)lp + *v11;
    v20 = v12;
    v27 = v7;
    if ( IsBadReadPtr(v12, 4u) )
      goto LABEL_28;
    v21 = 1;
    for ( i = 0; ; ++i )
    {
      v22 = i;
      if ( i >= v24 )
        break;
      if ( *v12 != *v7 )
      {
        v21 = 0;
        break;
      }
      v20 = ++v12;
      v27 = ++v7;
    }
    if ( v21 )
    {
      v23 = 1;
      v6 = v29;
      break;
    }
    ++v25;
    ++v31;
    v7 = (char *)a3;
    v6 = v29;
    v11 = v25;
  }
  if ( !v23 )
  {
LABEL_28:
    v40 = -1;
    result = 0;
    __writefsdword((unsigned int)&_except_list, v39[0]);
    return result;
  }
  v26 = (unsigned __int16 *)((char *)lp + 2 * v31 + v6[9]);
  v8 = *v26;
LABEL_30:
  v31 = v8;
  v34 = (char *)lp + 4 * v8 + v6[7];
  result = (char *)lp + *v34;
  v36 = result;
  if ( result >= (char *)lp + v33 && result < (char *)lp + v33 + v35 )
  {
    strcpy((char *)Str, result);
    v14 = __mbsstr(Str, &`string');
    v19 = v14;
    if ( v14 )
    {
      *v14++ = 0;
      v19 = v14;
    }
    v16 = (int)v14;
    v15 = GetModuleHandleA((LPCSTR)Str);
    result = (const char *)MyGetProcAddress(v15, v16);
    v36 = result;
  }
  __writefsdword((unsigned int)&_except_list, v39[0]);
  return result;
}
// 717C: using guessed type _SCOPETABLE_ENTRY _T63988;

//----- (00007188) --------------------------------------------------------
char CheckRsaBase()
{
  char v0; // bl
  const CHAR *v1; // eax
  LSTATUS (__stdcall *v2)(HKEY, LPCSTR, DWORD, REGSAM, PHKEY); // esi
  LSTATUS v3; // eax
  LSTATUS (__stdcall *v4)(HKEY, LPCSTR, LPDWORD, LPDWORD, LPBYTE, LPDWORD); // edi
  const CHAR *v5; // eax
  const char *v6; // eax
  const CHAR *v7; // eax
  const CHAR *v8; // eax
  const char *v9; // eax
  HANDLE v10; // eax
  void *v11; // esi
  const char *v12; // eax
  DWORD v13; // eax
  const char *v14; // eax
  const CHAR *v15; // eax
  HMODULE v16; // ebp
  char *v17; // eax
  const char *v18; // esi
  char *v19; // eax
  const char *v20; // edi
  char *v21; // eax
  const char *v22; // eax
  unsigned int v23; // eax
  unsigned int v24; // esi
  void *v25; // edi
  const char *v26; // eax
  const char *v27; // eax
  const CHAR *v28; // eax
  const char *v29; // eax
  int v31; // [esp+8h] [ebp-2D0h]
  int v32; // [esp+8h] [ebp-2D0h]
  int v33; // [esp+Ch] [ebp-2CCh]
  int v34; // [esp+Ch] [ebp-2CCh]
  int v35; // [esp+10h] [ebp-2C8h]
  DWORD v36; // [esp+10h] [ebp-2C8h]
  int v37; // [esp+10h] [ebp-2C8h]
  int v38; // [esp+14h] [ebp-2C4h]
  DWORD v39; // [esp+14h] [ebp-2C4h]
  int v40; // [esp+14h] [ebp-2C4h]
  BYTE v41; // [esp+28h] [ebp-2B0h] BYREF
  char v42; // [esp+29h] [ebp-2AFh]
  char v43; // [esp+2Ah] [ebp-2AEh]
  char v44; // [esp+2Bh] [ebp-2ADh]
  char v45; // [esp+2Ch] [ebp-2ACh]
  char v46; // [esp+2Dh] [ebp-2ABh]
  char v47; // [esp+2Eh] [ebp-2AAh]
  char v48; // [esp+2Fh] [ebp-2A9h]
  char v49; // [esp+30h] [ebp-2A8h]
  char v50; // [esp+31h] [ebp-2A7h]
  char v51; // [esp+32h] [ebp-2A6h]
  char v52; // [esp+33h] [ebp-2A5h]
  char v53; // [esp+34h] [ebp-2A4h]
  char v54; // [esp+35h] [ebp-2A3h]
  char v55; // [esp+36h] [ebp-2A2h]
  char v56; // [esp+37h] [ebp-2A1h]
  char v57; // [esp+38h] [ebp-2A0h]
  char v58; // [esp+39h] [ebp-29Fh]
  char v59; // [esp+3Ah] [ebp-29Eh]
  char v60; // [esp+3Bh] [ebp-29Dh]
  char v61; // [esp+3Ch] [ebp-29Ch]
  char v62; // [esp+3Dh] [ebp-29Bh]
  char v63; // [esp+3Eh] [ebp-29Ah]
  char v64; // [esp+3Fh] [ebp-299h]
  char v65; // [esp+40h] [ebp-298h]
  char v66; // [esp+41h] [ebp-297h]
  char v67; // [esp+42h] [ebp-296h]
  char v68; // [esp+43h] [ebp-295h]
  char v69; // [esp+44h] [ebp-294h]
  char v70; // [esp+45h] [ebp-293h]
  char v71; // [esp+46h] [ebp-292h]
  char v72; // [esp+47h] [ebp-291h]
  char v73; // [esp+48h] [ebp-290h]
  char v74; // [esp+49h] [ebp-28Fh]
  char v75; // [esp+4Ah] [ebp-28Eh]
  char v76; // [esp+4Bh] [ebp-28Dh]
  char v77; // [esp+4Ch] [ebp-28Ch]
  char v78; // [esp+4Dh] [ebp-28Bh]
  char v79; // [esp+4Eh] [ebp-28Ah]
  char v80; // [esp+4Fh] [ebp-289h]
  char v81; // [esp+50h] [ebp-288h]
  char v82; // [esp+51h] [ebp-287h]
  char v83; // [esp+52h] [ebp-286h]
  char v84; // [esp+53h] [ebp-285h]
  char v85; // [esp+54h] [ebp-284h]
  char v86; // [esp+55h] [ebp-283h]
  char v87; // [esp+56h] [ebp-282h]
  char v88; // [esp+57h] [ebp-281h]
  char v89; // [esp+58h] [ebp-280h]
  char v90; // [esp+59h] [ebp-27Fh]
  char v91; // [esp+5Ah] [ebp-27Eh]
  char v92; // [esp+5Bh] [ebp-27Dh]
  char v93; // [esp+5Ch] [ebp-27Ch]
  char v94; // [esp+5Dh] [ebp-27Bh]
  char v95; // [esp+5Eh] [ebp-27Ah]
  char v96; // [esp+5Fh] [ebp-279h]
  char v97; // [esp+60h] [ebp-278h]
  char v98; // [esp+61h] [ebp-277h]
  char v99; // [esp+62h] [ebp-276h]
  char v100; // [esp+63h] [ebp-275h]
  char v101; // [esp+64h] [ebp-274h]
  char v102; // [esp+65h] [ebp-273h]
  char v103; // [esp+66h] [ebp-272h]
  char v104; // [esp+67h] [ebp-271h]
  char v105; // [esp+68h] [ebp-270h]
  char v106; // [esp+69h] [ebp-26Fh]
  char v107; // [esp+6Ah] [ebp-26Eh]
  char v108; // [esp+6Bh] [ebp-26Dh]
  char v109; // [esp+6Ch] [ebp-26Ch]
  char v110; // [esp+6Dh] [ebp-26Bh]
  char v111; // [esp+6Eh] [ebp-26Ah]
  char v112; // [esp+6Fh] [ebp-269h]
  char v113; // [esp+70h] [ebp-268h]
  char v114; // [esp+71h] [ebp-267h]
  char v115; // [esp+72h] [ebp-266h]
  char v116; // [esp+73h] [ebp-265h]
  char v117; // [esp+74h] [ebp-264h]
  char v118; // [esp+75h] [ebp-263h]
  char v119; // [esp+76h] [ebp-262h]
  char v120; // [esp+77h] [ebp-261h]
  char v121; // [esp+78h] [ebp-260h]
  char v122; // [esp+79h] [ebp-25Fh]
  char v123; // [esp+7Ah] [ebp-25Eh]
  char v124; // [esp+7Bh] [ebp-25Dh]
  char v125; // [esp+7Ch] [ebp-25Ch]
  char v126; // [esp+7Dh] [ebp-25Bh]
  char v127; // [esp+7Eh] [ebp-25Ah]
  char v128; // [esp+7Fh] [ebp-259h]
  char v129; // [esp+80h] [ebp-258h]
  char v130; // [esp+81h] [ebp-257h]
  char v131; // [esp+82h] [ebp-256h]
  char v132; // [esp+83h] [ebp-255h]
  char v133; // [esp+84h] [ebp-254h]
  char v134; // [esp+85h] [ebp-253h]
  char v135; // [esp+86h] [ebp-252h]
  char v136; // [esp+87h] [ebp-251h]
  int v137; // [esp+88h] [ebp-250h]
  char v138; // [esp+8Ch] [ebp-24Ch]
  char v139; // [esp+8Dh] [ebp-24Bh]
  char v140; // [esp+8Eh] [ebp-24Ah]
  char v141; // [esp+8Fh] [ebp-249h]
  int v142; // [esp+90h] [ebp-248h]
  char v143; // [esp+94h] [ebp-244h]
  char v144; // [esp+95h] [ebp-243h]
  char v145; // [esp+96h] [ebp-242h]
  char v146; // [esp+97h] [ebp-241h]
  int v147; // [esp+98h] [ebp-240h]
  char v148; // [esp+9Ch] [ebp-23Ch]
  char v149; // [esp+9Dh] [ebp-23Bh]
  char v150; // [esp+9Eh] [ebp-23Ah]
  char v151; // [esp+9Fh] [ebp-239h]
  char v152; // [esp+A0h] [ebp-238h]
  char v153; // [esp+A1h] [ebp-237h]
  char v154; // [esp+A2h] [ebp-236h]
  char v155; // [esp+A3h] [ebp-235h]
  int v156; // [esp+A4h] [ebp-234h]
  char v157; // [esp+A8h] [ebp-230h]
  char v158; // [esp+A9h] [ebp-22Fh]
  char v159; // [esp+AAh] [ebp-22Eh]
  char v160; // [esp+ABh] [ebp-22Dh]
  char v161; // [esp+ACh] [ebp-22Ch]
  char v162; // [esp+ADh] [ebp-22Bh]
  char v163; // [esp+AEh] [ebp-22Ah]
  char v164; // [esp+AFh] [ebp-229h]
  HKEY phkResult; // [esp+B0h] [ebp-228h] BYREF
  DWORD cbData; // [esp+B4h] [ebp-224h] BYREF
  DWORD v167; // [esp+B8h] [ebp-220h]
  const char *v168; // [esp+BCh] [ebp-21Ch]
  int v169; // [esp+C0h] [ebp-218h] BYREF
  const char *v170; // [esp+C4h] [ebp-214h]
  int v171; // [esp+C8h] [ebp-210h] BYREF
  char v172[4]; // [esp+CCh] [ebp-20Ch] BYREF
  BYTE Data[4]; // [esp+D0h] [ebp-208h] BYREF
  CHAR Buffer[260]; // [esp+1D4h] [ebp-104h] BYREF

  v0 = 0;
  v1 = _Dect1(&`string');
  v2 = RegOpenKeyExA;
  v3 = RegOpenKeyExA(HKEY_LOCAL_MACHINE, v1, 0, 1u, &phkResult);
  v4 = RegQueryValueExA;
  if ( !v3 )
  {
    cbData = 260;
    v5 = _Dect1(&`string');
    if ( !v4(phkResult, v5, 0, 0, Data, &cbData) && gg )
    {
      v6 = _Dect1(&`string');
      CLog::Write((CGameGuard *)((char *)gg + 36), v6, Data);
    }
    RegCloseKey(phkResult);
  }
  v7 = _Dect1(&`string');
  if ( !v2(HKEY_LOCAL_MACHINE, v7, 0, 3u, &phkResult) )
  {
    cbData = 260;
    v8 = _Dect1(&`string');
    if ( !v4(phkResult, v8, 0, 0, Data, &cbData) && gg )
    {
      v38 = Data[3];
      v35 = Data[2];
      v33 = Data[1];
      v31 = Data[0];
      v9 = _Dect1(&`string');
      CLog::Write((CGameGuard *)((char *)gg + 36), v9, v31, v33, v35, v38);
    }
    GetSystemDirectoryA(Buffer, 0x104u);
    strcat(Buffer, _Dect1(&`string'));
    v167 = 0;
    v10 = CreateFileA(Buffer, 0x80000000, 3u, 0, 3u, 0x80u, 0);
    v11 = v10;
    if ( v10 == (HANDLE)-1 )
    {
      if ( gg )
      {
        v36 = GetLastError();
        v12 = _Dect1(&`string');
        CLog::Write((CGameGuard *)((char *)gg + 36), v12, v36, Buffer);
      }
    }
    else
    {
      v13 = GetFileSize(v10, 0);
      v167 = v13;
      if ( gg )
      {
        v39 = v13;
        v14 = _Dect1(&`string');
        CLog::Write((CGameGuard *)((char *)gg + 36), v14, v39);
      }
      CloseHandle(v11);
    }
    v15 = _Dect1(&`string');
    v16 = LoadLibraryA(v15);
    if ( v16 )
    {
      v17 = _Dect1(&`string');
      v18 = MyGetProcAddress(0, v16, (int)v17);
      v19 = _Dect1(&`string');
      v20 = MyGetProcAddress(0, v16, (int)v19);
      v170 = v20;
      v21 = _Dect1(&`string');
      v22 = MyGetProcAddress(0, v16, (int)v21);
      v168 = v22;
      if ( v18 )
      {
        if ( v20 )
        {
          if ( v22 )
          {
            v23 = ((int (__stdcall *)(CHAR *, int *))v18)(Buffer, &v171);
            v24 = v23;
            if ( v23 )
            {
              v25 = operator new(v23);
              ((void (__stdcall *)(CHAR *, int, unsigned int, void *))v170)(Buffer, v171, v24, v25);
              ((void (__stdcall *)(void *, const CHAR *, int *, char *))v168)(v25, "\\", &v169, v172);
              if ( *(_DWORD *)v169 == -17890115 && gg )
              {
                v40 = *(unsigned __int16 *)(v169 + 12);
                v37 = HIWORD(*(_DWORD *)(v169 + 12));
                v34 = *(unsigned __int16 *)(v169 + 8);
                v32 = HIWORD(*(_DWORD *)(v169 + 8));
                v26 = _Dect1(&`string');
                CLog::Write((CGameGuard *)((char *)gg + 36), v26, v32, v34, v37, v40);
              }
              operator delete(v25);
            }
          }
        }
      }
      FreeLibrary(v16);
    }
    if ( v167 == 101648 )
    {
      if ( gg )
      {
        v27 = _Dect1(&`string');
        CLog::Write((CGameGuard *)((char *)gg + 36), v27);
      }
      v42 = -57;
      v58 = -57;
      v92 = -14;
      v79 = 22;
      v96 = -14;
      v109 = 22;
      v41 = 42;
      v43 = 14;
      v44 = 16;
      v45 = 6;
      v46 = -66;
      v47 = -89;
      v48 = -51;
      v49 = -11;
      v50 = -6;
      v51 = 102;
      v52 = 15;
      v53 = -122;
      v54 = -93;
      v55 = -118;
      v56 = 65;
      v57 = 88;
      v59 = -81;
      v60 = 110;
      v61 = -11;
      v62 = -63;
      v63 = -110;
      v64 = 61;
      v65 = -11;
      v66 = 86;
      v67 = -88;
      v68 = -127;
      v69 = 72;
      v70 = 46;
      v71 = -119;
      v72 = 124;
      v73 = 4;
      v74 = 54;
      v75 = 83;
      v76 = -29;
      v77 = 100;
      v78 = 121;
      v80 = 52;
      v81 = 125;
      v82 = -24;
      v83 = -80;
      v84 = -82;
      v85 = -41;
      v86 = 60;
      v87 = -59;
      v88 = -21;
      v89 = 122;
      v90 = 37;
      v91 = 45;
      v93 = -72;
      v94 = -28;
      v95 = -12;
      v97 = -51;
      v98 = -107;
      v99 = 11;
      v100 = -35;
      v101 = 79;
      v102 = 10;
      v103 = -97;
      v104 = 39;
      v105 = 25;
      v106 = -75;
      v107 = -10;
      v108 = 82;
      v110 = 119;
      v111 = 1;
      v112 = 44;
      v113 = -10;
      v114 = -82;
      v115 = -102;
      v139 = -11;
      v116 = -45;
      v117 = 127;
      v118 = -65;
      v119 = 106;
      v120 = 34;
      v121 = -111;
      v122 = 107;
      v123 = -13;
      v124 = -37;
      v125 = -109;
      v126 = 13;
      v127 = 28;
      v128 = -46;
      v129 = 0;
      v130 = -75;
      v131 = -72;
      v132 = 20;
      v133 = 28;
      v134 = 62;
      v135 = -98;
      v136 = -108;
      v137 = -963729029;
      v138 = -124;
      v140 = 43;
      v141 = -6;
      v142 = -1526688331;
      v143 = -107;
      v144 = -78;
      v145 = 101;
      v146 = -116;
      v147 = 7805233;
      v148 = -51;
      v149 = 91;
      v150 = 78;
      v151 = -110;
      v152 = 104;
      v153 = -28;
      v154 = 66;
      v155 = 102;
      v156 = -1814776553;
      v157 = 0;
      v158 = 0;
      v159 = 0;
      v160 = 0;
      v161 = 0;
      v162 = 0;
      v163 = 0;
      v164 = 0;
      v28 = _Dect1(`string');
    }
    else
    {
      if ( v167 != 94480 )
      {
LABEL_35:
        RegCloseKey(phkResult);
        return v0;
      }
      if ( gg )
      {
        v29 = _Dect1(&`string');
        CLog::Write((CGameGuard *)((char *)gg + 36), v29);
      }
      v60 = 7;
      v81 = 7;
      v88 = 7;
      v41 = 95;
      v42 = 113;
      v43 = 105;
      v44 = 83;
      v45 = -118;
      v46 = -114;
      v47 = 84;
      v48 = -84;
      v49 = 9;
      v50 = 63;
      v51 = 101;
      v52 = 90;
      v53 = 38;
      v54 = -115;
      v55 = 119;
      v56 = 21;
      v57 = -98;
      v58 = 104;
      v59 = -69;
      v61 = -19;
      v62 = -113;
      v63 = -16;
      v64 = -73;
      v65 = -15;
      v66 = -103;
      v67 = 5;
      v68 = 21;
      v69 = 0x80;
      v70 = 100;
      v71 = -88;
      v72 = -40;
      v73 = -121;
      v74 = -61;
      v75 = 88;
      v76 = -87;
      v77 = -50;
      v78 = 38;
      v79 = -2;
      v80 = -77;
      v82 = -41;
      v83 = -93;
      v84 = -127;
      v85 = -66;
      v86 = -72;
      v87 = 110;
      v89 = 21;
      v90 = 104;
      v91 = 68;
      v92 = 23;
      v93 = -66;
      v94 = -127;
      v95 = 0x80;
      v96 = 117;
      v97 = -95;
      v98 = -37;
      v99 = -85;
      v100 = 33;
      v101 = -47;
      v102 = 31;
      v103 = -68;
      v104 = -100;
      v105 = 29;
      v106 = 73;
      v107 = -16;
      v108 = -27;
      v109 = -35;
      v110 = 73;
      v111 = 127;
      v112 = -75;
      v113 = -28;
      v114 = 9;
      v115 = -16;
      v116 = 57;
      v117 = -108;
      v131 = 32;
      v156 = 98602528;
      v118 = 42;
      v140 = 42;
      v119 = 107;
      v120 = -125;
      v121 = 15;
      v122 = -37;
      v123 = 86;
      v124 = 14;
      v125 = -93;
      v126 = 97;
      v127 = -97;
      v128 = 18;
      v129 = -44;
      v130 = -41;
      v132 = -112;
      v133 = 84;
      v134 = -101;
      v135 = -58;
      v136 = -103;
      v137 = -721206260;
      v138 = 27;
      v139 = -102;
      v141 = -96;
      v142 = -165901150;
      v143 = 104;
      v144 = -91;
      v145 = 87;
      v146 = 46;
      v147 = -1884995567;
      v148 = 119;
      v149 = 113;
      v150 = -20;
      v151 = 106;
      v152 = 105;
      v153 = -96;
      v154 = -53;
      v155 = 30;
      v157 = 0;
      v158 = 0;
      v159 = 0;
      v160 = 0;
      v161 = 0;
      v162 = 0;
      v163 = 0;
      v164 = 0;
      v28 = _Dect1(&`string');
    }
    RegSetValueExA(phkResult, v28, 0, 3u, &v41, 0x88u);
    v0 = 1;
    goto LABEL_35;
  }
  return v0;
}

//----- (00007D80) --------------------------------------------------------
char RemoveCompatibleMode()
{
  size_t v0; // eax
  unsigned __int8 *v1; // eax
  const CHAR *v2; // eax
  LSTATUS (__stdcall *v3)(HKEY, DWORD, LPSTR, LPDWORD, LPDWORD, LPDWORD, LPBYTE, LPDWORD); // ebx
  int v4; // ebp
  LSTATUS i; // eax
  unsigned __int8 *v6; // eax
  const char *v7; // eax
  DWORD v9; // [esp-28h] [ebp-56Ch]
  char v10; // [esp+7h] [ebp-53Dh]
  HKEY phkResult; // [esp+8h] [ebp-53Ch] BYREF
  DWORD cchValueName; // [esp+Ch] [ebp-538h] BYREF
  BYTE Data[32]; // [esp+10h] [ebp-534h] BYREF
  CHAR ValueName[260]; // [esp+30h] [ebp-514h] BYREF
  CHAR MultiByteStr[260]; // [esp+134h] [ebp-410h] BYREF
  unsigned __int8 String[260]; // [esp+238h] [ebp-30Ch] BYREF
  WCHAR Filename[260]; // [esp+33Ch] [ebp-208h] BYREF

  v10 = 0;
  GetModuleFileNameW(0, Filename, 0x104u);
  v0 = _wcslen(Filename);
  WideCharToMultiByte(0, 0, Filename, v0 + 1, MultiByteStr, 260, 0, 0);
  v1 = __mbsrchr((const unsigned __int8 *)MultiByteStr, 0x5Cu);
  if ( v1 )
    *v1 = 0;
  v2 = _Dect1(&`string');
  if ( RegOpenKeyExA(HKEY_CURRENT_USER, v2, 0, 3u, &phkResult) )
    return 0;
  v3 = RegEnumValueA;
  cchValueName = 260;
  v4 = 1;
  for ( i = RegEnumValueA(phkResult, 0, ValueName, &cchValueName, 0, 0, 0, 0);
        i != 259;
        i = v3(phkResult, v9, ValueName, &cchValueName, 0, 0, 0, 0) )
  {
    if ( !i )
    {
      strcpy((char *)String, ValueName);
      v6 = __mbsrchr(String, 0x5Cu);
      if ( v6 )
        *v6 = 0;
      if ( !__mbsicmp(String, (const unsigned __int8 *)MultiByteStr)
        && !RegQueryValueExA(phkResult, ValueName, 0, 0, Data, &cchValueName) )
      {
        if ( gg )
        {
          v7 = _Dect1(&`string');
          CLog::Write((CGameGuard *)((char *)gg + 36), v7, Data);
        }
        if ( !RegDeleteValueA(phkResult, ValueName) )
          v10 = 1;
      }
    }
    v9 = v4;
    cchValueName = 260;
    ++v4;
  }
  RegCloseKey(phkResult);
  return v10;
}

//----- (00007FE0) --------------------------------------------------------
char __cdecl DisableCompatibleMode(BYTE Data)
{
  char v1; // bl
  const CHAR *v2; // eax
  const CHAR *v3; // eax
  HKEY phkResult; // [esp+4h] [ebp-4h] BYREF

  v1 = 0;
  v2 = _Dect1(&`string');
  if ( !RegOpenKeyExA(HKEY_LOCAL_MACHINE, v2, 0, 0xF003Fu, &phkResult) )
  {
    v3 = _Dect1(&`string');
    if ( !RegSetValueExA(phkResult, v3, 0, 4u, &Data, 4u) )
      v1 = 1;
    RegCloseKey(phkResult);
  }
  return v1;
}

//----- (000080B0) --------------------------------------------------------
HMODULE CheckEncryptedClient()
{
  HMODULE result; // eax
  HMODULE v1; // esi
  HMODULE v2; // edx
  HMODULE v3; // ecx

  result = GetModuleHandleA(0);
  if ( *(_WORD *)result == 23117 )
  {
    if ( *((_DWORD *)result + 13) )
    {
      if ( *((_DWORD *)result + 14) )
      {
        bEncryptedClient = 1;
        if ( !*((_DWORD *)result + 12) )
          bEncryptedClientArm = 1;
      }
    }
    v1 = (HMODULE)*((_DWORD *)result + 14);
    if ( v1 )
    {
      v2 = (HMODULE)*((_DWORD *)result + 13);
      if ( v2 )
      {
        result = (HMODULE)*((_DWORD *)result + 12);
        if ( result )
        {
          if ( v2 <= v1 )
            v3 = (HMODULE)((char *)v1 - (char *)v2);
          else
            v3 = (HMODULE)((char *)v2 - (char *)v1);
          if ( result == v3 || v2 == v1 && result == v2 )
            bEncryptedClientArm = 1;
        }
      }
    }
  }
  return result;
}
// 364: using guessed type char bEncryptedClient;
// 365: using guessed type char bEncryptedClientArm;

//----- (00008120) --------------------------------------------------------
int FixVC80DEP()
{
  int v0; // edi
  HMODULE v1; // esi
  void (__stdcall *v2)(LPVOID, SIZE_T, DWORD, PDWORD); // ebx
  _DWORD *v3; // eax
  int v4; // edi
  _DWORD *v5; // eax
  DWORD flOldProtect; // [esp+Ch] [ebp-4h] BYREF

  v0 = 0;
  v1 = GetModuleHandleA(0);
  if ( v1 )
  {
    v2 = (void (__stdcall *)(LPVOID, SIZE_T, DWORD, PDWORD))VirtualProtect;
    if ( VirtualProtect(v1, 0x1000u, 4u, &flOldProtect) )
    {
      if ( *(_WORD *)v1 == 23117 )
      {
        v3 = (_DWORD *)((char *)v1 + *((_DWORD *)v1 + 15));
        if ( *v3 == 17744 )
        {
          v4 = v3[71];
          v5 = v3 + 62;
          v5[9] = v4 & 0x7FFFFFFF;
          v0 = 1;
          v5[19] &= 0x7FFFFFFFu;
        }
      }
      v2(v1, 0x1000u, flOldProtect, &flOldProtect);
    }
  }
  return v0;
}

//----- (000081A0) --------------------------------------------------------
HANDLE __cdecl WriteSMMsg(const void *a1, unsigned int a2)
{
  const CHAR *v2; // eax
  HANDLE (__stdcall *v3)(DWORD, BOOL, LPCSTR); // esi
  HANDLE v4; // edi
  const CHAR *v5; // eax
  HANDLE result; // eax
  char *v7; // ebx
  const CHAR *v8; // eax
  HANDLE (__stdcall *v9)(DWORD, BOOL, LPCSTR); // esi
  HANDLE v10; // ebp
  const CHAR *v11; // eax
  int v12; // ecx
  char *v13; // eax
  char *v14; // eax
  void (__stdcall *v15)(HANDLE); // esi
  HANDLE v16; // [esp+10h] [ebp-4h]

  v2 = _Dect1(&`string');
  v3 = OpenFileMappingA;
  v4 = OpenFileMappingA(0xF001Fu, 0, v2);
  v16 = v4;
  if ( !v4 )
  {
    v5 = _Dect1(&`string');
    result = v3(0xF001Fu, 0, v5);
    v16 = result;
    if ( !result )
      return result;
    v4 = result;
  }
  v7 = (char *)MapViewOfFile(v4, 0xF001Fu, 0, 0, 0x1000u);
  if ( v7 )
  {
    v8 = _Dect1(&`string');
    v9 = OpenMutexA;
    v10 = OpenMutexA(0x100000u, 0, v8);
    if ( v10 || (v11 = _Dect1(&`string'), (v10 = v9(0x100000u, 0, v11)) != 0) )
    {
      WaitForSingleObject(v10, 0xFFFFFFFF);
      v12 = *(_DWORD *)v7;
      v13 = v7;
      if ( *(_DWORD *)v7 )
      {
        while ( 1 )
        {
          v13 += v12;
          if ( (unsigned int)(v13 - v7) >= 0xFFC )
            break;
          v12 = *(_DWORD *)v13;
          if ( !*(_DWORD *)v13 )
            goto LABEL_14;
        }
        v13 = v7;
      }
LABEL_14:
      if ( v13 - v7 < 4092 - a2 )
      {
        qmemcpy(v13, a1, a2);
        v4 = v16;
        v14 = &v13[a2];
      }
      else
      {
        v14 = v7;
      }
      *(_DWORD *)v14 = 0;
      UnmapViewOfFile(v7);
      v15 = (void (__stdcall *)(HANDLE))CloseHandle;
      CloseHandle(v4);
      ReleaseMutex(v10);
      v15(v10);
      result = &pProcess32First + 1;
    }
    else
    {
      UnmapViewOfFile(v7);
      CloseHandle(v4);
      result = 0;
    }
  }
  else
  {
    CloseHandle(v4);
    result = 0;
  }
  return result;
}
// 0: using guessed type int (__stdcall *pProcess32First)(void *, struct tagPROCESSENTRY32 *);

//----- (00008340) --------------------------------------------------------
CNPDword *__thiscall CNPDword::CNPDword(CNPDword *this)
{
  *(_DWORD *)this = VirtualAlloc(0, 4u, 0x1000u, 4u);
  return this;
}

//----- (00008360) --------------------------------------------------------
void __thiscall CNPDword::~CNPDword(CNPDword *this)
{
  VirtualFree(*(LPVOID *)this, 4u, 0x4000u);
}

//----- (00008380) --------------------------------------------------------
void __thiscall CNPDword::Guard(CNPDword *this)
{
  DWORD flOldProtect; // [esp+0h] [ebp-4h] BYREF

  flOldProtect = (DWORD)this;
  VirtualProtect(*(LPVOID *)this, 4u, 2u, &flOldProtect);
}

//----- (000083A0) --------------------------------------------------------
void __thiscall CNPDword::Release(CNPDword *this)
{
  DWORD flOldProtect; // [esp+0h] [ebp-4h] BYREF

  flOldProtect = (DWORD)this;
  VirtualProtect(*(LPVOID *)this, 4u, 4u, &flOldProtect);
}

//----- (000083C0) --------------------------------------------------------
void __thiscall CNPDword::Set(CNPDword *this, unsigned int a2)
{
  CNPDword::Release(this);
  **(_DWORD **)this = a2;
  CNPDword::Guard(this);
}

//----- (000083E0) --------------------------------------------------------
unsigned int __thiscall CNPDword::Get(CNPDword *this)
{
  return **(_DWORD **)this;
}

// nfuncs=201 queued=76 decompiled=76 lumina nreq=0 worse=0 better=0
// ALL OK, 76 function(s) have been successfully decompiled
