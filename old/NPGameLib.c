/* This file was generated by the Hex-Rays decompiler.
   Copyright (c) 2007-2020 Hex-Rays <info@hex-rays.com>

   Detected compiler: Visual C++
*/

#include <windows.h>
#include <defs.h>

#include <stdarg.h>


//-------------------------------------------------------------------------
// Function declarations

#define __thiscall __cdecl // Test compile in C mode

int _E4();
CSafeAPI *_E1();
int _E3();
void __cdecl _E2(); // idb
unsigned int InitNPGameMon();
// void __usercall SetHwndToGameMon(int a1@<ebx>, HWND a2);
int __cdecl PreInitNPGameMonW(wchar_t *String); // idb
int __cdecl PreInitNPGameMonA(char *); // idb
unsigned int CheckNPGameMon();
int __cdecl SendUserIDToGameMonW(wchar_t *String); // idb
int __cdecl SendUserIDToGameMonA(char *); // idb
BOOL __cdecl SendCSAuthToGameMon(unsigned int a1);
BOOL __cdecl SendCSAuth2ToGameMon(struct _GG_AUTH_DATA *a1);
const char *GetInfoFromGameMon();
BOOL CloseNPGameMon();
void __thiscall CGameGuard::~CGameGuard(CGameGuard *__hidden this); // idb
// void __usercall _L63133(int a1@<ebp>);
unsigned int __thiscall CGameGuard::InitNPGameMonI(CGameGuard *__hidden this); // idb
DWORD __thiscall CGameGuard::PreInitNPGameMonI(CGameGuard *this, const char *Source);
void __thiscall CCriticalSector::~CCriticalSector(LPCRITICAL_SECTION lpCriticalSection); // idb
void __thiscall CLog::~CLog(CLog *__hidden this); // idb
// void __usercall _L63362(int a1@<ebp>);
char CLog::Write(CLog *this, const char *Format, ...);
// void __userpurge CGameGuard::SetHwndToGameMonI(CGameGuard *this@<ecx>, int a2@<ebx>, HWND a3);
char __thiscall CGameGuard::IsWinNT(CGameGuard *this);
char __thiscall CGameGuard::GetGameGuardDirectory(CGameGuard *this, LPSTR lpFilename, unsigned int a3);
char __thiscall CGameGuard::GetGameDirectory(CGameGuard *this, LPSTR lpFilename, unsigned int nSize);
unsigned int __thiscall CGameGuard::CheckNPGameMonI(CGameGuard *__hidden this); // idb
bool __thiscall CGameGuard::SendCSAuthToGameMonI(CGameGuard *__hidden this, unsigned int); // idb
bool __thiscall CGameGuard::SendUserIDToGameMonI(CGameGuard *__hidden this, const char *); // idb
const char *__thiscall CGameGuard::GetInfoFromGameMonI(CGameGuard *__hidden this); // idb
bool __thiscall CGameGuard::SendCSAuth2ToGameMonI(CGameGuard *__hidden this, struct _GG_AUTH_DATA *); // idb
bool __thiscall CGameGuard::CloseNPGameMonI(CGameGuard *__hidden this); // idb
char __thiscall CGameGuard::InitNPSC(CGameGuard *this);
char __thiscall CGameGuard::CloseNPSC(CGameGuard *this);
// DWORD __userpurge SpeedCheckEventThread@<eax>(int a1@<ebx>, LPVOID lpThreadParameter);
int __thiscall CGameGuard::CheckSingleInstance(CGameGuard *__hidden this, unsigned int); // idb
int __thiscall CGameGuard::CheckGameMonSingleInstance(CGameGuard *__hidden this, unsigned int); // idb
unsigned int __thiscall CGameGuard::IsDebugger(CGameGuard *__hidden this); // idb
// bool __userpurge CommPipeCallback@<al>(int a1@<ebx>, struct CCommPipe *a2, unsigned int a3, unsigned int a4);
void __thiscall CGameGuard::FtpSendErl(CGameGuard *__hidden this); // idb
// bool __usercall InitToolhelp32@<al>(int a1@<ebx>);
// char __usercall GetProcessList@<al>(int a1@<ebx>);
// char __usercall GetModuleList@<al>(int a1@<ebx>);
// LONG __userpurge FvUnhandledExceptionFilter@<eax>(int a1@<ebx>, struct _EXCEPTION_POINTERS *ExceptionInfo);
int __cdecl NPDect(int a1);
int InitTimeAddr();
int CheckTimeAddr();
// int __usercall InitSocketAddr@<eax>(int a1@<ebx>);
int CheckSocketAddr();
int __cdecl EncryptPacket(int a1, int a2);
int __cdecl DecryptPacket(int a1, int a2);
int __cdecl EncryptPeerPacket(int a1, int a2);
int __cdecl DecryptPeerPacket(int a1, int a2);
char __cdecl CheckGameMonCrc(char *a1, char *a2, int a3);
// void __usercall _L63571(int a1@<ebp>);
int __cdecl ReadMemCrc(_DWORD *a1);
char __cdecl CheckVersion(int a1, unsigned __int16 a2, unsigned __int16 a3, unsigned __int16 a4, unsigned __int16 a5);
// const char *__userpurge MyGetProcAddress@<eax>(int a1@<ebx>, void *lp, int a3);
char CheckRsaBase();
char RemoveCompatibleMode();
char __cdecl DisableCompatibleMode(BYTE Data);
HMODULE CheckEncryptedClient();
CNPDword *__thiscall CNPDword::CNPDword(CNPDword *this);
void __thiscall CNPDword::~CNPDword(CNPDword *__hidden this); // idb
void __thiscall CNPDword::Guard(CNPDword *__hidden this); // idb
void __thiscall CNPDword::Release(CNPDword *__hidden this); // idb
void __thiscall CNPDword::Set(CNPDword *__hidden this, unsigned int); // idb
unsigned int __thiscall CNPDword::Get(CNPDword *__hidden this); // idb
// CSafeAPI *__thiscall CSafeAPI::CSafeAPI(CSafeAPI *__hidden this); idb
// int __cdecl atexit(void (__cdecl *)());
// void __thiscall CSafeAPI::~CSafeAPI(CSafeAPI *__hidden this); idb
// int __stdcall WideCharToMultiByte(UINT CodePage, DWORD dwFlags, LPCWCH lpWideCharStr, int cchWideChar, LPSTR lpMultiByteStr, int cbMultiByte, LPCCH lpDefaultChar, LPBOOL lpUsedDefaultChar);
// size_t __cdecl wcslen(const wchar_t *String);
// BOOL __stdcall SetEvent(HANDLE hEvent);
// CFileAuthClient *__thiscall CFileAuthClient::CFileAuthClient(CFileAuthClient *__hidden this); idb
// CCommPipe *__thiscall CCommPipe::CCommPipe(CCommPipe *__hidden this); idb
// void __stdcall InitializeCriticalSection(LPCRITICAL_SECTION lpCriticalSection);
// void *__cdecl operator new(unsigned int); idb
// LPTOP_LEVEL_EXCEPTION_FILTER __stdcall SetUnhandledExceptionFilter(LPTOP_LEVEL_EXCEPTION_FILTER lpTopLevelExceptionFilter);
// void __cdecl operator delete(void *); idb
// void __stdcall DeleteCriticalSection(LPCRITICAL_SECTION lpCriticalSection);
// BOOL __stdcall CloseHandle(HANDLE hObject);
// BOOL __stdcall SetEndOfFile(HANDLE hFile);
// BOOL __stdcall WriteFile(HANDLE hFile, LPCVOID lpBuffer, DWORD nNumberOfBytesToWrite, LPDWORD lpNumberOfBytesWritten, LPOVERLAPPED lpOverlapped);
// int sprintf(char *const Buffer, const char *const Format, ...);
// char *__cdecl _Dect(char *); idb
// void __stdcall GetLocalTime(LPSYSTEMTIME lpSystemTime);
// void __thiscall CCommPipe::~CCommPipe(CCommPipe *__hidden this); idb
// void __thiscall CFileAuthClient::~CFileAuthClient(CFileAuthClient *__hidden this); idb
// char *__cdecl _Dect1(char *); idb
// bool __thiscall CCommPipe::SendCommPipe(CCommPipe *__hidden this, unsigned int, unsigned int, unsigned int); idb
// DWORD __stdcall ResumeThread(HANDLE hThread);
// unsigned int __thiscall CCommPipe::RunCommPipe(CCommPipe *__hidden this); idb
// void *__thiscall CCommPipe::GetChildReadHandle(CCommPipe *__hidden this); idb
// void *__thiscall CCommPipe::GetChildWriteHandle(CCommPipe *__hidden this); idb
// BOOL __stdcall ResetEvent(HANDLE hEvent);
// bool __thiscall CCommPipe::InitCommPipe(CCommPipe *__hidden this); idb
// HMODULE __stdcall GetModuleHandleA(LPCSTR lpModuleName);
// FARPROC __stdcall GetProcAddress(HMODULE hModule, LPCSTR lpProcName);
// unsigned int __cdecl MemGetPrivateProfileInt(const char *, const char *, int, char *); idb
// int __cdecl _mbsicmp(const unsigned __int8 *Str1, const unsigned __int8 *Str2);
// unsigned int __cdecl MemGetPrivateProfileString(const char *, const char *, const char *, char *, unsigned int, char *); idb
// bool __thiscall CFileAuthClient::DecryptMem(CFileAuthClient *__hidden this, const char *, char *, unsigned int, const char *); idb
// BOOL __stdcall GetExitCodeProcess(HANDLE hProcess, LPDWORD lpExitCode);
// DWORD __stdcall WaitForMultipleObjects(DWORD nCount, const HANDLE *lpHandles, BOOL bWaitAll, DWORD dwMilliseconds);
// BOOL __stdcall CreateProcessA(LPCSTR lpApplicationName, LPSTR lpCommandLine, LPSECURITY_ATTRIBUTES lpProcessAttributes, LPSECURITY_ATTRIBUTES lpThreadAttributes, BOOL bInheritHandles, DWORD dwCreationFlags, LPVOID lpEnvironment, LPCSTR lpCurrentDirectory, LPSTARTUPINFOA lpStartupInfo, LPPROCESS_INFORMATION lpProcessInformation);
// char *__cdecl _Enct(char *); idb
// int _wsprintfA(LPSTR, LPCSTR, ...);
// BOOL __stdcall ReadFile(HANDLE hFile, LPVOID lpBuffer, DWORD nNumberOfBytesToRead, LPDWORD lpNumberOfBytesRead, LPOVERLAPPED lpOverlapped);
// DWORD __stdcall SetFilePointer(HANDLE hFile, LONG lDistanceToMove, PLONG lpDistanceToMoveHigh, DWORD dwMoveMethod);
// DWORD __stdcall GetFileSize(HANDLE hFile, LPDWORD lpFileSizeHigh);
// bool __thiscall CFileAuthClient::Auth(CFileAuthClient *__hidden this, const char *, bool); idb
// HANDLE __stdcall CreateEventA(LPSECURITY_ATTRIBUTES lpEventAttributes, BOOL bManualReset, BOOL bInitialState, LPCSTR lpName);
// DWORD __stdcall WaitForSingleObject(HANDLE hHandle, DWORD dwMilliseconds);
// HANDLE __stdcall OpenEventA(DWORD dwDesiredAccess, BOOL bInheritHandle, LPCSTR lpName);
// DWORD __stdcall GetTickCount();
// HANDLE __stdcall CreateFileA(LPCSTR lpFileName, DWORD dwDesiredAccess, DWORD dwShareMode, LPSECURITY_ATTRIBUTES lpSecurityAttributes, DWORD dwCreationDisposition, DWORD dwFlagsAndAttributes, HANDLE hTemplateFile);
// unsigned __int8 *__cdecl _mbsrchr(const unsigned __int8 *String, unsigned int C);
// DWORD __stdcall GetModuleFileNameA(HMODULE hModule, LPSTR lpFilename, DWORD nSize);
// LPSTR __stdcall lstrcatA(LPSTR lpString1, LPCSTR lpString2);
// DWORD __stdcall GetLastError();
// BOOL __stdcall CreateDirectoryA(LPCSTR lpPathName, LPSECURITY_ATTRIBUTES lpSecurityAttributes);
// int __cdecl _access(const char *FileName, int AccessMode);
// unsigned __int8 *__cdecl _mbsnbcpy(unsigned __int8 *Dest, const unsigned __int8 *Source, size_t Count);
// DWORD __stdcall GetCurrentThreadId();
// DWORD __stdcall GetCurrentProcessId();
// void __stdcall LeaveCriticalSection(LPCRITICAL_SECTION lpCriticalSection);
// int __cdecl vsprintf(char *const Buffer, const char *const Format, va_list ArgList);
// void __stdcall EnterCriticalSection(LPCRITICAL_SECTION lpCriticalSection);
// int __stdcall NPGameMonCallback(unsigned int, unsigned int); idb
// BOOL __stdcall GetVersionExA(LPOSVERSIONINFOA lpVersionInformation);
// HANDLE __stdcall OpenMutexA(DWORD dwDesiredAccess, BOOL bInheritHandle, LPCSTR lpName);
// const char *__thiscall CCommPipe::GetUserInfo(CCommPipe *__hidden this); idb
// bool __thiscall CCommPipe::CloseCommPipe(CCommPipe *__hidden this); idb
// HANDLE __stdcall CreateThread(LPSECURITY_ATTRIBUTES lpThreadAttributes, SIZE_T dwStackSize, LPTHREAD_START_ROUTINE lpStartAddress, LPVOID lpParameter, DWORD dwCreationFlags, LPDWORD lpThreadId);
// HMODULE __stdcall LoadLibraryA(LPCSTR lpLibFileName);
// BOOL __stdcall FreeLibrary(HMODULE hLibModule);
// BOOL __stdcall TerminateThread(HANDLE hThread, DWORD dwExitCode);
// HANDLE __stdcall CreateMutexA(LPSECURITY_ATTRIBUTES lpMutexAttributes, BOOL bInitialOwner, LPCSTR lpName);
// BOOL __stdcall SetSecurityDescriptorDacl(PSECURITY_DESCRIPTOR pSecurityDescriptor, BOOL bDaclPresent, PACL pDacl, BOOL bDaclDefaulted);
// BOOL __stdcall InitializeSecurityDescriptor(PSECURITY_DESCRIPTOR pSecurityDescriptor, DWORD dwRevision);
// BOOL __stdcall ReleaseMutex(HANDLE hMutex);
// unsigned int *__thiscall CCommPipe::GetCSAuth2(CCommPipe *__hidden this); idb
// int _snprintf(char *const Buffer, const size_t BufferCount, const char *const Format, ...);
// BOOL __stdcall GetUserNameA(LPSTR lpBuffer, LPDWORD pcbBuffer);
// BOOL __stdcall GetComputerNameA(LPSTR lpBuffer, LPDWORD nSize);
// int __thiscall CSafeAPI::Init(CSafeAPI *__hidden this, const char *); idb
// HINSTANCE __thiscall CSafeAPI::GetModule(CSafeAPI *__hidden this); idb
// LSTATUS __stdcall RegCloseKey(HKEY hKey);
// LSTATUS __stdcall RegSetValueExA(HKEY hKey, LPCSTR lpValueName, DWORD Reserved, DWORD dwType, const BYTE *lpData, DWORD cbData);
// int __stdcall lstrlenA(LPCSTR lpString);
// int __stdcall lstrcmpA(LPCSTR lpString1, LPCSTR lpString2);
// LSTATUS __stdcall RegQueryValueExA(HKEY hKey, LPCSTR lpValueName, LPDWORD lpReserved, LPDWORD lpType, LPBYTE lpData, LPDWORD lpcbData);
// LSTATUS __stdcall RegCreateKeyExA(HKEY hKey, LPCSTR lpSubKey, DWORD Reserved, LPSTR lpClass, DWORD dwOptions, REGSAM samDesired, const LPSECURITY_ATTRIBUTES lpSecurityAttributes, PHKEY phkResult, LPDWORD lpdwDisposition);
// void __stdcall __noreturn ExitProcess(UINT uExitCode);
// DWORD __stdcall timeGetTime();
// BOOL __stdcall QueryPerformanceCounter(LARGE_INTEGER *lpPerformanceCount);
// int __stdcall send(SOCKET s, const char *buf, int len, int flags);
// int __stdcall WSASend(SOCKET s, LPWSABUF lpBuffers, DWORD dwBufferCount, LPDWORD lpNumberOfBytesSent, DWORD dwFlags, LPWSAOVERLAPPED lpOverlapped, LPWSAOVERLAPPED_COMPLETION_ROUTINE lpCompletionRoutine);
// int __cdecl PPEncryptClientPacket(_DWORD, _DWORD, _DWORD); weak
// int __cdecl PPDecryptServerPacket(_DWORD, _DWORD, _DWORD); weak
// int __cdecl PPDecryptClientPacket(_DWORD, _DWORD, _DWORD); weak
// void __thiscall CFvCrc32::~CFvCrc32(CFvCrc32 *__hidden this); idb
// bool __thiscall CFvCrc32::Crc32File(CFvCrc32 *__hidden this, const char *, unsigned int *); idb
// CFvCrc32 *__thiscall CFvCrc32::CFvCrc32(CFvCrc32 *__hidden this); idb
// unsigned __int8 *__cdecl _mbsstr(const unsigned __int8 *Str, const unsigned __int8 *Substr);
// BOOL __stdcall IsBadReadPtr(const void *lp, UINT_PTR ucb);
// UINT __stdcall GetSystemDirectoryA(LPSTR lpBuffer, UINT uSize);
// LSTATUS __stdcall RegOpenKeyExA(HKEY hKey, LPCSTR lpSubKey, DWORD ulOptions, REGSAM samDesired, PHKEY phkResult);
// LSTATUS __stdcall RegDeleteValueA(HKEY hKey, LPCSTR lpValueName);
// LSTATUS __stdcall RegEnumValueA(HKEY hKey, DWORD dwIndex, LPSTR lpValueName, LPDWORD lpcchValueName, LPDWORD lpReserved, LPDWORD lpType, LPBYTE lpData, LPDWORD lpcbData);
// DWORD __stdcall GetModuleFileNameW(HMODULE hModule, LPWSTR lpFilename, DWORD nSize);
// LPVOID __stdcall VirtualAlloc(LPVOID lpAddress, SIZE_T dwSize, DWORD flAllocationType, DWORD flProtect);
// BOOL __stdcall VirtualFree(LPVOID lpAddress, SIZE_T dwSize, DWORD dwFreeType);
// BOOL __stdcall VirtualProtect(LPVOID lpAddress, SIZE_T dwSize, DWORD flNewProtect, PDWORD lpflOldProtect);

//-------------------------------------------------------------------------
// Data declarations

int (__stdcall *pProcess32First)(void *, struct tagPROCESSENTRY32 *); // weak
int (__stdcall *pModule32Next)(void *, struct tagMODULEENTRY32 *); // weak
CHAR szLogFile; // idb
char byte_D; // weak
_UNKNOWN unk_D2; // weak
_UNKNOWN unk_DC; // weak
_UNKNOWN unk_E6; // weak
void *(__stdcall *pCreateToolhelp32Snapshot)(unsigned int, unsigned int); // weak
_UNKNOWN safeWinInet; // weak
_UNKNOWN unk_1F4; // weak
char szGameMon[260]; // idb
int (__stdcall *pModule32First)(void *, struct tagMODULEENTRY32 *); // weak
int (__stdcall *pProcess32Next)(void *, struct tagPROCESSENTRY32 *); // weak
int nSendErl; // weak
int g_dwThreadId; // weak
DWORD g_dwWaitTime; // idb
int g_dwNoUpdate; // weak
_UNKNOWN dwClientSequenceNumber; // weak
_UNKNOWN dwServerSequenceNumber; // weak
int dwWorkingPID; // weak
int bCheckGameMon; // weak
int dwDE; // weak
int dwRE; // weak
unsigned int dwGameMonPID; // weak
HANDLE hGameMonHandle; // idb
char bEncryptedClient; // weak
char bEncryptedClientArm; // weak
char bIsWin2K; // weak
CGameGuard *gg; // idb
int _dwCount__1__CheckNPGameMonI_CGameGuard__QAEKXZ_4KA; // weak
char _bInit__1__InitToolhelp32__YA_NXZ_4_NA; // weak
char _bInException__1__FvUnhandledExceptionFilter__YGJPAU_EXCEPTION_POINTERS___Z_4_NA; // weak
int lpGTC; // weak
int lpQPC; // weak
int lpTGT; // weak
int lpWSASend; // weak
int lpsend; // weak
int lpGTC2; // weak
int lpQPC2; // weak
int lpTGT2; // weak
int lpWSASend2; // weak
int lpsend2; // weak
char bInitTA; // weak
char bInitSA; // weak
char *CONTAINER_NAME = &`string'; // idb
int nSendErlIni = 1; // weak
int g_dwLoseAllowFactor = 4; // weak
_UNKNOWN _L63193; // weak
char `string' = '\x01'; // idb
_UNKNOWN `string'; // weak
_UNKNOWN `string'; // weak
char `string' = '\x01'; // idb
char `string' = '\x01'; // idb
char `string' = '\x01'; // idb
char `string' = '\x01'; // idb
char `string' = '\x01'; // idb
char `string' = '\x01'; // idb
char `string' = '\x01'; // idb
char `string' = '\x01'; // idb
char `string' = '\x01'; // idb
char `string' = '\x01'; // idb
char `string' = '\x01'; // idb
char `string' = '\x01'; // idb
char `string'[27] =
{
  '\x01',
  '\xF6',
  'G',
  '\x18',
  '\n',
  '\f',
  '6',
  '\"',
  '\x1B',
  '\x8D',
  '\x9A',
  'm',
  '\xF6',
  '\xD2',
  'a',
  '\t',
  '\x1F',
  'Z',
  '\xDE',
  'K',
  '\xB7',
  '\xAE',
  '\x9F',
  'S',
  '\xF7',
  '\x7F',
  '\0'
}; // idb
char `string' = '\x01'; // idb
char `string' = '\x01'; // idb
char `string' = '\x01'; // idb
char `string' = '\x01'; // idb
char `string' = '\x01'; // idb
char `string' = '\x01'; // idb
char `string' = '\x01'; // idb
char `string' = '\x01'; // idb
char `string' = '\x01'; // idb
char `string' = '\x01'; // idb
char `string' = '\x01'; // idb
char `string' = '\x01'; // idb
char `string' = '\x01'; // idb
char `string' = '\x01'; // idb
char `string' = '\x01'; // idb
char `string' = '\x01'; // idb
char `string' = '\x01'; // idb
char `string' = '\x01'; // idb
char `string' = '\x01'; // idb
char `string' = '\x01'; // idb
char `string' = '\x01'; // idb
char `string' = '\x01'; // idb
char `string' = '\x01'; // idb
char `string' = '\x01'; // idb
char `string' = '\x01'; // idb
char `string' = '\x01'; // idb
char `string' = '\x01'; // idb
char `string' = '\x01'; // idb
char `string' = '\x01'; // idb
char `string' = '\x01'; // idb
char `string' = '\x01'; // idb
char `string' = '\x01'; // idb
char `string'[24] =
{
  '\x01',
  '\xAD',
  'l',
  'n',
  '\xD9',
  '\'',
  '}',
  'U',
  '\xD9',
  't',
  'H',
  '\x85',
  ' ',
  '_',
  '\x85',
  '\x8C',
  '\x84',
  '\xD1',
  ')',
  '9',
  'p',
  '\f',
  '\xD0',
  '\0'
}; // idb
char `string' = '\x01'; // idb
char `string' = '\x01'; // idb
char `string' = '\x01'; // idb
char `string' = '\x01'; // idb
char `string' = '\x01'; // idb
char `string' = '\x01'; // idb
char `string' = '\x01'; // idb
char `string' = '\x01'; // idb
char `string' = '\x01'; // idb
char `string' = '\x01'; // idb
char `string' = '\x01'; // idb
char `string' = '\x01'; // idb
char `string' = '\x01'; // idb
char `string' = '\x01'; // idb
char `string' = '\x01'; // idb
char `string' = '\x01'; // idb
char `string' = '\x01'; // idb
char `string' = '\x01'; // idb
char `string'[36] =
{
  '\x01',
  '\xC4',
  '\xB1',
  'S',
  '^',
  '\xE2',
  '\x8C',
  '\x95',
  'a',
  '\x1D',
  '\x81',
  '{',
  '\xEA',
  '\x86',
  '\xB0',
  '\xAA',
  '\xEC',
  '\xBB',
  '\xF9',
  '\xCC',
  '\x98',
  'F',
  '\xAC',
  '\xFA',
  '\x81',
  '8',
  '\xE7',
  '\xDD',
  '\x04',
  '\xEC',
  '\x95',
  'D',
  '@',
  '\x04',
  '\x04',
  '\0'
}; // idb
char `string'[35] =
{
  '\x01',
  ']',
  '|',
  '\xB3',
  '\x03',
  '\x8B',
  'A',
  '\xC4',
  '\\',
  '\xD4',
  'l',
  't',
  '\xFE',
  '\x80',
  '\x80',
  'f',
  '\r',
  '\xC2',
  '<',
  '\xE8',
  '\x96',
  '\xBC',
  '\xAA',
  '\xF1',
  '\xE8',
  '\xF7',
  '\x8D',
  '\x94',
  '\\',
  '\xE5',
  '\xB4',
  '\xD0',
  't',
  '\xF4',
  '\0'
}; // idb
char `string' = '\x01'; // idb
char `string' = '\x01'; // idb
char `string' = '\x01'; // idb
char `string' = '\x01'; // idb
char `string' = '\x01'; // idb
char `string' = '\x01'; // idb
char `string' = '\x01'; // idb
char `string' = '\x01'; // idb
char `string' = '\x01'; // idb
_UNKNOWN _L63393; // weak
char `string' = '\x01'; // idb
char `string' = '\x01'; // idb
char `string' = '\x01'; // idb
char `string' = '\x01'; // idb
char `string' = '\x01'; // idb
char `string' = '\x01'; // idb
char `string' = '\x01'; // idb
char `string' = '\x01'; // idb
char `string' = '\x01'; // idb
unsigned __int8 `string' = 46u; // idb
char `string' = '\x01'; // idb
char `string' = '\x01'; // idb
char `string' = '\x01'; // idb
char `string' = '\x01'; // idb
char `string' = '\x01'; // idb
char `string' = '\x01'; // idb
char `string' = '\x01'; // idb
char `string' = '\x01'; // idb
char `string' = '\x01'; // idb
char `string' = '\x01'; // idb
char `string' = '\x01'; // idb
char `string' = '\x01'; // idb
char `string' = '\x01'; // idb
char `string' = '\x01'; // idb
char `string'[28] =
{
  '\x01',
  '\x82',
  '\xEB',
  '\xED',
  'n',
  '\xC0',
  '*',
  'v',
  'l',
  '\x86',
  '~',
  '\xEF',
  '\xB3',
  '\xFD',
  '\x1B',
  '\xF7',
  '\x8C',
  'm',
  'k',
  '|',
  '\xE6',
  '\xA7',
  '\xCF',
  '\x0E',
  '\xBF',
  '3',
  '\x1F',
  '\0'
}; // idb
char `string' = '\x01'; // idb
char `string'[35] =
{
  '\x01',
  '\x8D',
  '\f',
  'C',
  '\x13',
  '[',
  '\xD1',
  '4',
  'L',
  '\x84',
  '\x88',
  '\xA5',
  '\xD2',
  '|',
  '\xE5',
  '\xA1',
  '\xA8',
  '\xB7',
  '\xCD',
  'T',
  '\x9C',
  ')',
  '\'',
  'V',
  '\xAC',
  '\xA9',
  '\x0E',
  '\xC8',
  '!',
  '\x9D',
  '\b',
  '\x85',
  '\r',
  '\xD5',
  '\0'
}; // idb
char `string'[39] =
{
  '\x01',
  '\x81',
  '\xE8',
  '\xD3',
  'O',
  '/',
  '5',
  'H',
  '\xC0',
  '0',
  '}',
  '\x97',
  '\xB9',
  '\xA3',
  '\xD4',
  '9',
  '\xD7',
  '\xB5',
  '\xED',
  '\xB4',
  '\xC8',
  'u',
  '\x91',
  'j',
  '?',
  'p',
  '\xAE',
  '\xA4',
  '\x12',
  '\xD9',
  '`',
  '\x9F',
  'E',
  '\xCC',
  'D',
  '\x91',
  'i',
  'y',
  '\0'
}; // idb
char `string'[25] =
{
  '\x01',
  '\xE6',
  '\x17',
  'j',
  '\xFF',
  '=',
  'N',
  '\xA2',
  '\xC7',
  '\xB3',
  '\xA5',
  '\xFC',
  '\x82',
  '\x90',
  '\xA6',
  '\xF6',
  '\xDD',
  '\v',
  '\x1E',
  '\xF2',
  '?',
  'R',
  '\xAA',
  '\x82',
  '\0'
}; // idb
char `string' = '\x01'; // idb
char `string' = '\x01'; // idb
char `string' = '\x01'; // idb
char `string' = '\x01'; // idb
char `string' = '\x01'; // idb
char `string' = '\x01'; // idb
char `string' = '\x01'; // idb
char `string' = '\x01'; // idb
char `string' = '\x01'; // idb
char `string' = '\x01'; // idb
char `string' = '\x01'; // idb
char `string' = '\x01'; // idb
char `string' = '\x01'; // idb
char `string' = '\x01'; // idb
char `string' = '\x01'; // idb
char `string' = '\x01'; // idb
char `string' = '\x01'; // idb
char `string' = '\x01'; // idb
char `string' = '\x01'; // idb
char `string' = '\x01'; // idb
char `string' = '\x01'; // idb
char `string'[9] = { '\x01', 'V', 'g', 'j', '\xEC', '\xAC', '\x1C', '\xD3', '\0' }; // idb
char `string'[10] = { '\x01', '\x16', '\xA7', '+', '\xA0', '\xEA', '\xDA', '\x15', '\xF0', '\0' }; // idb
char `string'[11] = { '\x01', '\xC5', '\xB4', 'S', 'M', '\x91', '\xB8', '\xAC', '\xD4', '|', '\0' }; // idb
char `string'[13] =
{
  '\x01',
  '\xE7',
  '\x1A',
  '\x8F',
  '\xA0',
  '\xCC',
  'W',
  '\xEF',
  'r',
  '\x1A',
  '\xDE',
  'R',
  '\0'
}; // idb
char `string'[9] = { '\x01', '\xAA', 'c', 'f', '6', '8', ']', '\x85', '\0' }; // idb
char `string'[9] = { '\x01', '\xF2', ';', '\xEE', '\x9E', 'p', '\xFA', '\x86', '\0' }; // idb
char `string'[8] = { '\x01', 'K', 'F', '\b', '8', '3', 'h', '\0' }; // idb
char `string'[10] = { '\x01', '6', '\a', 'K', 'F', '\xD0', 'm', '\xF9', '\x89', '\0' }; // idb
char `string'[11] =
{
  '\x01',
  '\xD1',
  '\xD8',
  '\xC7',
  '\x1D',
  '\xC1',
  '7',
  '\x98',
  ']',
  '\xD6',
  '\0'
}; // idb
char `string' = '\x01'; // idb
char `string' = '\x01'; // idb
char `string' = '\x01'; // idb
char `string' = '\x01'; // idb
char `string' = '\x01'; // idb
char `string' = '\x01'; // idb
char `string' = '\x01'; // idb
char `string' = '\x01'; // idb
char `string' = '\x01'; // idb
char `string' = '\x01'; // idb
char `string' = '\x01'; // idb
char `string' = '\x01'; // idb
char `string' = '\x01'; // idb
char `string' = '\x01'; // idb
char `string' = '\x01'; // idb
char `string' = '\x01'; // idb
char `string' = '\x01'; // idb
char `string' = '\x01'; // idb
char `string' = '\x01'; // idb
char `string' = '\x01'; // idb
char `string' = '\x01'; // idb
char `string' = '\x01'; // idb
char `string' = '\x01'; // idb
char `string' = '\x01'; // idb
char `string' = '\x01'; // idb
char `string' = '\x01'; // idb
char `string' = '\x01'; // idb
char `string' = '\x01'; // idb
char `string' = '\x01'; // idb
char `string' = '\x01'; // idb
char `string' = '\x01'; // idb
char `string' = '\x01'; // idb
char `string' = '\x01'; // idb
char `string' = '\x01'; // idb
char `string' = '\x01'; // idb
char `string' = '\x01'; // idb
char `string' = '\x01'; // idb
char `string' = '\x01'; // idb
char `string' = '\x01'; // idb
char `string' = '\x01'; // idb
char `string' = '\x01'; // idb
char `string' = '\x01'; // idb
char `string' = '\x01'; // idb
char `string' = '\x01'; // idb
char `string' = '\x01'; // idb
char `string' = '\x01'; // idb
char `string' = '\x01'; // idb
char `string' = '\x01'; // idb
char `string' = '\x01'; // idb
char `string' = '\x01'; // idb
char `string' = '\x01'; // idb
char `string' = '\x01'; // idb
char `string' = '\x01'; // idb
_UNKNOWN _L63583; // weak
char `string' = '\x01'; // idb
char `string' = '\x01'; // idb
char `string' = '\x01'; // idb
char `string' = '\x01'; // idb
char `string' = '\x01'; // idb
char `string' = '\x01'; // idb
char `string' = '\x01'; // idb
char `string' = '\x01'; // idb
char `string' = '\x01'; // idb
char `string' = '\x01'; // idb
char `string' = '\x01'; // idb
char `string' = '\x01'; // idb
char `string' = '\x01'; // idb
_SCOPETABLE_ENTRY _T63612 = { -1, &_L63601, &_L63602 }; // weak
char `string' = '\x01'; // idb
char `string' = '\x01'; // idb
char `string'[14] =
{
  '\x01',
  'I',
  '@',
  '\xF0',
  'w',
  '\xCC',
  'O',
  '\xDF',
  '-',
  'i',
  '\xE5',
  '\x9B',
  '\x91',
  '\0'
}; // idb
char `string' = '\x01'; // idb
char `string' = '\x01'; // idb
char `string' = '\x01'; // idb
char `string' = '\x01'; // idb
char `string' = '\x01'; // idb
char `string' = '\x01'; // idb
char `string' = '\x01'; // idb
char `string' = '\x01'; // idb
char `string' = '\x01'; // idb
char `string' = '\x01'; // idb
char `string' = '\x01'; // idb
char `string' = '\x01'; // idb
char `string' = '\x01'; // idb
// extern _UNKNOWN _except_list; weak
// extern _UNKNOWN _except_handler3; weak


//----- (000003C0) --------------------------------------------------------
int _E4()
{
  _E1();
  return _E3();
}

//----- (000003D0) --------------------------------------------------------
CSafeAPI *_E1()
{
  return CSafeAPI::CSafeAPI((CSafeAPI *)&safeWinInet);
}

//----- (000003E0) --------------------------------------------------------
int _E3()
{
  return atexit(_E2);
}

//----- (000003F0) --------------------------------------------------------
void __cdecl _E2()
{
  CSafeAPI::~CSafeAPI((CSafeAPI *)&safeWinInet);
}

//----- (00000400) --------------------------------------------------------
unsigned int InitNPGameMon()
{
  unsigned int result; // eax

  if ( gg )
    result = CGameGuard::InitNPGameMonI(gg);
  else
    result = 0;
  return result;
}

//----- (00000420) --------------------------------------------------------
void __usercall SetHwndToGameMon(int a1@<ebx>, HWND a2)
{
  if ( gg )
    CGameGuard::SetHwndToGameMonI(gg, a1, a2);
}

//----- (00000450) --------------------------------------------------------
int __cdecl PreInitNPGameMonW(wchar_t *String)
{
  size_t v1; // eax
  CHAR MultiByteStr[32]; // [esp+4h] [ebp-20h] BYREF

  v1 = wcslen(String);
  WideCharToMultiByte(0, 0, String, v1 + 1, MultiByteStr, 32, 0, 0);
  return PreInitNPGameMonA(MultiByteStr);
}

//----- (00000490) --------------------------------------------------------
int __cdecl PreInitNPGameMonA(char *a1)
{
  void (__stdcall *v2)(LPTOP_LEVEL_EXCEPTION_FILTER); // ebp
  LONG (__stdcall *v3)(struct _EXCEPTION_POINTERS *); // edi
  char *v4; // esi
  CGameGuard *v5; // ecx

  if ( gg )
    return 0;
  v2 = (void (__stdcall *)(LPTOP_LEVEL_EXCEPTION_FILTER))SetUnhandledExceptionFilter;
  v3 = SetUnhandledExceptionFilter((LPTOP_LEVEL_EXCEPTION_FILTER)FvUnhandledExceptionFilter);
  v4 = (char *)operator new(0x1288u);
  if ( v4 )
  {
    *v4 = 0;
    v4[1] = 0;
    *((_DWORD *)v4 + 1) = 0;
    *((_DWORD *)v4 + 2) = 0;
    *((_DWORD *)v4 + 3) = 0;
    *((_DWORD *)v4 + 4) = 0;
    *((_DWORD *)v4 + 5) = 0;
    *((_DWORD *)v4 + 6) = 0;
    v4[28] = 0;
    v4[29] = 0;
    v4[30] = 0;
    v4[31] = 0;
    *((_DWORD *)v4 + 8) = -1;
    InitializeCriticalSection((LPCRITICAL_SECTION)(v4 + 36));
    *((_DWORD *)v4 + 1046) = 0;
    CCommPipe::CCommPipe((CCommPipe *)(v4 + 4188));
    CFileAuthClient::CFileAuthClient((CFileAuthClient *)(v4 + 4532));
    *((_DWORD *)v4 + 1151) = 0;
    *((_DWORD *)v4 + 1160) = 0;
    *((_DWORD *)v4 + 1161) = 0;
    v4[4712] = 0;
    v4[4713] = 0;
    *((_DWORD *)v4 + 1179) = 1000;
    *((_DWORD *)v4 + 1180) = 0;
    *((_DWORD *)v4 + 1181) = 0;
    *((_DWORD *)v4 + 1182) = 0;
    v4[4732] = 0;
    *((_DWORD *)v4 + 1184) = 0;
    *((_DWORD *)v4 + 1185) = 0;
    v4[4648] = 0;
    v5 = (CGameGuard *)v4;
  }
  else
  {
    v5 = 0;
  }
  gg = v5;
  *((_DWORD *)v5 + 4) = CGameGuard::PreInitNPGameMonI(v5, a1);
  if ( *((_DWORD *)gg + 6) )
    SetEvent(*((HANDLE *)gg + 6));
  if ( v3 )
    v2(v3);
  return *((_DWORD *)gg + 4);
}

//----- (000005C0) --------------------------------------------------------
unsigned int CheckNPGameMon()
{
  unsigned int result; // eax

  if ( gg )
    result = CGameGuard::CheckNPGameMonI(gg);
  else
    result = 0;
  return result;
}

//----- (000005E0) --------------------------------------------------------
int __cdecl SendUserIDToGameMonW(wchar_t *String)
{
  int v2; // eax
  CHAR MultiByteStr[64]; // [esp+4h] [ebp-40h] BYREF

  if ( !String )
    return 0;
  v2 = wcslen(String);
  WideCharToMultiByte(0, 0, String, v2, MultiByteStr, 64, 0, 0);
  return SendUserIDToGameMonA(MultiByteStr);
}

//----- (00000630) --------------------------------------------------------
int __cdecl SendUserIDToGameMonA(char *a1)
{
  int result; // eax

  if ( !gg )
    return 0;
  result = (int)a1;
  if ( a1 )
    result = CGameGuard::SendUserIDToGameMonI(gg, a1);
  return result;
}

//----- (00000660) --------------------------------------------------------
BOOL __cdecl SendCSAuthToGameMon(unsigned int a1)
{
  BOOL result; // eax

  if ( gg )
    result = CGameGuard::SendCSAuthToGameMonI(gg, a1);
  else
    result = 0;
  return result;
}

//----- (00000680) --------------------------------------------------------
BOOL __cdecl SendCSAuth2ToGameMon(struct _GG_AUTH_DATA *a1)
{
  BOOL result; // eax

  if ( gg )
    result = CGameGuard::SendCSAuth2ToGameMonI(gg, a1);
  else
    result = 0;
  return result;
}

//----- (000006A0) --------------------------------------------------------
const char *GetInfoFromGameMon()
{
  const char *result; // eax

  if ( gg )
    result = CGameGuard::GetInfoFromGameMonI(gg);
  else
    result = 0;
  return result;
}

//----- (000006C0) --------------------------------------------------------
BOOL CloseNPGameMon()
{
  CGameGuard *v1; // esi
  bool v2; // [esp+0h] [ebp-4h]

  if ( !gg )
    return 0;
  v2 = CGameGuard::CloseNPGameMonI(gg);
  v1 = gg;
  if ( gg )
  {
    CGameGuard::~CGameGuard(gg);
    operator delete(v1);
  }
  gg = 0;
  return v2;
}

//----- (00000710) --------------------------------------------------------
void __thiscall CGameGuard::~CGameGuard(CGameGuard *this)
{
  char *v2; // esi
  HANDLE v3; // eax
  unsigned int v4; // eax
  bool v5; // cc
  void *v6; // eax
  const char *v7; // eax
  signed int v8; // ecx
  _BYTE *v9; // eax
  int v10; // edx
  _BYTE *v11; // eax
  int v12; // edx
  int v13; // [esp-2Ch] [ebp-40h]
  int v14; // [esp-28h] [ebp-3Ch]
  int v15; // [esp-24h] [ebp-38h]
  int v16; // [esp-20h] [ebp-34h]
  int v17; // [esp-1Ch] [ebp-30h]
  int v18; // [esp-18h] [ebp-2Ch]
  int v19; // [esp-14h] [ebp-28h]
  void *v20; // [esp-10h] [ebp-24h]
  DWORD NumberOfBytesWritten; // [esp+4h] [ebp-10h] BYREF
  unsigned int v22[2]; // [esp+8h] [ebp-Ch] BYREF
  int v23; // [esp+10h] [ebp-4h]

  v22[1] = (unsigned int)&_L63193;
  v22[0] = __readfsdword((unsigned int)&_except_list);
  __writefsdword((unsigned int)&_except_list, (unsigned int)v22);
  v23 = 1;
  CFileAuthClient::~CFileAuthClient((CGameGuard *)((char *)this + 4532));
  LOBYTE(v23) = 0;
  CCommPipe::~CCommPipe((CGameGuard *)((char *)this + 4188));
  v2 = (char *)this + 32;
  v3 = *(HANDLE *)v2;
  v23 = 2;
  if ( v3 != (HANDLE)-1 )
  {
    GetLocalTime((LPSYSTEMTIME)(v2 + 4124));
    v4 = *((_DWORD *)v2 + 1037);
    if ( !v4 || (v5 = *((_DWORD *)v2 + 1038) <= v4, v6 = &`string', v5) )
      v6 = &`string';
    v20 = v6;
    v19 = *((unsigned __int16 *)v2 + 2069);
    v18 = *((unsigned __int16 *)v2 + 2068);
    v17 = *((unsigned __int16 *)v2 + 2067);
    v16 = *((unsigned __int16 *)v2 + 2066);
    v15 = *((unsigned __int16 *)v2 + 2065);
    v14 = *((unsigned __int16 *)v2 + 2063);
    v13 = *((unsigned __int16 *)v2 + 2062);
    v7 = _Dect(&`string');
    sprintf(v2 + 28, v7, v13, v14, v15, v16, v17, v18, v19, v20);
    v8 = strlen(v2 + 28);
    if ( *((_DWORD *)v2 + 1036) )
    {
      if ( v8 > 0 )
      {
        v9 = v2 + 28;
        do
        {
          v10 = *((_DWORD *)v2 + 1036) + 2;
          *((_DWORD *)v2 + 1036) = v10;
          *v9++ ^= (_BYTE)v10 + 67;
        }
        while ( (int)&v9[-28 - (_DWORD)v2] < v8 );
      }
    }
    else if ( v8 > 0 )
    {
      v11 = v2 + 28;
      do
      {
        v12 = 3 * *((_DWORD *)v2 + 1035) + 1;
        *((_DWORD *)v2 + 1035) = v12;
        *v11++ ^= (_BYTE)v12 + 118;
      }
      while ( (int)&v11[-28 - (_DWORD)v2] < v8 );
    }
    if ( *((_DWORD *)v2 + 1037) != 999 )
      WriteFile(*(HANDLE *)v2, v2 + 28, v8, &NumberOfBytesWritten, 0);
    SetEndOfFile(*(HANDLE *)v2);
    CloseHandle(*(HANDLE *)v2);
    *(_DWORD *)v2 = -1;
  }
  DeleteCriticalSection((LPCRITICAL_SECTION)(v2 + 4));
  __writefsdword((unsigned int)&_except_list, v22[0]);
}

//----- (000008C0) --------------------------------------------------------
void __usercall _L63133(int a1@<ebp>)
{
  CLog::~CLog((CLog *)(*(_DWORD *)(a1 - 20) + 32));
}

//----- (00000988) --------------------------------------------------------
unsigned int __thiscall CGameGuard::InitNPGameMonI(CGameGuard *this)
{
  const char *v2; // eax
  const char *v4; // eax
  int v5; // [esp-4h] [ebp-8h]

  if ( *(_BYTE *)this )
  {
    v4 = _Dect1(&`string');
    CLog::Write((CGameGuard *)((char *)this + 32), v4);
  }
  else
  {
    v5 = *((_DWORD *)this + 4);
    v2 = _Dect1(&`string');
    CLog::Write((CGameGuard *)((char *)this + 32), v2, v5);
  }
  return *((_DWORD *)this + 4);
}

//----- (00000A0C) --------------------------------------------------------
DWORD __thiscall CGameGuard::PreInitNPGameMonI(CGameGuard *this, const char *Source)
{
  DWORD (__stdcall *v3)(); // esi
  const char *v4; // eax
  void (__stdcall *v6)(LPSTR, LPCSTR); // esi
  const CHAR *v7; // eax
  int v8; // eax
  HANDLE *v9; // ebp
  unsigned __int8 *v10; // eax
  char *v11; // edx
  HANDLE v12; // eax
  const char *v13; // eax
  signed int v14; // esi
  char *v15; // eax
  int v16; // edx
  __int16 v17; // di
  unsigned int v18; // ecx
  int *v19; // edi
  char *v20; // eax
  int v21; // ecx
  unsigned __int8 *v22; // esi
  DWORD v23; // eax
  const char *v24; // eax
  unsigned __int8 *v25; // eax
  char *v26; // edx
  HANDLE v27; // eax
  const char *v28; // eax
  signed int v29; // esi
  char *v30; // eax
  int v31; // edx
  __int16 v32; // di
  unsigned int v33; // ecx
  int *v34; // edi
  char *v35; // eax
  int v36; // ecx
  const char *v37; // eax
  const char *v38; // eax
  const char *v39; // eax
  const CHAR *v40; // eax
  HANDLE v41; // eax
  void *v42; // esi
  const char *v43; // eax
  DWORD v44; // eax
  HANDLE (__stdcall *v45)(LPSECURITY_ATTRIBUTES, BOOL, BOOL, LPCSTR); // esi
  HANDLE v46; // eax
  DWORD (__stdcall *v47)(); // esi
  const char *v48; // eax
  HANDLE v49; // eax
  DWORD (__stdcall *v50)(); // esi
  HANDLE v51; // eax
  DWORD (__stdcall *v52)(); // esi
  const char *v53; // eax
  const char *v54; // eax
  bool v55; // al
  void (__stdcall *v56)(); // esi
  int v57; // eax
  int v58; // edi
  const char *v59; // eax
  HANDLE v60; // eax
  void *v61; // edi
  const char *v62; // eax
  const char *v63; // eax
  const char *v64; // eax
  const char *v65; // eax
  const char *v66; // eax
  const char *v67; // eax
  int v68; // eax
  int v69; // edx
  const CHAR *v70; // eax
  CHAR *v71; // esi
  unsigned int v72; // kr24_4
  unsigned __int8 *v73; // edi
  int v74; // eax
  DWORD (__stdcall *v75)(); // esi
  const char *v76; // eax
  const char *v77; // eax
  void *v78; // edx
  const char *v79; // eax
  const char *v80; // eax
  void (__stdcall *v81)(HANDLE); // esi
  const char *v82; // eax
  int v83; // eax
  void (__stdcall *v84)(HANDLE); // esi
  DWORD (__stdcall *v85)(); // esi
  DWORD v86; // ebx
  const char *v87; // eax
  char *v88; // eax
  DWORD (__stdcall *v89)(); // esi
  int v90; // ebx
  const char *v91; // eax
  const char *v92; // esi
  const char *v93; // eax
  const char *v94; // eax
  const char *v95; // eax
  const char *v96; // eax
  const char *v97; // eax
  const char *v98; // eax
  const char *v99; // eax
  const char *v100; // eax
  const char *v101; // eax
  const char *v102; // eax
  const char *v103; // eax
  const char *v104; // eax
  const char *v105; // eax
  const char *v106; // eax
  const char *v107; // eax
  DWORD (__stdcall *v108)(); // esi
  int v109; // ebx
  const char *v110; // eax
  const char *v111; // eax
  const char *v112; // eax
  const char *v113; // eax
  DWORD v114; // esi
  void *v115; // ecx
  const CHAR *v116; // eax
  CHAR *v117; // esi
  unsigned int v118; // kr44_4
  unsigned __int8 *v119; // edi
  int v120; // eax
  const char *v121; // eax
  DWORD (__stdcall *v122)(); // esi
  const char *v123; // eax
  const char *v124; // eax
  const char *v125; // eax
  unsigned int v126; // eax
  DWORD (__stdcall *v127)(); // esi
  const char *v128; // eax
  const char *v129; // eax
  const CHAR *v130; // eax
  HANDLE v131; // eax
  const char *v132; // eax
  const char *v133; // eax
  const char *v134; // eax
  const CHAR *v135; // eax
  HANDLE v136; // eax
  const char *v137; // eax
  const char *v138; // eax
  int v139; // esi
  const char *v140; // eax
  int v141; // esi
  const char *v142; // eax
  const char *v143; // eax
  const char *v144; // eax
  const char *v145; // eax
  int v146; // [esp+8h] [ebp-110Ch]
  int v147; // [esp+Ch] [ebp-1108h]
  int v148; // [esp+Ch] [ebp-1108h]
  int v149; // [esp+Ch] [ebp-1108h]
  int v150; // [esp+10h] [ebp-1104h]
  int v151; // [esp+10h] [ebp-1104h]
  unsigned int v152; // [esp+10h] [ebp-1104h]
  void *v153; // [esp+10h] [ebp-1104h]
  int v154; // [esp+14h] [ebp-1100h]
  HANDLE v155; // [esp+14h] [ebp-1100h]
  int v156; // [esp+14h] [ebp-1100h]
  HANDLE v157; // [esp+14h] [ebp-1100h]
  int v158; // [esp+14h] [ebp-1100h]
  int v159; // [esp+14h] [ebp-1100h]
  void *v160; // [esp+14h] [ebp-1100h]
  int v161; // [esp+18h] [ebp-10FCh]
  int v162; // [esp+18h] [ebp-10FCh]
  int v163; // [esp+18h] [ebp-10FCh]
  const char *v164; // [esp+18h] [ebp-10FCh]
  int v165; // [esp+18h] [ebp-10FCh]
  int v166; // [esp+18h] [ebp-10FCh]
  int v167; // [esp+1Ch] [ebp-10F8h]
  int v168; // [esp+1Ch] [ebp-10F8h]
  int v169; // [esp+1Ch] [ebp-10F8h]
  int v170; // [esp+1Ch] [ebp-10F8h]
  int v171; // [esp+1Ch] [ebp-10F8h]
  int v172; // [esp+1Ch] [ebp-10F8h]
  int v173; // [esp+1Ch] [ebp-10F8h]
  int v174; // [esp+20h] [ebp-10F4h]
  int v175; // [esp+20h] [ebp-10F4h]
  DWORD v176; // [esp+20h] [ebp-10F4h]
  DWORD v177; // [esp+20h] [ebp-10F4h]
  int v178; // [esp+20h] [ebp-10F4h]
  DWORD v179; // [esp+20h] [ebp-10F4h]
  DWORD v180; // [esp+20h] [ebp-10F4h]
  int v181; // [esp+20h] [ebp-10F4h]
  int v182; // [esp+20h] [ebp-10F4h]
  DWORD v183; // [esp+20h] [ebp-10F4h]
  int v184; // [esp+20h] [ebp-10F4h]
  DWORD v185; // [esp+20h] [ebp-10F4h]
  DWORD v186; // [esp+24h] [ebp-10F0h]
  int v187; // [esp+24h] [ebp-10F0h]
  DWORD v188; // [esp+24h] [ebp-10F0h]
  int v189; // [esp+24h] [ebp-10F0h]
  DWORD v190; // [esp+24h] [ebp-10F0h]
  DWORD v191; // [esp+24h] [ebp-10F0h]
  DWORD v192; // [esp+24h] [ebp-10F0h]
  int v193; // [esp+24h] [ebp-10F0h]
  DWORD v194; // [esp+24h] [ebp-10F0h]
  DWORD v195; // [esp+24h] [ebp-10F0h]
  DWORD v196; // [esp+24h] [ebp-10F0h]
  DWORD v197; // [esp+24h] [ebp-10F0h]
  int v198; // [esp+24h] [ebp-10F0h]
  int v199; // [esp+24h] [ebp-10F0h]
  DWORD v200; // [esp+24h] [ebp-10F0h]
  DWORD v201; // [esp+24h] [ebp-10F0h]
  DWORD v202; // [esp+24h] [ebp-10F0h]
  unsigned int v203; // [esp+24h] [ebp-10F0h]
  DWORD v204; // [esp+24h] [ebp-10F0h]
  DWORD Buffer; // [esp+38h] [ebp-10DCh] BYREF
  char v206; // [esp+3Eh] [ebp-10D6h]
  char v207; // [esp+3Fh] [ebp-10D5h]
  unsigned int v208; // [esp+40h] [ebp-10D4h]
  DWORD NumberOfBytesWritten; // [esp+44h] [ebp-10D0h] BYREF
  struct _PROCESS_INFORMATION ProcessInformation; // [esp+48h] [ebp-10CCh] BYREF
  DWORD ExitCode; // [esp+58h] [ebp-10BCh] BYREF
  DWORD NumberOfBytesRead[2]; // [esp+5Ch] [ebp-10B8h] BYREF
  int v213; // [esp+64h] [ebp-10B0h]
  int v214; // [esp+68h] [ebp-10ACh]
  int v215; // [esp+6Ch] [ebp-10A8h]
  int v216; // [esp+70h] [ebp-10A4h]
  int v217; // [esp+74h] [ebp-10A0h]
  int v218; // [esp+78h] [ebp-109Ch]
  int v219; // [esp+7Ch] [ebp-1098h]
  int v220; // [esp+80h] [ebp-1094h]
  int v221; // [esp+84h] [ebp-1090h]
  int v222; // [esp+88h] [ebp-108Ch]
  struct _SECURITY_ATTRIBUTES EventAttributes; // [esp+8Ch] [ebp-1088h] BYREF
  HANDLE Handles[2]; // [esp+98h] [ebp-107Ch] BYREF
  struct _STARTUPINFOA StartupInfo; // [esp+A0h] [ebp-1074h] BYREF
  unsigned __int8 Str1[32]; // [esp+E4h] [ebp-1030h] BYREF
  char FileName[260]; // [esp+104h] [ebp-1010h] BYREF
  CHAR Filename[264]; // [esp+208h] [ebp-F0Ch] BYREF
  CHAR v229[256]; // [esp+310h] [ebp-E04h] BYREF
  CHAR v230[260]; // [esp+410h] [ebp-D04h] BYREF
  char v231[2048]; // [esp+514h] [ebp-C00h] BYREF
  CHAR CommandLine[1024]; // [esp+D14h] [ebp-400h] BYREF

  if ( *(_BYTE *)this )
    return 1877;
  *((_BYTE *)this + 4713) = CGameGuard::IsWinNT(this);
  *((_DWORD *)this + 1151) = GetCurrentProcessId();
  g_dwThreadId = GetCurrentThreadId();
  _mbsnbcpy((unsigned __int8 *)this + 4608, (const unsigned __int8 *)Source, 0x20u);
  *((_BYTE *)this + 4639) = 0;
  CGameGuard::GetGameGuardDirectory(this, &szLogFile, 0x104u);
  if ( _access(&szLogFile, 0) == -1 && !CreateDirectoryA(&szLogFile, 0) )
  {
    v3 = GetLastError;
    GetLastError();
    v186 = v3();
    v4 = _Dect1(&`string');
    CLog::Write((CGameGuard *)((char *)this + 32), v4, v186);
    return 111;
  }
  v6 = (void (__stdcall *)(LPSTR, LPCSTR))lstrcatA;
  lstrcatA(&szLogFile, "\\");
  v7 = _Dect1(&`string');
  v6(&szLogFile, v7);
  v8 = *((_DWORD *)this + 8);
  v9 = (HANDLE *)((char *)this + 32);
  v213 = -973999051;
  v214 = -2086428637;
  v215 = 1315073070;
  v216 = -1987999735;
  v217 = -890046406;
  v218 = -757852474;
  v219 = -1675784815;
  v220 = 1680229986;
  v221 = 961114488;
  v222 = 436867608;
  if ( v8 != -1 )
    goto LABEL_22;
  *((_DWORD *)this + 1044) = 0;
  *((_DWORD *)this + 1045) = 1000;
  if ( strlen(&szLogFile) <= 3
    || byte_D == 58
    || (GetModuleFileNameA(0, Filename, 0x104u),
        v10 = _mbsrchr((const unsigned __int8 *)Filename, 0x5Cu),
        v11 = (char *)(v10 + 1),
        !v10) )
  {
    v11 = Filename;
  }
  strcpy(v11, &szLogFile);
  v12 = CreateFileA(Filename, 0xC0000000, 1u, 0, 2u, 0x80000080, 0);
  *v9 = v12;
  if ( v12 == (HANDLE)-1 )
  {
LABEL_22:
    v22 = _mbsrchr((const unsigned __int8 *)&szLogFile, 0x2Eu);
    v208 = (unsigned int)v22;
    if ( v22 )
    {
      v23 = 1;
      v213 = -973999051;
      Buffer = 1;
      v214 = -2086428637;
      v215 = 1315073070;
      v216 = -1987999735;
      v217 = -890046406;
      v218 = -757852474;
      v219 = -1675784815;
      v220 = 1680229986;
      v221 = 961114488;
      v222 = 436867608;
      while ( 1 )
      {
        v188 = v23;
        v24 = _Dect1(&`string');
        sprintf((char *const)v22, v24, v188);
        if ( *v9 == (HANDLE)-1 )
        {
          *((_DWORD *)this + 1044) = 0;
          *((_DWORD *)this + 1045) = 1000;
          if ( strlen(&szLogFile) <= 3
            || byte_D == 58
            || (GetModuleFileNameA(0, Filename, 0x104u),
                v25 = _mbsrchr((const unsigned __int8 *)Filename, 0x5Cu),
                v26 = (char *)(v25 + 1),
                !v25) )
          {
            v26 = Filename;
          }
          strcpy(v26, &szLogFile);
          v27 = CreateFileA(Filename, 0xC0000000, 1u, 0, 2u, 0x80000080, 0);
          *v9 = v27;
          if ( v27 != (HANDLE)-1 )
            break;
        }
        v23 = ++Buffer;
        if ( (int)Buffer >= 10 )
          goto LABEL_43;
        v22 = (unsigned __int8 *)v208;
      }
      GetLocalTime((LPSYSTEMTIME)((char *)this + 4156));
      v189 = *((unsigned __int16 *)this + 2085);
      v175 = *((unsigned __int16 *)this + 2084);
      v168 = *((unsigned __int16 *)this + 2083);
      v162 = *((unsigned __int16 *)this + 2082);
      v156 = *((unsigned __int16 *)this + 2081);
      v151 = *((unsigned __int16 *)this + 2079);
      v148 = *((unsigned __int16 *)this + 2078);
      v28 = _Dect(&`string');
      sprintf((char *const)this + 60, v28, v148, v151, v156, v162, v168, v175, v189);
      v29 = strlen((const char *)this + 60);
      if ( *((_DWORD *)this + 1045) == 999 )
        v29 = 0;
      if ( *((_DWORD *)this + 1044) )
      {
        if ( v29 > 0 )
        {
          v30 = (char *)this + 60;
          do
          {
            v31 = *((_DWORD *)this + 1044) + 2;
            *((_DWORD *)this + 1044) = v31;
            *v30++ ^= v31 + 67;
          }
          while ( (int)&v30[-28 - (_DWORD)v9] < v29 );
        }
      }
      else
      {
        v32 = *((_WORD *)this + 2085);
        v33 = (unsigned __int16)((v32 * *((_WORD *)this + 2078) * *((_WORD *)this + 2079) * *((_WORD *)this + 2081) + 1)
                               * (*((_WORD *)this + 2084) + v32 + GetTickCount() + *((_WORD *)this + 2083)));
        v34 = (int *)((char *)this + 4172);
        v208 = (v33 | 0x2C000000ui64) % 0xA;
        v157 = *v9;
        *((_DWORD *)this + 1043) = v33 | 0x2C000000 | ((v208 ^ 0x55) << 16);
        WriteFile(v157, (char *)this + 4172, 4u, &NumberOfBytesWritten, 0);
        *((_DWORD *)this + 1043) = *(&v213 + v208);
        if ( v29 > 0 )
        {
          v35 = (char *)this + 60;
          do
          {
            v36 = 3 * *v34 + 1;
            *v34 = v36;
            *v35++ ^= v36 + 118;
          }
          while ( (int)&v35[-28 - (_DWORD)v9] < v29 );
        }
      }
      WriteFile(*v9, (char *)this + 60, v29, NumberOfBytesRead, 0);
    }
  }
  else
  {
    GetLocalTime((LPSYSTEMTIME)((char *)this + 4156));
    v187 = *((unsigned __int16 *)this + 2085);
    v174 = *((unsigned __int16 *)this + 2084);
    v167 = *((unsigned __int16 *)this + 2083);
    v161 = *((unsigned __int16 *)this + 2082);
    v154 = *((unsigned __int16 *)this + 2081);
    v150 = *((unsigned __int16 *)this + 2079);
    v147 = *((unsigned __int16 *)this + 2078);
    v13 = _Dect(&`string');
    sprintf((char *const)this + 60, v13, v147, v150, v154, v161, v167, v174, v187);
    v14 = strlen((const char *)this + 60);
    if ( *((_DWORD *)this + 1045) == 999 )
      v14 = 0;
    if ( *((_DWORD *)this + 1044) )
    {
      if ( v14 > 0 )
      {
        v15 = (char *)this + 60;
        do
        {
          v16 = *((_DWORD *)this + 1044) + 2;
          *((_DWORD *)this + 1044) = v16;
          *v15++ ^= v16 + 67;
        }
        while ( (int)&v15[-28 - (_DWORD)v9] < v14 );
      }
    }
    else
    {
      v17 = *((_WORD *)this + 2085);
      v18 = (unsigned __int16)((v17 * *((_WORD *)this + 2078) * *((_WORD *)this + 2079) * *((_WORD *)this + 2081) + 1)
                             * (*((_WORD *)this + 2084) + v17 + GetTickCount() + *((_WORD *)this + 2083)));
      v19 = (int *)((char *)this + 4172);
      v208 = (v18 | 0x2C000000ui64) % 0xA;
      v155 = *v9;
      *((_DWORD *)this + 1043) = v18 | 0x2C000000 | ((v208 ^ 0x55) << 16);
      WriteFile(v155, (char *)this + 4172, 4u, &NumberOfBytesWritten, 0);
      *((_DWORD *)this + 1043) = *(&v213 + v208);
      if ( v14 > 0 )
      {
        v20 = (char *)this + 60;
        do
        {
          v21 = 3 * *v19 + 1;
          *v19 = v21;
          *v20++ ^= v21 + 118;
        }
        while ( (int)&v20[-28 - (_DWORD)v9] < v14 );
      }
    }
    WriteFile(*v9, (char *)this + 60, v14, &Buffer, 0);
  }
LABEL_43:
  v37 = _Dect(&`string');
  CLog::Write((CGameGuard *)((char *)this + 32), v37, 47, "Wed May  3 14:08:04 2006");
  v169 = *((_DWORD *)this + 1151);
  v38 = _Dect1(&`string');
  CLog::Write((CGameGuard *)((char *)this + 32), v38, v169, Source, InitNPGameMon);
  GetProcessList((int)this);
  GetModuleList((int)this);
  if ( *((_BYTE *)this + 4732) )
    DisableCompatibleMode(1u);
  if ( !CGameGuard::CheckSingleInstance(this, 0x251Cu) )
  {
    v39 = _Dect1(&`string');
    CLog::Write((CGameGuard *)((char *)this + 32), v39);
    return 115;
  }
  if ( !CGameGuard::CheckGameMonSingleInstance(this, 0) )
  {
    v40 = _Dect1(&`string');
    v41 = OpenEventA(0x100002u, 0, v40);
    v42 = v41;
    if ( !v41 )
      return 110;
    if ( WaitForSingleObject(v41, 0) == 258 )
    {
      SetEvent(v42);
      CloseHandle(v42);
    }
    if ( !CGameGuard::CheckGameMonSingleInstance(this, 0x251Cu) )
      return 110;
    v43 = _Dect1(&`string');
    CLog::Write((CGameGuard *)((char *)this + 32), v43);
  }
  v44 = GetTickCount();
  v45 = CreateEventA;
  v208 = v44 & 0xFFF00000;
  EventAttributes.nLength = 12;
  EventAttributes.lpSecurityDescriptor = 0;
  EventAttributes.bInheritHandle = 1;
  v46 = CreateEventA(&EventAttributes, 0, 0, 0);
  *((_DWORD *)this + 1182) = v46;
  if ( !v46 )
  {
    v47 = GetLastError;
    GetLastError();
    v190 = v47();
    v48 = _Dect1(`string');
LABEL_61:
    CLog::Write((CGameGuard *)((char *)this + 32), v48, v190);
    return 171;
  }
  v49 = v45(&EventAttributes, 1, 0, 0);
  *((_DWORD *)this + 6) = v49;
  if ( !v49 )
  {
    v50 = GetLastError;
    GetLastError();
    v190 = v50();
    v48 = _Dect1(`string');
    goto LABEL_61;
  }
  v51 = v45(&EventAttributes, 0, 0, 0);
  *((_DWORD *)this + 1181) = v51;
  if ( !v51 )
  {
    v52 = GetLastError;
    GetLastError();
    v190 = v52();
    v48 = _Dect1(&`string');
    goto LABEL_61;
  }
  v53 = _Dect1(&`string');
  CLog::Write((CGameGuard *)((char *)this + 32), v53);
  CGameGuard::GetGameDirectory(this, FileName, 0x104u);
  strcat(FileName, "\\");
  strcat(FileName, _Dect1(&`string'));
  if ( _access(FileName, 0) == -1 )
  {
    v54 = _Dect1(&`string');
    CLog::Write((CGameGuard *)((char *)this + 32), v54, FileName);
    return 153;
  }
  v207 = 0;
  v55 = CFileAuthClient::Auth((CGameGuard *)((char *)this + 4532), FileName, 1);
  v56 = (void (__stdcall *)())GetLastError;
  if ( !v55 )
  {
    v57 = *((_DWORD *)this + 1150);
    v206 = 0;
    if ( v57 == 8 && GetLastError() == -2146893818 )
      v206 = 1;
    v56();
    v58 = *((_DWORD *)this + 1150);
    v176 = ((DWORD (__stdcall *)())v56)();
    v59 = _Dect1(&`string');
    CLog::Write((CGameGuard *)((char *)this + 32), v59, v58, v176, FileName);
    v60 = CreateFileA(FileName, 0x80000000, 3u, 0, 3u, 0x80u, 0);
    v61 = v60;
    if ( v60 == (HANDLE)-1 )
    {
      v177 = ((DWORD (__stdcall *)())v56)();
      v62 = _Dect1(&`string');
      CLog::Write((CGameGuard *)((char *)this + 32), v62, v177, FileName);
    }
    else
    {
      v191 = GetFileSize(v60, 0);
      v63 = _Dect1(&`string');
      CLog::Write((CGameGuard *)((char *)this + 32), v63, v191);
      SetFilePointer(v61, -4, 0, 2u);
      Buffer = 0;
      ReadFile(v61, &Buffer, 4u, NumberOfBytesRead, 0);
      v192 = Buffer;
      v64 = _Dect1(&`string');
      CLog::Write((CGameGuard *)((char *)this + 32), v64, v192);
      CloseHandle(v61);
    }
    if ( !v206 )
      goto LABEL_80;
    if ( *((_BYTE *)this + 4713) || !CheckRsaBase() )
      return 155;
    if ( !CFileAuthClient::Auth((CGameGuard *)((char *)this + 4532), FileName, 1) )
    {
      if ( *((_DWORD *)this + 1150) == 8 && ((DWORD (__stdcall *)())v56)() == -2146893818 )
        return 155;
      v207 = 1;
    }
    v65 = _Dect1(&`string');
    CLog::Write((CGameGuard *)((char *)this + 32), v65);
    if ( v207 )
    {
LABEL_80:
      v66 = _Dect1(&`string');
      CLog::Write((CGameGuard *)((char *)this + 32), v66);
      return 124;
    }
  }
  v67 = _Dect1(&`string');
  CLog::Write((CGameGuard *)((char *)this + 32), v67);
  memset(&StartupInfo, 0, sizeof(StartupInfo));
  v68 = *((_DWORD *)this + 1151);
  ProcessInformation.hProcess = 0;
  ProcessInformation.hThread = 0;
  StartupInfo.cb = 68;
  ProcessInformation.dwProcessId = 0;
  v193 = dwDE;
  v69 = *((_DWORD *)this + 1182);
  ProcessInformation.dwThreadId = 0;
  v178 = v68;
  v170 = *((_DWORD *)this + 6);
  v163 = v69;
  v152 = v208;
  v70 = _Dect1(&`string');
  _wsprintfA(v229, v70, v152, (char *)this + 4608, v163, v170, v178, v193);
  CLog::Write((CGameGuard *)((char *)this + 32), "cmd: %s", v229);
  Buffer = (DWORD)_Enct(v229);
  v71 = CommandLine;
  v72 = strlen(v229) + 1;
  CLog::Write((CGameGuard *)((char *)this + 32), "len: %d", v72 - 1);
  if ( (int)(v72 - 1 + 4) > 0 )
  {
    v73 = (unsigned __int8 *)Buffer;
    NumberOfBytesWritten = v72 - 1 + 4;
    do
    {
      v74 = *v73++;
      v71 += _wsprintfA(v71, "\\x%02x", v74);
      --NumberOfBytesWritten;
    }
    while ( NumberOfBytesWritten );
  }
  *v71 = 0;
  CLog::Write((CGameGuard *)((char *)this + 32), "enc: %s", CommandLine);
  if ( !CreateProcessA(FileName, CommandLine, 0, 0, 1, 0, 0, 0, &StartupInfo, &ProcessInformation) )
  {
    v75 = GetLastError;
    GetLastError();
    v179 = v75();
    v76 = _Dect1(&`string');
    CLog::Write((CGameGuard *)((char *)this + 32), v76, FileName, v179, v229);
    return 170;
  }
  v77 = _Dect1(&`string');
  CLog::Write((CGameGuard *)((char *)this + 32), v77);
  v78 = (void *)*((_DWORD *)this + 1182);
  ExitCode = 0;
  Handles[0] = v78;
  Handles[1] = ProcessInformation.hProcess;
  if ( !WaitForMultipleObjects(2u, Handles, 0, 0xFFFFFFFF) )
  {
    v82 = _Dect1(&`string');
    CLog::Write((CGameGuard *)((char *)this + 32), v82);
    v83 = ReadMemCrc(&ProcessInformation);
    v84 = (void (__stdcall *)(HANDLE))CloseHandle;
    v208 = v83;
    CloseHandle(ProcessInformation.hProcess);
    v84(ProcessInformation.hThread);
    CGameGuard::GetGameGuardDirectory(this, v230, 0x104u);
    strcat(v230, "\\");
    strcat(v230, (const char *)this + 4608);
    strcat(v230, _Dect1(&`string'));
    if ( !CFileAuthClient::Auth((CGameGuard *)((char *)this + 4532), v230, 1) )
    {
      v85 = GetLastError;
      GetLastError();
      v86 = *((_DWORD *)this + 1150);
      v196 = v85();
      v180 = v86;
      v87 = _Dect1(`string');
LABEL_108:
      CLog::Write((CLog *)v9, v87, v180, v196);
      return 120;
    }
    v88 = _Dect1(CONTAINER_NAME);
    if ( !CFileAuthClient::DecryptMem((CGameGuard *)((char *)this + 4532), v230, v231, 0x7FFu, v88 + 5) )
    {
      v89 = GetLastError;
      GetLastError();
      v90 = *((_DWORD *)this + 1150);
      v197 = v89();
      v91 = _Dect1(&`string');
      CLog::Write((CLog *)v9, v91, v90, v197);
      return 130;
    }
    v92 = _Dect(&`string');
    v164 = _Dect(&`string');
    v93 = _Dect1(&`string');
    MemGetPrivateProfileString(v92, v93, v164, (char *)Str1, 0x20u, v231);
    if ( _mbsicmp(Str1, (const unsigned __int8 *)this + 4608) )
    {
      v94 = _Dect1(&`string');
      CLog::Write((CGameGuard *)((char *)this + 32), v94);
      return 142;
    }
    v95 = _Dect1(&`string');
    nSendErlIni = MemGetPrivateProfileInt(v92, v95, 1, v231);
    v96 = _Dect1(&`string');
    g_dwWaitTime = MemGetPrivateProfileInt(v92, v96, 100000, v231);
    v97 = _Dect1(&`string');
    g_dwNoUpdate = MemGetPrivateProfileInt(v92, v97, 0, v231);
    v98 = _Dect1(&`string');
    NumberOfBytesWritten = MemGetPrivateProfileInt(v92, v98, 0, v231);
    v99 = _Dect1(&`string');
    Buffer = MemGetPrivateProfileInt(v92, v99, 0, v231);
    v100 = _Dect1(&`string');
    *((_BYTE *)this + 30) = (MemGetPrivateProfileInt(v92, v100, 0, v231) & 2) == 0;
    v101 = _Dect1(&`string');
    *((_DWORD *)this + 1179) = MemGetPrivateProfileInt(v92, v101, 1000, v231);
    v102 = _Dect1(&`string');
    *((_DWORD *)this + 1180) = MemGetPrivateProfileInt(v92, v102, 0, v231);
    memset(v231, 0, sizeof(v231));
    v103 = _Dect1(&`string');
    CLog::Write((CGameGuard *)((char *)this + 32), v103);
    CGameGuard::GetGameGuardDirectory(this, szGameMon, 0x104u);
    strcat(szGameMon, "\\");
    strcat(szGameMon, _Dect1(&`string'));
    if ( gg )
    {
      v198 = *((unsigned __int8 *)GetProcAddress + 4);
      v181 = *((unsigned __int8 *)GetProcAddress + 3);
      v171 = *((unsigned __int8 *)GetProcAddress + 2);
      v165 = *((unsigned __int8 *)GetProcAddress + 1);
      v158 = *(unsigned __int8 *)GetProcAddress;
      v104 = _Dect1(&`string');
      CLog::Write((CGameGuard *)((char *)gg + 32), v104, v158, v165, v171, v181, v198);
      if ( gg )
      {
        v199 = *((unsigned __int8 *)GetModuleHandleA + 4);
        v182 = *((unsigned __int8 *)GetModuleHandleA + 3);
        v172 = *((unsigned __int8 *)GetModuleHandleA + 2);
        v166 = *((unsigned __int8 *)GetModuleHandleA + 1);
        v159 = *(unsigned __int8 *)GetModuleHandleA;
        v105 = _Dect1(&`string');
        CLog::Write((CGameGuard *)((char *)gg + 32), v105, v159, v166, v172, v182, v199);
      }
    }
    v106 = _Dect1(&`string');
    CLog::Write((CGameGuard *)((char *)this + 32), v106);
    if ( _access(szGameMon, 0) == -1 )
    {
      CGameGuard::GetGameGuardDirectory(this, szGameMon, 0x104u);
      strcat(szGameMon, "\\");
      strcat(szGameMon, _Dect1(&`string'));
      if ( _access(szGameMon, 0) == -1 )
      {
        v107 = _Dect1(&`string');
        CLog::Write((CGameGuard *)((char *)this + 32), v107, szGameMon);
        return 154;
      }
    }
    if ( !CFileAuthClient::Auth((CGameGuard *)((char *)this + 4532), szGameMon, 1) )
    {
      v108 = GetLastError;
      GetLastError();
      v109 = *((_DWORD *)this + 1150);
      v183 = v108();
      v110 = _Dect1(&`string');
      CLog::Write((CLog *)v9, v110, v109, v183, szGameMon);
      return 122;
    }
    v111 = _Dect1(&`string');
    CLog::Write((CGameGuard *)((char *)this + 32), v111);
    if ( !CCommPipe::InitCommPipe((CGameGuard *)((char *)this + 4188)) )
    {
      v112 = _Dect1(&`string');
      CLog::Write((CGameGuard *)((char *)this + 32), v112);
      return 160;
    }
    v113 = _Dect1(&`string');
    CLog::Write((CGameGuard *)((char *)this + 32), v113);
    v114 = GetTickCount() & 0xFFF00000;
    if ( NumberOfBytesWritten < 0x2F )
    {
      v196 = 47;
      v180 = NumberOfBytesWritten;
      v87 = _Dect1(&`string');
      goto LABEL_108;
    }
    memset(&StartupInfo, 0, sizeof(StartupInfo));
    v115 = (void *)*((_DWORD *)this + 1182);
    ProcessInformation.hProcess = 0;
    ProcessInformation.hThread = 0;
    ProcessInformation.dwProcessId = 0;
    StartupInfo.cb = 68;
    ProcessInformation.dwThreadId = 0;
    ResetEvent(v115);
    v200 = Buffer;
    v184 = *((_DWORD *)this + 1182);
    v173 = *((_DWORD *)this + 1181);
    v160 = CCommPipe::GetChildWriteHandle((CGameGuard *)((char *)this + 4188));
    v153 = CCommPipe::GetChildReadHandle((CGameGuard *)((char *)this + 4188));
    v149 = *((unsigned __int8 *)this + 4713);
    v146 = *((_DWORD *)this + 1151);
    v116 = _Dect1(&`string');
    _wsprintfA(v229, v116, v114, v146, v149, v153, v160, (char *)this + 4608, v173, v184, v200);
    Buffer = (DWORD)_Enct(v229);
    v117 = CommandLine;
    v118 = strlen(v229) + 1;
    if ( (int)(v118 - 1 + 4) > 0 )
    {
      v119 = (unsigned __int8 *)Buffer;
      NumberOfBytesWritten = v118 - 1 + 4;
      do
      {
        v120 = *v119++;
        v117 += _wsprintfA(v117, "\\x%02x", v120);
        --NumberOfBytesWritten;
      }
      while ( NumberOfBytesWritten );
    }
    *v117 = 0;
    v121 = _Dect1(&`string');
    CLog::Write((CGameGuard *)((char *)this + 32), v121);
    if ( !dwDE && !dwRE )
    {
      if ( !CreateProcessA(szGameMon, CommandLine, 0, 0, 0, 4u, 0, 0, &StartupInfo, &ProcessInformation) )
      {
        v122 = GetLastError;
        GetLastError();
        v185 = v122();
        v123 = _Dect1(&`string');
        CLog::Write((CGameGuard *)((char *)this + 32), v123, szGameMon, v185, v229);
        return 170;
      }
      v201 = ProcessInformation.dwProcessId;
      v124 = _Dect1(&`string');
      CLog::Write((CGameGuard *)((char *)this + 32), v124, v201);
    }
    bCheckGameMon = g_dwNoUpdate;
    if ( !g_dwNoUpdate )
    {
      LOBYTE(bCheckGameMon) = CheckGameMonCrc(szGameMon, &`string', v208);
      bCheckGameMon = (unsigned __int8)bCheckGameMon;
    }
    v125 = _Dect1(&`string');
    CLog::Write((CGameGuard *)((char *)this + 32), v125);
    v126 = CCommPipe::RunCommPipe((CGameGuard *)((char *)this + 4188));
    if ( !v126 )
    {
      v127 = GetLastError;
      GetLastError();
      v202 = v127();
      v128 = _Dect1(&`string');
      CLog::Write((CGameGuard *)((char *)this + 32), v128, v202);
      return 160;
    }
    v203 = v126;
    v129 = _Dect1(&`string');
    CLog::Write((CGameGuard *)((char *)this + 32), v129, v203);
    if ( dwDE )
    {
      if ( WaitForSingleObject(*((HANDLE *)this + 1181), g_dwWaitTime) )
        goto LABEL_127;
    }
    else
    {
      ResumeThread(ProcessInformation.hThread);
      NumberOfBytesRead[0] = *((_DWORD *)this + 1181);
      NumberOfBytesRead[1] = (DWORD)ProcessInformation.hProcess;
      if ( WaitForMultipleObjects(2u, (const HANDLE *)NumberOfBytesRead, 0, g_dwWaitTime) )
      {
        v130 = _Dect1(&`string');
        v131 = OpenEventA(0x100000u, 0, v130);
        if ( v131 )
        {
          CloseHandle(v131);
          if ( WaitForSingleObject(*((HANDLE *)this + 1181), g_dwWaitTime) )
          {
            v204 = g_dwWaitTime;
            v132 = _Dect1(`string');
LABEL_128:
            CLog::Write((CGameGuard *)((char *)this + 32), v132, v204);
            return 114;
          }
          goto LABEL_129;
        }
LABEL_127:
        v204 = g_dwWaitTime;
        v132 = _Dect1(&`string');
        goto LABEL_128;
      }
    }
LABEL_129:
    v133 = _Dect1(&`string');
    CLog::Write((CGameGuard *)((char *)this + 32), v133);
    if ( WaitForSingleObject(*((HANDLE *)this + 1182), 0) )
    {
      v134 = _Dect1(&`string');
      CLog::Write((CGameGuard *)((char *)this + 32), v134);
      return 114;
    }
    v135 = _Dect1(&`string');
    v136 = OpenEventA(0x100000u, 0, v135);
    if ( v136 )
    {
      CloseHandle(v136);
      v137 = _Dect1(&`string');
      CLog::Write((CGameGuard *)((char *)this + 32), v137);
    }
    else
    {
      dwGameMonPID = ProcessInformation.dwProcessId;
      hGameMonHandle = ProcessInformation.hProcess;
    }
    v138 = _Dect1(&`string');
    CLog::Write((CGameGuard *)((char *)this + 32), v138);
    if ( !bCheckGameMon )
      return 122;
    CheckEncryptedClient();
    v139 = InitTimeAddr();
    if ( !v139 )
      CommPipeCallback((int)this, (CGameGuard *)((char *)this + 4188), 0x62Du, 0xBu);
    v140 = _Dect1(&`string');
    CLog::Write((CGameGuard *)((char *)this + 32), v140, v139);
    v141 = InitSocketAddr((int)this);
    if ( !v141 )
      CCommPipe::SendCommPipe((CGameGuard *)((char *)this + 4188), 0x8B1u, 0x630u, 0xDu);
    v142 = _Dect1(&`string');
    CLog::Write((CGameGuard *)((char *)this + 32), v142, v141);
    if ( *((_BYTE *)this + 30) && !CGameGuard::InitNPSC(this) )
    {
      v143 = _Dect1(&`string');
      CLog::Write((CGameGuard *)((char *)this + 32), v143);
      return 220;
    }
    v144 = _Dect1(&`string');
    CLog::Write((CGameGuard *)((char *)this + 32), v144);
    CCommPipe::SendCommPipe((CGameGuard *)((char *)this + 4188), 0x8B1u, 0x611u, *((_DWORD *)this + 1151));
    CCommPipe::SendCommPipe((CGameGuard *)((char *)this + 4188), 0x8B1u, 0x617u, v208);
    v145 = _Dect1(&`string');
    CLog::Write((CGameGuard *)((char *)this + 32), v145);
    *(_BYTE *)this = 1;
    return 1877;
  }
  if ( !GetExitCodeProcess(ProcessInformation.hProcess, &ExitCode) )
  {
    v194 = GetLastError();
    v79 = _Dect1(&`string');
    CLog::Write((CGameGuard *)((char *)this + 32), v79, v194);
  }
  v195 = ExitCode;
  v80 = _Dect1(&`string');
  CLog::Write((CGameGuard *)((char *)this + 32), v80, v195);
  v81 = (void (__stdcall *)(HANDLE))CloseHandle;
  CloseHandle(ProcessInformation.hProcess);
  v81(ProcessInformation.hThread);
  return ExitCode;
}
// D: using guessed type char byte_D;
// 334: using guessed type int g_dwThreadId;
// 33C: using guessed type int g_dwNoUpdate;
// 34C: using guessed type int bCheckGameMon;
// 350: using guessed type int dwDE;
// 354: using guessed type int dwRE;
// 358: using guessed type unsigned int dwGameMonPID;
// 3A0: using guessed type int nSendErlIni;

//----- (000029C4) --------------------------------------------------------
void __thiscall CCriticalSector::~CCriticalSector(LPCRITICAL_SECTION lpCriticalSection)
{
  DeleteCriticalSection(lpCriticalSection);
}

//----- (000029D4) --------------------------------------------------------
void __thiscall CLog::~CLog(CLog *this)
{
  HANDLE v2; // eax
  unsigned __int16 *v3; // edi
  unsigned int v4; // eax
  bool v5; // cc
  void *v6; // eax
  const char *v7; // eax
  signed int v8; // ecx
  char *v9; // eax
  int v10; // ebx
  char *v11; // eax
  int v12; // edx
  int v13; // [esp-30h] [ebp-44h]
  int v14; // [esp-2Ch] [ebp-40h]
  int v15; // [esp-28h] [ebp-3Ch]
  int v16; // [esp-24h] [ebp-38h]
  int v17; // [esp-20h] [ebp-34h]
  int v18; // [esp-1Ch] [ebp-30h]
  int v19; // [esp-18h] [ebp-2Ch]
  void *v20; // [esp-14h] [ebp-28h]
  DWORD NumberOfBytesWritten; // [esp+4h] [ebp-10h] BYREF
  unsigned int v22[2]; // [esp+8h] [ebp-Ch] BYREF
  int v23; // [esp+10h] [ebp-4h]

  v23 = -1;
  v22[1] = (unsigned int)&_L63393;
  v22[0] = __readfsdword((unsigned int)&_except_list);
  __writefsdword((unsigned int)&_except_list, (unsigned int)v22);
  v2 = *(HANDLE *)this;
  v23 = 0;
  if ( v2 != (HANDLE)-1 )
  {
    v3 = (unsigned __int16 *)((char *)this + 4124);
    GetLocalTime((LPSYSTEMTIME)((char *)this + 4124));
    v4 = *((_DWORD *)this + 1037);
    if ( !v4 || (v5 = *((_DWORD *)this + 1038) <= v4, v6 = &`string', v5) )
      v6 = &`string';
    v20 = v6;
    v19 = *((unsigned __int16 *)this + 2069);
    v18 = *((unsigned __int16 *)this + 2068);
    v17 = *((unsigned __int16 *)this + 2067);
    v16 = *((unsigned __int16 *)this + 2066);
    v15 = *((unsigned __int16 *)this + 2065);
    v14 = *((unsigned __int16 *)this + 2063);
    v13 = *v3;
    v7 = _Dect(&`string');
    sprintf((char *const)this + 28, v7, v13, v14, v15, v16, v17, v18, v19, v20);
    v8 = strlen((const char *)this + 28);
    if ( *((_DWORD *)this + 1036) )
    {
      if ( v8 > 0 )
      {
        v9 = (char *)this + 28;
        do
        {
          v10 = *((_DWORD *)this + 1036) + 2;
          *((_DWORD *)this + 1036) = v10;
          *v9++ ^= v10 + 67;
        }
        while ( (int)&v9[-28 - (_DWORD)this] < v8 );
      }
    }
    else if ( v8 > 0 )
    {
      v11 = (char *)this + 28;
      do
      {
        v12 = 3 * *((_DWORD *)this + 1035) + 1;
        *((_DWORD *)this + 1035) = v12;
        *v11++ ^= v12 + 118;
      }
      while ( (int)&v11[-28 - (_DWORD)this] < v8 );
    }
    if ( *((_DWORD *)this + 1037) != 999 )
      WriteFile(*(HANDLE *)this, (char *)this + 28, v8, &NumberOfBytesWritten, 0);
    SetEndOfFile(*(HANDLE *)this);
    CloseHandle(*(HANDLE *)this);
    *(_DWORD *)this = -1;
  }
  DeleteCriticalSection((LPCRITICAL_SECTION)((char *)this + 4));
  __writefsdword((unsigned int)&_except_list, v22[0]);
}

//----- (00002B64) --------------------------------------------------------
void __usercall _L63362(int a1@<ebp>)
{
  CCriticalSector::~CCriticalSector((LPCRITICAL_SECTION)(*(_DWORD *)(a1 - 20) + 4));
}

//----- (00002BA4) --------------------------------------------------------
char CLog::Write(CLog *this, const char *Format, ...)
{
  unsigned int v2; // eax
  unsigned int v3; // ecx
  struct _RTL_CRITICAL_SECTION *v4; // ebx
  const char *v5; // eax
  signed int v6; // ecx
  char *v7; // eax
  int v8; // ebx
  char *v9; // eax
  int v10; // edx
  int v12; // [esp-1Ch] [ebp-102Ch]
  int v13; // [esp-18h] [ebp-1028h]
  int v14; // [esp-14h] [ebp-1024h]
  int v15; // [esp-10h] [ebp-1020h]
  DWORD NumberOfBytesWritten; // [esp+Ch] [ebp-1004h] BYREF
  char Buffer[4096]; // [esp+10h] [ebp-1000h] BYREF
  va_list ArgList; // [esp+101Ch] [ebp+Ch] BYREF

  va_start(ArgList, Format);
  if ( *(_DWORD *)this == -1 )
    return 0;
  v2 = *((_DWORD *)this + 1037);
  if ( v2 && *Format != 33 )
  {
    v3 = *((_DWORD *)this + 1038);
    if ( v3 > v2 )
      return 0;
    *((_DWORD *)this + 1038) = v3 + 1;
  }
  v4 = (struct _RTL_CRITICAL_SECTION *)((char *)this + 4);
  EnterCriticalSection((LPCRITICAL_SECTION)((char *)this + 4));
  vsprintf(Buffer, Format, ArgList);
  GetLocalTime((LPSYSTEMTIME)((char *)this + 4124));
  if ( (_BYTE)sprintf == 0xCC || *(_BYTE *)WriteFile == 0xCC )
  {
    LeaveCriticalSection((LPCRITICAL_SECTION)((char *)this + 4));
    return 0;
  }
  v15 = *((unsigned __int16 *)this + 2069);
  v14 = *((unsigned __int16 *)this + 2068);
  v13 = *((unsigned __int16 *)this + 2067);
  v12 = *((unsigned __int16 *)this + 2066);
  v5 = _Dect(&`string');
  sprintf((char *const)this + 28, v5, v12, v13, v14, v15, Buffer);
  v6 = strlen((const char *)this + 28);
  if ( *((_DWORD *)this + 1036) )
  {
    if ( v6 > 0 )
    {
      v7 = (char *)this + 28;
      do
      {
        v8 = *((_DWORD *)this + 1036) + 2;
        *((_DWORD *)this + 1036) = v8;
        *v7++ ^= v8 + 67;
      }
      while ( (int)&v7[-28 - (_DWORD)this] < v6 );
      v4 = (struct _RTL_CRITICAL_SECTION *)((char *)this + 4);
    }
  }
  else if ( v6 > 0 )
  {
    v9 = (char *)this + 28;
    do
    {
      v10 = 3 * *((_DWORD *)this + 1035) + 1;
      *((_DWORD *)this + 1035) = v10;
      *v9++ ^= v10 + 118;
    }
    while ( (int)&v9[-28 - (_DWORD)this] < v6 );
  }
  WriteFile(*(HANDLE *)this, (char *)this + 28, v6, &NumberOfBytesWritten, 0);
  LeaveCriticalSection(v4);
  return 1;
}

//----- (00002D54) --------------------------------------------------------
void __userpurge CGameGuard::SetHwndToGameMonI(CGameGuard *this@<ecx>, int a2@<ebx>, HWND a3)
{
  CLog *v4; // edi
  const char *v5; // eax
  const char *v6; // eax
  const char *v7; // eax
  const char *v8; // eax
  int v9; // [esp-8h] [ebp-10h]
  int v10; // [esp-4h] [ebp-Ch]

  v4 = (CGameGuard *)((char *)this + 32);
  v5 = _Dect1(&`string');
  CLog::Write(v4, v5);
  GetProcessList(a2);
  GetModuleList(a2);
  *((_DWORD *)this + 1) = a3;
  CCommPipe::SendCommPipe((CGameGuard *)((char *)this + 4188), 0x8B1u, 0x612u, (unsigned int)a3);
  if ( *((_DWORD *)this + 2) )
  {
    v10 = *((_DWORD *)this + 3);
    v9 = *((_DWORD *)this + 2);
    v6 = _Dect1(&`string');
    CLog::Write(v4, v6, v9, v10);
    if ( !NPGameMonCallback(*((_DWORD *)this + 2), *((_DWORD *)this + 3)) )
    {
      v7 = _Dect1(&`string');
      CLog::Write(v4, v7);
    }
  }
  v8 = _Dect1(&`string');
  CLog::Write(v4, v8);
}

//----- (00002E78) --------------------------------------------------------
char __thiscall CGameGuard::IsWinNT(CGameGuard *this)
{
  const CHAR *v2; // eax
  HMODULE v3; // esi
  const CHAR *v4; // eax
  FARPROC (__stdcall *v5)(HMODULE, LPCSTR); // edi
  const CHAR *v6; // eax
  DWORD v7; // eax
  struct _OSVERSIONINFOA VersionInformation; // [esp+Ch] [ebp-94h] BYREF

  VersionInformation.dwOSVersionInfoSize = 148;
  GetVersionExA(&VersionInformation);
  v2 = _Dect1(&`string');
  v3 = GetModuleHandleA(v2);
  v4 = _Dect1(&`string');
  v5 = GetProcAddress;
  if ( GetProcAddress(v3, v4) && (v6 = _Dect1(&`string'), v5(v3, v6)) )
  {
    v7 = VersionInformation.dwMajorVersion;
    if ( VersionInformation.dwMajorVersion < 5
      || VersionInformation.dwMajorVersion == 5 && !VersionInformation.dwMinorVersion )
    {
      *((_BYTE *)this + 4732) = 1;
      return 1;
    }
  }
  else
  {
    v7 = VersionInformation.dwMajorVersion;
  }
  if ( VersionInformation.dwPlatformId != 2 )
    return 0;
  bIsWin2K = 1;
  if ( v7 == 5 && !VersionInformation.dwMinorVersion )
    g_dwLoseAllowFactor *= 2;
  return 1;
}
// 362: using guessed type char bIsWin2K;
// 3A4: using guessed type int g_dwLoseAllowFactor;

//----- (00002F88) --------------------------------------------------------
char __thiscall CGameGuard::GetGameGuardDirectory(CGameGuard *this, LPSTR lpFilename, unsigned int a3)
{
  CGameGuard::GetGameDirectory(this, lpFilename, a3);
  strcat(lpFilename, _Dect1(&`string'));
  return 1;
}

//----- (00002FE8) --------------------------------------------------------
char __thiscall CGameGuard::GetGameDirectory(CGameGuard *this, LPSTR lpFilename, unsigned int nSize)
{
  char result; // al
  unsigned __int8 *v4; // eax
  unsigned int v5; // eax
  CHAR *v6; // edi
  unsigned __int8 *v7; // esi
  char v8; // cl

  if ( GetModuleFileNameA(0, lpFilename, nSize) )
  {
    v4 = _mbsrchr((const unsigned __int8 *)lpFilename, 0x5Cu);
    if ( v4 )
    {
      *v4 = 0;
      result = 1;
    }
    else
    {
      v5 = strlen((const char *)&`string') + 1;
      qmemcpy(lpFilename, &`string', 4 * (v5 >> 2));
      v7 = &`string' + 4 * (v5 >> 2);
      v6 = &lpFilename[4 * (v5 >> 2)];
      v8 = v5;
      result = 1;
      qmemcpy(v6, v7, v8 & 3);
    }
  }
  else
  {
    strcpy(lpFilename, (const char *)&`string');
    result = 0;
  }
  return result;
}

//----- (0000307C) --------------------------------------------------------
unsigned int __thiscall CGameGuard::CheckNPGameMonI(CGameGuard *this)
{
  unsigned int result; // eax
  const char *v3; // eax
  const char *v4; // eax
  const char *v5; // eax
  const CHAR *v6; // eax
  HANDLE (__stdcall *v7)(DWORD, BOOL, LPCSTR); // esi
  HANDLE v8; // eax
  const CHAR *v9; // eax
  void (__stdcall *v10)(HANDLE); // edi
  const CHAR *v11; // eax
  HANDLE v12; // eax
  const CHAR *v13; // eax
  const char *v14; // eax
  const char *v15; // eax
  DWORD v16; // [esp-4h] [ebp-14h]
  DWORD v17; // [esp-4h] [ebp-14h]
  DWORD ExitCode; // [esp+Ch] [ebp-4h] BYREF

  ++_dwCount__1__CheckNPGameMonI_CGameGuard__QAEKXZ_4KA;
  if ( *((_BYTE *)this + 1) )
    return 1877;
  if ( *(_BYTE *)this )
  {
    if ( bCheckGameMon )
    {
      if ( hGameMonHandle && (ExitCode = 0, GetExitCodeProcess(hGameMonHandle, &ExitCode)) && ExitCode != 259 )
      {
        v5 = _Dect1(&`string');
        CLog::Write((CGameGuard *)((char *)this + 32), v5);
        result = 620;
      }
      else
      {
        v6 = _Dect1(&`string');
        v7 = OpenMutexA;
        v8 = OpenMutexA(0x100000u, 0, v6);
        if ( v8 || (v9 = _Dect1(&`string'), (v8 = v7(0x100000u, 0, v9)) != 0) )
        {
          v10 = (void (__stdcall *)(HANDLE))CloseHandle;
          CloseHandle(v8);
          v11 = _Dect1(&`string');
          v12 = v7(0x100000u, 0, v11);
          if ( v12 || (v13 = _Dect1(&`string'), (v12 = v7(0x100000u, 0, v13)) != 0) )
          {
            v10(v12);
            result = 1877;
          }
          else
          {
            v16 = GetLastError();
            v14 = _Dect1(&`string');
            CLog::Write((CGameGuard *)((char *)this + 32), v14, v16);
            result = 630;
          }
        }
        else
        {
          v17 = GetLastError();
          v15 = _Dect1(&`string');
          CLog::Write((CGameGuard *)((char *)this + 32), v15, v17);
          result = 660;
        }
      }
    }
    else
    {
      v4 = _Dect1(&`string');
      CLog::Write((CGameGuard *)((char *)this + 32), v4);
      result = 650;
    }
  }
  else if ( (unsigned int)_dwCount__1__CheckNPGameMonI_CGameGuard__QAEKXZ_4KA >= 3 )
  {
    v3 = _Dect1(&`string');
    CLog::Write((CGameGuard *)((char *)this + 32), v3);
    result = 610;
  }
  else
  {
    result = 1877;
  }
  return result;
}
// 34C: using guessed type int bCheckGameMon;
// 368: using guessed type int _dwCount__1__CheckNPGameMonI_CGameGuard__QAEKXZ_4KA;

//----- (00003318) --------------------------------------------------------
bool __thiscall CGameGuard::SendCSAuthToGameMonI(CGameGuard *this, unsigned int a2)
{
  const char *v3; // eax

  if ( !*(_BYTE *)this )
    return 0;
  v3 = _Dect1(&`string');
  CLog::Write((CGameGuard *)((char *)this + 32), v3, a2);
  return CCommPipe::SendCommPipe((CGameGuard *)((char *)this + 4188), 0x8B1u, 0x616u, a2);
}

//----- (00003378) --------------------------------------------------------
bool __thiscall CGameGuard::SendUserIDToGameMonI(CGameGuard *this, const char *a2)
{
  if ( !*(_BYTE *)this )
    return 0;
  strcpy((char *)this + 4648, a2);
  return CCommPipe::SendCommPipe((CGameGuard *)((char *)this + 4188), 0x8B1u, 0x613u, (unsigned int)a2);
}

//----- (000033D8) --------------------------------------------------------
const char *__thiscall CGameGuard::GetInfoFromGameMonI(CGameGuard *this)
{
  const char *result; // eax

  if ( *(_BYTE *)this )
    result = CCommPipe::GetUserInfo((CGameGuard *)((char *)this + 4188));
  else
    result = 0;
  return result;
}

//----- (000033F8) --------------------------------------------------------
bool __thiscall CGameGuard::SendCSAuth2ToGameMonI(CGameGuard *this, struct _GG_AUTH_DATA *a2)
{
  bool result; // al

  if ( *(_BYTE *)this )
    result = CCommPipe::SendCommPipe((CGameGuard *)((char *)this + 4188), 0x8B1u, 0x619u, (unsigned int)a2);
  else
    result = 0;
  return result;
}

//----- (00003428) --------------------------------------------------------
bool __thiscall CGameGuard::CloseNPGameMonI(CGameGuard *this)
{
  const char *v3; // eax
  char v4; // al
  void *v5; // eax
  void (__stdcall *v6)(HANDLE); // edi
  const char *v7; // eax

  if ( *((_BYTE *)this + 1) )
    return 1;
  v3 = _Dect1(&`string');
  CLog::Write((CGameGuard *)((char *)this + 32), v3);
  v4 = *((_BYTE *)this + 28);
  *((_BYTE *)this + 1) = 1;
  if ( v4 )
  {
    CGameGuard::CloseNPSC(this);
    *((_BYTE *)this + 28) = 0;
  }
  v5 = (void *)*((_DWORD *)this + 1181);
  v6 = (void (__stdcall *)(HANDLE))CloseHandle;
  if ( v5 )
  {
    CloseHandle(v5);
    *((_DWORD *)this + 1181) = 0;
  }
  if ( *((_DWORD *)this + 6) )
  {
    v6(*((HANDLE *)this + 6));
    *((_DWORD *)this + 6) = 0;
  }
  if ( *((_DWORD *)this + 1182) )
  {
    v6(*((HANDLE *)this + 1182));
    *((_DWORD *)this + 1182) = 0;
  }
  if ( *((_BYTE *)this + 4732) )
  {
    DisableCompatibleMode(0);
    RemoveCompatibleMode();
  }
  if ( nSendErlIni )
  {
    if ( nSendErl )
      CGameGuard::FtpSendErl(this);
  }
  v7 = _Dect1(&`string');
  CLog::Write((CGameGuard *)((char *)this + 32), v7);
  *(_BYTE *)this = 0;
  return CCommPipe::CloseCommPipe((CGameGuard *)((char *)this + 4188));
}
// 32C: using guessed type int nSendErl;
// 3A0: using guessed type int nSendErlIni;

//----- (0000353C) --------------------------------------------------------
char __thiscall CGameGuard::InitNPSC(CGameGuard *this)
{
  CLog *v3; // ebp
  const char *v4; // eax
  const char *v5; // eax
  DWORD (__stdcall *v6)(); // esi
  int v7; // ebx
  const char *v8; // eax
  HMODULE v9; // eax
  const char *v10; // eax
  const char *v11; // eax
  int v12; // ecx
  HANDLE v13; // eax
  HANDLE v14; // eax
  const char *v15; // eax
  int v16; // eax
  const char *v17; // eax
  DWORD v18; // [esp-4h] [ebp-118h]
  DWORD v19; // [esp-4h] [ebp-118h]
  DWORD v20; // [esp-4h] [ebp-118h]
  DWORD ThreadId; // [esp+Ch] [ebp-108h] BYREF
  CHAR LibFileName[260]; // [esp+10h] [ebp-104h] BYREF

  if ( *((_BYTE *)this + 28) )
    return 1;
  v3 = (CGameGuard *)((char *)this + 32);
  v4 = _Dect1(&`string');
  CLog::Write((CGameGuard *)((char *)this + 32), v4);
  CGameGuard::GetGameGuardDirectory(this, LibFileName, 0x104u);
  strcat(LibFileName, "\\");
  strcat(LibFileName, _Dect1(&`string'));
  v5 = _Dect1(&`string');
  CLog::Write((CGameGuard *)((char *)this + 32), v5, LibFileName);
  if ( !CFileAuthClient::Auth((CGameGuard *)((char *)this + 4532), LibFileName, 1) )
  {
    v6 = GetLastError;
    GetLastError();
    v7 = *((_DWORD *)this + 1150);
    v18 = v6();
    v8 = _Dect1(&`string');
    CLog::Write(v3, v8, v7, v18);
    return 0;
  }
  v9 = LoadLibraryA(LibFileName);
  *((_DWORD *)this + 1160) = v9;
  if ( v9 )
  {
    *((_DWORD *)this + 1184) = MyGetProcAddress((int)this, v9, 2);
    v11 = MyGetProcAddress((int)this, *((void **)this + 1160), 1);
    v12 = *((_DWORD *)this + 1184);
    *((_DWORD *)this + 1185) = v11;
    if ( v12 && v11 )
    {
      v13 = CreateEventA(0, 0, 0, 0);
      *((_DWORD *)this + 5) = v13;
      if ( v13 )
      {
        *((_BYTE *)this + 28) = 1;
        v14 = CreateThread(0, 0, (LPTHREAD_START_ROUTINE)SpeedCheckEventThread, this, 0, &ThreadId);
        *((_DWORD *)this + 1161) = v14;
        if ( v14 )
        {
          v20 = ThreadId;
          v15 = _Dect1(&`string');
          CLog::Write((CGameGuard *)((char *)this + 32), v15, v20);
          v16 = (*((int (__cdecl **)(_DWORD, _DWORD, _DWORD, _DWORD))this + 1184))(
                  *((_DWORD *)this + 1151),
                  *((_DWORD *)this + 1180),
                  *((_DWORD *)this + 1179),
                  *((_DWORD *)this + 5));
          if ( v16 == 107 )
          {
            v17 = _Dect1(&`string');
            CLog::Write((CGameGuard *)((char *)this + 32), v17);
            return 1;
          }
          v19 = v16;
          v10 = _Dect1(`string');
        }
        else
        {
          v19 = GetLastError();
          v10 = _Dect1(`string');
        }
      }
      else
      {
        v19 = GetLastError();
        v10 = _Dect1(`string');
      }
    }
    else
    {
      v19 = GetLastError();
      v10 = _Dect1(&`string');
    }
  }
  else
  {
    v19 = GetLastError();
    v10 = _Dect1(`string');
  }
  CLog::Write((CGameGuard *)((char *)this + 32), v10, v19);
  return 0;
}

//----- (000038D0) --------------------------------------------------------
char __thiscall CGameGuard::CloseNPSC(CGameGuard *this)
{
  const char *v3; // eax
  void *v4; // eax
  const char *v5; // eax
  const char *v6; // eax

  if ( !*((_BYTE *)this + 28) )
    return 1;
  v3 = _Dect1(&`string');
  CLog::Write((CGameGuard *)((char *)this + 32), v3);
  (*((void (__cdecl **)(_DWORD, char *))this + 1185))(*((_DWORD *)this + 1151), (char *)this + 4648);
  v4 = (void *)*((_DWORD *)this + 5);
  *((_BYTE *)this + 28) = 0;
  if ( v4 )
    SetEvent(v4);
  if ( WaitForSingleObject(*((HANDLE *)this + 1161), 0x7D0u) == 258 )
  {
    v5 = _Dect1(&`string');
    CLog::Write((CGameGuard *)((char *)this + 32), v5);
    TerminateThread(*((HANDLE *)this + 1161), 0);
  }
  CloseHandle(*((HANDLE *)this + 1161));
  if ( *((_DWORD *)this + 1160) )
    FreeLibrary(*((HMODULE *)this + 1160));
  *((_DWORD *)this + 1184) = 0;
  *((_DWORD *)this + 1185) = 0;
  v6 = _Dect1(&`string');
  CLog::Write((CGameGuard *)((char *)this + 32), v6);
  return 1;
}

//----- (000039F0) --------------------------------------------------------
DWORD __userpurge SpeedCheckEventThread@<eax>(int a1@<ebx>, LPVOID lpThreadParameter)
{
  DWORD (__stdcall *v2)(HANDLE, DWORD); // edi
  const char *v3; // eax
  unsigned int v5; // [esp-8h] [ebp-10h]
  int v6; // [esp-4h] [ebp-Ch]

  v2 = WaitForSingleObject;
  while ( 1 )
  {
    while ( v2(*((HANDLE *)lpThreadParameter + 5), 0xDE3u) )
    {
      if ( CheckTimeAddr() )
      {
        if ( CheckSocketAddr() )
        {
          if ( CGameGuard::IsDebugger((CGameGuard *)lpThreadParameter) || *((_BYTE *)lpThreadParameter + 29) )
          {
            if ( gg )
            {
              v6 = *((unsigned __int8 *)lpThreadParameter + 29);
              v5 = CGameGuard::IsDebugger((CGameGuard *)lpThreadParameter);
              v3 = _Dect1(&`string');
              CLog::Write((CGameGuard *)((char *)gg + 32), v3, v5, v6);
            }
            CommPipeCallback(a1, (struct CCommPipe *)((char *)lpThreadParameter + 4188), 0x1F4u, 0);
          }
        }
        else
        {
          CCommPipe::SendCommPipe((CCommPipe *)((char *)lpThreadParameter + 4188), 0x8B1u, 0x630u, 0xCu);
        }
      }
      else
      {
        CommPipeCallback(a1, (struct CCommPipe *)((char *)lpThreadParameter + 4188), 0x62Du, 0xAu);
      }
    }
    if ( !*((_BYTE *)lpThreadParameter + 28) )
      break;
    CommPipeCallback(a1, (struct CCommPipe *)((char *)lpThreadParameter + 4188), 0x62Du, 0);
  }
  return 0;
}

//----- (00003AF4) --------------------------------------------------------
int __thiscall CGameGuard::CheckSingleInstance(CGameGuard *this, unsigned int dwMilliseconds)
{
  struct _SECURITY_ATTRIBUTES *v3; // edi
  const CHAR *v4; // eax
  HANDLE (__stdcall *v5)(LPSECURITY_ATTRIBUTES, BOOL, LPCSTR); // ebx
  HANDLE v6; // esi
  const CHAR *v7; // eax
  DWORD (__stdcall *v8)(); // esi
  const char *v9; // eax
  int result; // eax
  DWORD v11; // [esp-4h] [ebp-34h]
  int v12[3]; // [esp+10h] [ebp-20h] BYREF
  char pSecurityDescriptor[20]; // [esp+1Ch] [ebp-14h] BYREF

  v12[0] = 12;
  v12[1] = (int)pSecurityDescriptor;
  v12[2] = 0;
  v3 = 0;
  if ( InitializeSecurityDescriptor(pSecurityDescriptor, 1u) && SetSecurityDescriptorDacl(pSecurityDescriptor, 1, 0, 0) )
    v3 = (struct _SECURITY_ATTRIBUTES *)v12;
  v4 = _Dect1(&`string');
  v5 = CreateMutexA;
  v6 = CreateMutexA(v3, 0, v4);
  if ( v6 || (v7 = _Dect1(&`string'), (v6 = v5(v3, 0, v7)) != 0) )
  {
    if ( GetLastError() == 183 || WaitForSingleObject(v6, dwMilliseconds) == 258 )
    {
      CloseHandle(v6);
      result = 0;
    }
    else
    {
      result = 1;
    }
  }
  else
  {
    v8 = GetLastError;
    GetLastError();
    v11 = v8();
    v9 = _Dect1(&`string');
    CLog::Write((CGameGuard *)((char *)this + 32), v9, v11);
    result = 0;
  }
  return result;
}

//----- (00003C48) --------------------------------------------------------
int __thiscall CGameGuard::CheckGameMonSingleInstance(CGameGuard *this, unsigned int dwMilliseconds)
{
  struct _SECURITY_ATTRIBUTES *v3; // edi
  const CHAR *v4; // eax
  HANDLE (__stdcall *v5)(LPSECURITY_ATTRIBUTES, BOOL, LPCSTR); // ebx
  HANDLE v6; // esi
  const CHAR *v7; // eax
  DWORD (__stdcall *v8)(); // esi
  const char *v9; // eax
  int result; // eax
  const char *v11; // eax
  DWORD v12; // [esp-4h] [ebp-34h]
  int v13[3]; // [esp+10h] [ebp-20h] BYREF
  char pSecurityDescriptor[20]; // [esp+1Ch] [ebp-14h] BYREF

  v13[0] = 12;
  v13[1] = (int)pSecurityDescriptor;
  v13[2] = 0;
  v3 = 0;
  if ( InitializeSecurityDescriptor(pSecurityDescriptor, 1u) && SetSecurityDescriptorDacl(pSecurityDescriptor, 1, 0, 0) )
    v3 = (struct _SECURITY_ATTRIBUTES *)v13;
  v4 = _Dect1(&`string');
  v5 = CreateMutexA;
  v6 = CreateMutexA(v3, 0, v4);
  if ( v6 || (v7 = _Dect1(&`string'), (v6 = v5(v3, 0, v7)) != 0) )
  {
    if ( GetLastError() == 183 && WaitForSingleObject(v6, dwMilliseconds) == 258 )
    {
      v11 = _Dect1(&`string');
      CLog::Write((CGameGuard *)((char *)this + 32), v11);
      CloseHandle(v6);
      result = 0;
    }
    else
    {
      ReleaseMutex(v6);
      CloseHandle(v6);
      result = 1;
    }
  }
  else
  {
    v8 = GetLastError;
    GetLastError();
    v12 = v8();
    v9 = _Dect1(&`string');
    CLog::Write((CGameGuard *)((char *)this + 32), v9, v12);
    result = 0;
  }
  return result;
}

//----- (00003DA8) --------------------------------------------------------
unsigned int __thiscall CGameGuard::IsDebugger(CGameGuard *this)
{
  if ( bEncryptedClientArm )
    return 0;
  if ( *((_BYTE *)this + 4713) )
    return NtCurrentTeb()->ProcessEnvironmentBlock->BeingDebugged;
  return LOBYTE(NtCurrentTeb()->ClientId.UniqueProcess);
}
// 361: using guessed type char bEncryptedClientArm;

//----- (00003DF8) --------------------------------------------------------
bool __userpurge CommPipeCallback@<al>(int a1@<ebx>, struct CCommPipe *a2, unsigned int a3, unsigned int a4)
{
  CGameGuard *v4; // eax
  unsigned int *v5; // edi
  const char *v6; // eax
  unsigned int v7; // esi
  bool v8; // zf
  bool result; // al
  bool v10; // zf
  const char *v11; // eax
  const char *v12; // eax
  const char *v13; // eax
  const char *v14; // eax
  const char *v15; // eax
  unsigned int v16; // [esp-4h] [ebp-Ch]

  v4 = gg;
  v5 = (unsigned int *)a4;
  if ( gg )
  {
    v6 = _Dect1(&`string');
    CLog::Write((CGameGuard *)((char *)gg + 32), v6, a3, a4);
    v4 = gg;
  }
  switch ( a3 )
  {
    case 0x60Fu:
      v7 = 1001;
      v8 = *(_BYTE *)v4 == 0;
      goto LABEL_5;
    case 0x610u:
      v7 = 1002;
      v10 = *(_BYTE *)v4 == 0;
      goto LABEL_8;
    case 0x615u:
      dwWorkingPID = a4;
      if ( dwGameMonPID )
      {
        if ( a4 != dwGameMonPID )
        {
          if ( v4 )
          {
            v16 = dwGameMonPID;
            v15 = _Dect1(&`string');
            CLog::Write((CGameGuard *)((char *)gg + 32), v15, a4, v16);
            v4 = gg;
          }
          nSendErl = 2;
          v7 = 1014;
          v5 = (_DWORD *)&unk_E6;
          v10 = *((_DWORD *)v4 + 1) == 0;
LABEL_8:
          if ( v10 )
          {
            *((_DWORD *)v4 + 2) = v7;
            result = 1;
            *((_DWORD *)gg + 3) = v5;
            return result;
          }
          goto LABEL_14;
        }
      }
      else
      {
        dwGameMonPID = a4;
      }
      if ( CheckVersion((int)szGameMon, 0x7D6u, 4u, 1u, 1u) )
        return 1;
      v4 = gg;
      if ( gg )
      {
        v14 = _Dect1(&`string');
        CLog::Write((CGameGuard *)((char *)gg + 32), v14);
        v4 = gg;
      }
      v7 = 1014;
      v5 = (_DWORD *)&unk_E6;
      v8 = *((_DWORD *)v4 + 1) == 0;
LABEL_5:
      if ( v8 )
      {
        *((_DWORD *)v4 + 2) = v7;
        *((_DWORD *)gg + 3) = v5;
        return 1;
      }
LABEL_14:
      if ( NPGameMonCallback(v7, (unsigned int)v5) )
        return 1;
      if ( gg )
      {
        v12 = _Dect1(&`string');
        CLog::Write((CGameGuard *)((char *)gg + 32), v12, v7, v5);
      }
      *((_BYTE *)gg + 31) = 1;
      return 0;
    case 0x618u:
      if ( a4 < 800 * g_dwLoseAllowFactor )
        return 1;
      GetProcessList(a1);
      GetModuleList(a1);
      if ( gg )
      {
        v11 = _Dect1(&`string');
        CLog::Write((CGameGuard *)((char *)gg + 32), v11, a4);
      }
      v7 = 1001;
      goto LABEL_14;
    case 0x619u:
      v5 = CCommPipe::GetCSAuth2(a2);
      v7 = 1017;
      goto LABEL_14;
    case 0x62Du:
      v7 = 1011;
      goto LABEL_22;
    case 0x62Eu:
      v7 = 1012;
      v8 = *((_DWORD *)v4 + 1) == 0;
      goto LABEL_5;
    case 0x62Fu:
      v7 = 1013;
      v10 = *((_DWORD *)v4 + 1) == 0;
      goto LABEL_8;
    case 0x630u:
      v7 = 1015;
LABEL_22:
      if ( *((_DWORD *)v4 + 1) )
        goto LABEL_14;
      *((_DWORD *)v4 + 2) = v7;
      *((_DWORD *)gg + 3) = a4;
      return 1;
    case 0x637u:
      v7 = 1014;
      v5 = (_DWORD *)&unk_D2;
      v8 = *((_DWORD *)v4 + 1) == 0;
      goto LABEL_5;
    case 0x638u:
      v7 = 1014;
      v5 = (_DWORD *)&unk_DC;
      v10 = *((_DWORD *)v4 + 1) == 0;
      goto LABEL_8;
    case 0x639u:
      v7 = 1014;
      v5 = (_DWORD *)&unk_E6;
      if ( *((_DWORD *)v4 + 1) )
        goto LABEL_14;
      *((_DWORD *)v4 + 2) = 1014;
      result = 1;
      *((_DWORD *)gg + 3) = 230;
      return result;
    case 0x63Au:
      if ( v4 )
      {
        v13 = _Dect1(&`string');
        CLog::Write((CGameGuard *)((char *)gg + 32), v13, a4);
      }
      v7 = 1016;
      goto LABEL_14;
    default:
      if ( a3 == 500 )
      {
        v7 = 1014;
        v5 = (_DWORD *)&unk_1F4;
      }
      else
      {
        v7 = 1000;
      }
      v10 = *((_DWORD *)v4 + 1) == 0;
      goto LABEL_8;
  }
}
// 32C: using guessed type int nSendErl;
// 348: using guessed type int dwWorkingPID;
// 358: using guessed type unsigned int dwGameMonPID;
// 3A4: using guessed type int g_dwLoseAllowFactor;

//----- (000041F0) --------------------------------------------------------
void __thiscall CGameGuard::FtpSendErl(CGameGuard *this)
{
  char *v1; // esi
  const char *v2; // eax
  char v3; // bl
  const CHAR *v4; // eax
  void (*v5)(LPSTR, LPCSTR, ...); // edi
  const CHAR *v6; // eax
  void (__stdcall *v7)(HKEY, LPCSTR, LPDWORD, LPDWORD, LPBYTE, LPDWORD); // ebp
  const CHAR *v8; // eax
  const CHAR *v9; // eax
  void (__stdcall *v10)(HKEY, LPCSTR, DWORD, DWORD, const BYTE *, DWORD); // edi
  const CHAR *v11; // eax
  const char *v12; // eax
  unsigned int v13; // eax
  bool v14; // cc
  void *v15; // eax
  const char *v16; // eax
  signed int v17; // ecx
  char *v18; // eax
  int v19; // edx
  char *v20; // eax
  int v21; // edx
  const char *v22; // eax
  HINSTANCE v23; // eax
  const char *v24; // esi
  HINSTANCE v25; // eax
  const char *v26; // edi
  HINSTANCE v27; // eax
  const char *v28; // ebp
  HINSTANCE v29; // eax
  const char *v30; // eax
  char *v31; // eax
  int v32; // ebx
  char *v33; // eax
  int v34; // esi
  char *v35; // eax
  const char *v36; // eax
  char *v37; // [esp-1Ch] [ebp-2FCh]
  char *v38; // [esp-14h] [ebp-2F4h]
  int v39; // [esp-10h] [ebp-2F0h]
  int v40; // [esp-4h] [ebp-2E4h]
  char *v41; // [esp-4h] [ebp-2E4h]
  int v42; // [esp+0h] [ebp-2E0h]
  int v43; // [esp+0h] [ebp-2E0h]
  int v44; // [esp+4h] [ebp-2DCh]
  int v45; // [esp+4h] [ebp-2DCh]
  int v46; // [esp+8h] [ebp-2D8h]
  char *v47; // [esp+8h] [ebp-2D8h]
  int v48; // [esp+8h] [ebp-2D8h]
  int v49; // [esp+Ch] [ebp-2D4h]
  char *v50; // [esp+Ch] [ebp-2D4h]
  int v51; // [esp+Ch] [ebp-2D4h]
  int v52; // [esp+10h] [ebp-2D0h]
  int v53; // [esp+10h] [ebp-2D0h]
  int v54; // [esp+14h] [ebp-2CCh]
  int v55; // [esp+14h] [ebp-2CCh]
  DWORD v56; // [esp+18h] [ebp-2C8h]
  void *v57; // [esp+18h] [ebp-2C8h]
  char *v58; // [esp+18h] [ebp-2C8h]
  char *v59; // [esp+18h] [ebp-2C8h]
  char *v60; // [esp+18h] [ebp-2C8h]
  char *v61; // [esp+18h] [ebp-2C8h]
  int v62; // [esp+18h] [ebp-2C8h]
  BYTE v63[4]; // [esp+2Ch] [ebp-2B4h] BYREF
  DWORD cbData; // [esp+30h] [ebp-2B0h] BYREF
  HKEY phkResult; // [esp+34h] [ebp-2ACh] BYREF
  DWORD nSize; // [esp+38h] [ebp-2A8h] BYREF
  DWORD NumberOfBytesWritten; // [esp+3Ch] [ebp-2A4h] BYREF
  DWORD dwDisposition; // [esp+40h] [ebp-2A0h] BYREF
  CGameGuard *v69; // [esp+44h] [ebp-29Ch]
  struct _SYSTEMTIME SystemTime; // [esp+48h] [ebp-298h] BYREF
  BYTE Data[64]; // [esp+5Ch] [ebp-284h] BYREF
  CHAR String2[64]; // [esp+9Ch] [ebp-244h] BYREF
  CHAR v73[128]; // [esp+DCh] [ebp-204h] BYREF
  CHAR Buffer[128]; // [esp+15Ch] [ebp-184h] BYREF
  char v75[260]; // [esp+1DCh] [ebp-104h] BYREF

  v69 = this;
  v1 = (char *)this + 32;
  v2 = _Dect1(&`string');
  CLog::Write((CLog *)v1, v2);
  *(_DWORD *)v63 = 0;
  v3 = 0;
  v4 = _Dect1(&`string');
  if ( !RegCreateKeyExA(HKEY_CURRENT_USER, v4, 0, 0, 0, 0xF003Fu, 0, &phkResult, &dwDisposition) )
  {
    v5 = (void (*)(LPSTR, LPCSTR, ...))_wsprintfA;
    if ( dwDisposition == 2 )
    {
      cbData = 64;
      v6 = _Dect1(&`string');
      v7 = (void (__stdcall *)(HKEY, LPCSTR, LPDWORD, LPDWORD, LPBYTE, LPDWORD))RegQueryValueExA;
      RegQueryValueExA(phkResult, v6, 0, 0, Data, &cbData);
      v5(String2, "%hs", "Wed May  3 14:08:04 2006");
      if ( cbData && !lstrcmpA((LPCSTR)Data, String2) )
        v3 = 1;
      cbData = 4;
      v8 = _Dect1(&`string');
      v7(phkResult, v8, 0, 0, v63, &cbData);
    }
    v5((LPSTR)Data, "%hs", "Wed May  3 14:08:04 2006");
    v56 = lstrlenA((LPCSTR)Data) + 1;
    cbData = v56;
    v9 = _Dect1(&`string');
    v10 = (void (__stdcall *)(HKEY, LPCSTR, DWORD, DWORD, const BYTE *, DWORD))RegSetValueExA;
    RegSetValueExA(phkResult, v9, 0, 1u, Data, v56);
    cbData = 4;
    if ( v3 )
      ++*(_DWORD *)v63;
    else
      *(_DWORD *)v63 = 0;
    v11 = _Dect1(&`string');
    v10(phkResult, v11, 0, 4u, v63, 4u);
    RegCloseKey(phkResult);
  }
  if ( *(_DWORD *)v63 != 1 && *(_DWORD *)v63 <= 5u && (!v3 || nSendErl < 9) )
  {
    v12 = _Dect1(&`string');
    CLog::Write((CLog *)v1, v12);
    if ( *(_DWORD *)v1 != -1 )
    {
      GetLocalTime((LPSYSTEMTIME)(v1 + 4124));
      v13 = *((_DWORD *)v1 + 1037);
      if ( !v13 || (v14 = *((_DWORD *)v1 + 1038) <= v13, v15 = &`string', v14) )
        v15 = &`string';
      v57 = v15;
      v54 = *((unsigned __int16 *)v1 + 2069);
      v52 = *((unsigned __int16 *)v1 + 2068);
      v49 = *((unsigned __int16 *)v1 + 2067);
      v46 = *((unsigned __int16 *)v1 + 2066);
      v44 = *((unsigned __int16 *)v1 + 2065);
      v42 = *((unsigned __int16 *)v1 + 2063);
      v40 = *((unsigned __int16 *)v1 + 2062);
      v16 = _Dect(&`string');
      sprintf(v1 + 28, v16, v40, v42, v44, v46, v49, v52, v54, v57);
      v17 = strlen(v1 + 28);
      if ( *((_DWORD *)v1 + 1036) )
      {
        if ( v17 > 0 )
        {
          v18 = v1 + 28;
          do
          {
            v19 = *((_DWORD *)v1 + 1036) + 2;
            *((_DWORD *)v1 + 1036) = v19;
            v3 = (v19 + 67) ^ *v18;
            *v18++ = v3;
          }
          while ( (int)&v18[-28 - (_DWORD)v1] < v17 );
        }
      }
      else if ( v17 > 0 )
      {
        v20 = v1 + 28;
        do
        {
          v21 = 3 * *((_DWORD *)v1 + 1035) + 1;
          *((_DWORD *)v1 + 1035) = v21;
          v3 = (v21 + 118) ^ *v20;
          *v20++ = v3;
        }
        while ( (int)&v20[-28 - (_DWORD)v1] < v17 );
      }
      if ( *((_DWORD *)v1 + 1037) != 999 )
        WriteFile(*(HANDLE *)v1, v1 + 28, v17, &NumberOfBytesWritten, 0);
      SetEndOfFile(*(HANDLE *)v1);
      CloseHandle(*(HANDLE *)v1);
      *(_DWORD *)v1 = -1;
    }
    if ( CSafeAPI::GetModule((CSafeAPI *)&safeWinInet)
      || (v22 = _Dect1(&`string'), CSafeAPI::Init((CSafeAPI *)&safeWinInet, v22)) )
    {
      v58 = _Dect1(&`string');
      v23 = CSafeAPI::GetModule((CSafeAPI *)&safeWinInet);
      v24 = MyGetProcAddress(v3, v23, (int)v58);
      v59 = _Dect1(&`string');
      v25 = CSafeAPI::GetModule((CSafeAPI *)&safeWinInet);
      v26 = MyGetProcAddress(v3, v25, (int)v59);
      v60 = _Dect1(&`string');
      v27 = CSafeAPI::GetModule((CSafeAPI *)&safeWinInet);
      v28 = MyGetProcAddress(v3, v27, (int)v60);
      v61 = _Dect1(&`string');
      v29 = CSafeAPI::GetModule((CSafeAPI *)&safeWinInet);
      v30 = MyGetProcAddress(v3, v29, (int)v61);
      NumberOfBytesWritten = (DWORD)v30;
      if ( v24 )
      {
        if ( v26 )
        {
          if ( v28 )
          {
            if ( v30 )
            {
              v31 = _Dect(&`string');
              v32 = ((int (__stdcall *)(char *, _DWORD, _DWORD, _DWORD, _DWORD))v24)(v31, 0, 0, 0, 0);
              if ( v32 )
              {
                v50 = _Dect1(&`string');
                v47 = _Dect(&`string');
                v33 = _Dect(&`string');
                v34 = ((int (__stdcall *)(int, char *, int, char *, char *, int, int, _DWORD))v26)(
                        v32,
                        v33,
                        6060,
                        v47,
                        v50,
                        1,
                        0x8000000,
                        0);
                if ( v34 )
                {
                  Buffer[0] = 0;
                  nSize = 128;
                  GetComputerNameA(Buffer, &nSize);
                  v73[0] = 0;
                  nSize = 128;
                  GetUserNameA(v73, &nSize);
                  GetLocalTime(&SystemTime);
                  switch ( nSendErl )
                  {
                    case 1:
                      v35 = _Dect(`string');
                      break;
                    case 2:
                      v35 = _Dect(`string');
                      break;
                    case 3:
                      v35 = _Dect(`string');
                      break;
                    case 4:
                      v35 = _Dect(`string');
                      break;
                    case 5:
                      v35 = _Dect(`string');
                      break;
                    case 6:
                      v35 = _Dect(`string');
                      break;
                    case 7:
                      v35 = _Dect(`string');
                      break;
                    case 8:
                      v35 = _Dect(`string');
                      break;
                    case 9:
                      v35 = _Dect(`string');
                      break;
                    default:
                      v35 = _Dect(&`string');
                      break;
                  }
                  v62 = SystemTime.wMilliseconds;
                  v55 = SystemTime.wSecond;
                  v53 = SystemTime.wMinute;
                  v51 = SystemTime.wHour;
                  v48 = SystemTime.wDay;
                  v45 = SystemTime.wMonth;
                  v43 = SystemTime.wYear;
                  v41 = (char *)v69 + 4648;
                  v39 = *((_DWORD *)gg + 4);
                  v38 = v35;
                  v37 = (char *)v69 + 4608;
                  v36 = _Dect1(&`string');
                  _snprintf(v75, 0x104u, v36, v37, 47, v38, v39, Buffer, v73, v41, v43, v45, v48, v51, v53, v55, v62);
                  ((void (__stdcall *)(int, CHAR *, char *, int, _DWORD))NumberOfBytesWritten)(
                    v34,
                    &szLogFile,
                    v75,
                    67108866,
                    0);
                  GetLastError();
                  ((void (__stdcall *)(int))v28)(v32);
                  ((void (__stdcall *)(int))v28)(v34);
                }
                else
                {
                  ((void (__stdcall *)(int))v28)(v32);
                }
              }
            }
          }
        }
      }
    }
  }
}
// 32C: using guessed type int nSendErl;

//----- (00004A18) --------------------------------------------------------
bool __usercall InitToolhelp32@<al>(int a1@<ebx>)
{
  bool result; // al
  const CHAR *v2; // eax
  HMODULE v3; // esi
  char *v4; // eax
  char *v5; // eax
  char *v6; // eax
  char *v7; // eax
  char *v8; // eax

  if ( _bInit__1__InitToolhelp32__YA_NXZ_4_NA )
    return 1;
  v2 = _Dect1(&`string');
  v3 = GetModuleHandleA(v2);
  if ( !v3 )
    return 0;
  v4 = _Dect1(&`string');
  pCreateToolhelp32Snapshot = (void *(__stdcall *)(unsigned int, unsigned int))MyGetProcAddress(a1, v3, (int)v4);
  if ( !pCreateToolhelp32Snapshot )
    return 0;
  v5 = _Dect1(&`string');
  pProcess32First = (int (__stdcall *)(void *, struct tagPROCESSENTRY32 *))MyGetProcAddress(a1, v3, (int)v5);
  if ( !pProcess32First )
    return 0;
  v6 = _Dect1(&`string');
  pProcess32Next = (int (__stdcall *)(void *, struct tagPROCESSENTRY32 *))MyGetProcAddress(a1, v3, (int)v6);
  if ( !pProcess32Next )
    return 0;
  v7 = _Dect1(&`string');
  pModule32First = (int (__stdcall *)(void *, struct tagMODULEENTRY32 *))MyGetProcAddress(a1, v3, (int)v7);
  if ( !pModule32First )
    return 0;
  v8 = _Dect1(&`string');
  pModule32Next = (int (__stdcall *)(void *, struct tagMODULEENTRY32 *))MyGetProcAddress(a1, v3, (int)v8);
  if ( !pModule32Next )
    return 0;
  result = 1;
  _bInit__1__InitToolhelp32__YA_NXZ_4_NA = 1;
  return result;
}
// 0: using guessed type int (__stdcall *pProcess32First)(void *, struct tagPROCESSENTRY32 *);
// 4: using guessed type int (__stdcall *pModule32Next)(void *, struct tagMODULEENTRY32 *);
// 110: using guessed type void *(__stdcall *pCreateToolhelp32Snapshot)(unsigned int, unsigned int);
// 324: using guessed type int (__stdcall *pModule32First)(void *, struct tagMODULEENTRY32 *);
// 328: using guessed type int (__stdcall *pProcess32Next)(void *, struct tagPROCESSENTRY32 *);
// 36C: using guessed type char _bInit__1__InitToolhelp32__YA_NXZ_4_NA;

//----- (00004B7C) --------------------------------------------------------
char __usercall GetProcessList@<al>(int a1@<ebx>)
{
  void *v1; // eax
  void *v2; // esi
  const char *v3; // eax
  const char *v4; // eax
  DWORD v6; // [esp+0h] [ebp-138h]
  DWORD v7; // [esp+4h] [ebp-134h]
  LONG v8; // [esp+8h] [ebp-130h]
  struct tagPROCESSENTRY32 v9; // [esp+10h] [ebp-128h] BYREF

  LOBYTE(v1) = InitToolhelp32(a1);
  if ( (_BYTE)v1 )
  {
    v9.dwSize = 0;
    memset(&v9.cntUsage, 0, 0x124u);
    v1 = pCreateToolhelp32Snapshot(2u, 0);
    v2 = v1;
    if ( v1 != (void *)-1 )
    {
      v9.dwSize = 296;
      if ( pProcess32First(v1, &v9) )
      {
        if ( !gg )
          goto LABEL_8;
        v3 = _Dect1(&`string');
        CLog::Write((CGameGuard *)((char *)gg + 32), v3);
        do
        {
          if ( gg )
          {
            v8 = v9.pcPriClassBase;
            v7 = v9.cntThreads;
            v6 = v9.th32ProcessID;
            v4 = _Dect1(&`string');
            CLog::Write((CGameGuard *)((char *)gg + 32), v4, v9.szExeFile, v6, v7, v8);
          }
LABEL_8:
          ;
        }
        while ( pProcess32Next(v2, &v9) );
      }
      LOBYTE(v1) = CloseHandle(v2);
    }
  }
  return (char)v1;
}
// 0: using guessed type int (__stdcall *pProcess32First)(void *, struct tagPROCESSENTRY32 *);
// 110: using guessed type void *(__stdcall *pCreateToolhelp32Snapshot)(unsigned int, unsigned int);
// 328: using guessed type int (__stdcall *pProcess32Next)(void *, struct tagPROCESSENTRY32 *);

//----- (00004CB4) --------------------------------------------------------
char __usercall GetModuleList@<al>(int a1@<ebx>)
{
  void *v1; // eax
  unsigned int v2; // eax
  void *v3; // esi
  const char *v4; // eax
  const char *v5; // eax
  BYTE *v7; // [esp+0h] [ebp-234h]
  DWORD v8; // [esp+4h] [ebp-230h]
  struct tagMODULEENTRY32 v9; // [esp+10h] [ebp-224h] BYREF

  LOBYTE(v1) = InitToolhelp32(a1);
  if ( (_BYTE)v1 )
  {
    v9.dwSize = 0;
    memset(&v9.th32ModuleID, 0, 0x220u);
    v2 = GetCurrentProcessId();
    v1 = pCreateToolhelp32Snapshot(8u, v2);
    v3 = v1;
    if ( v1 != (void *)-1 )
    {
      v9.dwSize = 548;
      if ( pModule32First(v1, &v9) )
      {
        if ( !gg )
          goto LABEL_8;
        v4 = _Dect1(&`string');
        CLog::Write((CGameGuard *)((char *)gg + 32), v4);
        do
        {
          if ( gg )
          {
            v8 = v9.modBaseSize;
            v7 = v9.modBaseAddr;
            v5 = _Dect1(&`string');
            CLog::Write((CGameGuard *)((char *)gg + 32), v5, v9.szModule, v7, v8, v9.szExePath);
          }
LABEL_8:
          ;
        }
        while ( pModule32Next(v3, &v9) );
      }
      LOBYTE(v1) = CloseHandle(v3);
    }
  }
  return (char)v1;
}
// 4: using guessed type int (__stdcall *pModule32Next)(void *, struct tagMODULEENTRY32 *);
// 110: using guessed type void *(__stdcall *pCreateToolhelp32Snapshot)(unsigned int, unsigned int);
// 324: using guessed type int (__stdcall *pModule32First)(void *, struct tagMODULEENTRY32 *);

//----- (00004DFC) --------------------------------------------------------
LONG __userpurge FvUnhandledExceptionFilter@<eax>(int a1@<ebx>, struct _EXCEPTION_POINTERS *ExceptionInfo)
{
  PEXCEPTION_RECORD v3; // esi
  const char *v4; // eax
  unsigned __int8 *v5; // ebx
  int v6; // edi
  int i; // esi
  const char *v8; // eax
  CGameGuard *v9; // eax
  int v10; // ebx
  const char *v11; // eax
  DWORD v12; // [esp-1Ch] [ebp-9Ch]
  PVOID v13; // [esp-18h] [ebp-98h]
  DWORD v14; // [esp-14h] [ebp-94h]
  int v15; // [esp-10h] [ebp-90h]
  int v16; // [esp-10h] [ebp-90h]
  char Buffer[128]; // [esp+0h] [ebp-80h] BYREF

  if ( _bInException__1__FvUnhandledExceptionFilter__YGJPAU_EXCEPTION_POINTERS___Z_4_NA )
    return 1;
  _bInException__1__FvUnhandledExceptionFilter__YGJPAU_EXCEPTION_POINTERS___Z_4_NA = 1;
  v3 = ExceptionInfo->ExceptionRecord;
  if ( gg )
  {
    v15 = g_dwThreadId;
    v14 = GetCurrentThreadId();
    v13 = v3->ExceptionAddress;
    v12 = v3->ExceptionCode;
    v4 = _Dect1(&`string');
    CLog::Write((CGameGuard *)((char *)gg + 32), v4, v12, v13, v14, v15);
  }
  v5 = (unsigned __int8 *)v3->ExceptionAddress;
  v6 = 0;
  for ( i = 0; i < 32; ++i )
  {
    v16 = v5[i];
    v8 = _Dect(&`string');
    v6 += sprintf(&Buffer[v6], v8, v16);
  }
  v9 = gg;
  Buffer[v6] = 0;
  v10 = a1;
  if ( v9 )
  {
    v11 = _Dect1(&`string');
    CLog::Write((CGameGuard *)((char *)gg + 32), v11, Buffer);
  }
  GetProcessList(v10);
  GetModuleList(v10);
  if ( gg )
  {
    if ( !*(_BYTE *)gg )
    {
      *((_DWORD *)gg + 4) += 10000;
      ExitProcess(0x64u);
    }
  }
  return 0;
}
// 4DFC: could not find valid save-restore pair for ebx
// 334: using guessed type int g_dwThreadId;
// 36D: using guessed type char _bInException__1__FvUnhandledExceptionFilter__YGJPAU_EXCEPTION_POINTERS___Z_4_NA;

//----- (00004F64) --------------------------------------------------------
int __cdecl NPDect(int a1)
{
  return a1;
}

//----- (00004F74) --------------------------------------------------------
int InitTimeAddr()
{
  const CHAR *v0; // eax
  HMODULE (__stdcall *v1)(LPCSTR); // edi
  HMODULE v2; // ebx
  const CHAR *v3; // eax
  HMODULE v4; // ebp
  const CHAR *v5; // eax
  HMODULE v6; // esi
  char *v8; // eax
  const char *v9; // eax
  const char *v10; // eax
  const char *v11; // eax
  char *v12; // eax
  const char *v13; // eax
  const char *v14; // eax
  const char *v15; // eax
  DWORD (__stdcall *v16)(); // esi
  const CHAR *v17; // eax
  HMODULE v18; // edi
  char *v19; // eax
  const char *v20; // eax
  const char *v21; // eax
  const char *v22; // eax
  const char *v23; // [esp-8h] [ebp-1Ch]
  const char *v24; // [esp-8h] [ebp-1Ch]
  const char *v25; // [esp-8h] [ebp-1Ch]
  BOOL (__stdcall *v26)(LARGE_INTEGER *); // [esp-4h] [ebp-18h]
  DWORD (__stdcall *v27)(); // [esp-4h] [ebp-18h]
  int v28; // [esp+10h] [ebp-4h]

  v28 = 0;
  v0 = _Dect1(&`string');
  v1 = GetModuleHandleA;
  v2 = GetModuleHandleA(v0);
  v3 = _Dect1(&`string');
  v4 = v1(v3);
  v5 = _Dect1(&`string');
  v6 = v1(v5);
  if ( !v6 )
    return 2;
  v8 = _Dect1(&`string');
  v9 = MyGetProcAddress((int)v2, v6, (int)v8);
  lpQPC = (int)v9;
  if ( v9 )
  {
    lpQPC2 = (int)QueryPerformanceCounter;
    if ( gg )
    {
      v26 = QueryPerformanceCounter;
      v23 = v9;
      v10 = _Dect1(&`string');
      CLog::Write((CGameGuard *)((char *)gg + 32), v10, v23, v26);
      v9 = (const char *)lpQPC;
    }
    if ( v9 < (const char *)v6 && !v4 && (!v2 || v9 < (const char *)v2) )
    {
      if ( gg )
      {
        v11 = _Dect1(&`string');
        CLog::Write((CGameGuard *)((char *)gg + 32), v11, v6);
      }
      v28 = 1;
    }
  }
  v12 = _Dect1(&`string');
  v13 = MyGetProcAddress((int)v2, v6, (int)v12);
  lpGTC = (int)v13;
  if ( v13 )
  {
    lpGTC2 = (int)GetTickCount;
    if ( gg )
    {
      v27 = GetTickCount;
      v24 = v13;
      v14 = _Dect1(&`string');
      CLog::Write((CGameGuard *)((char *)gg + 32), v14, v24, v27);
      v13 = (const char *)lpGTC;
    }
    if ( v13 < (const char *)v6 && !v4 && (!v2 || lpQPC < (unsigned int)v2) )
    {
      if ( gg )
      {
        v15 = _Dect1(&`string');
        CLog::Write((CGameGuard *)((char *)gg + 32), v15, v6);
      }
      ++v28;
    }
  }
  v16 = timeGetTime;
  timeGetTime();
  v17 = _Dect1(&`string');
  v18 = v1(v17);
  if ( v18 )
  {
    v19 = _Dect1(&`string');
    v20 = MyGetProcAddress((int)v2, v18, (int)v19);
    lpTGT = (int)v20;
    if ( v20 )
    {
      lpTGT2 = (int)v16;
      if ( gg )
      {
        v25 = v20;
        v21 = _Dect1(&`string');
        CLog::Write((CGameGuard *)((char *)gg + 32), v21, v25, v16);
        v20 = (const char *)lpTGT;
      }
      if ( v20 < (const char *)v18 && !v4 && (!v2 || lpQPC < (unsigned int)v2) )
      {
        if ( gg )
        {
          v22 = _Dect1(&`string');
          CLog::Write((CGameGuard *)((char *)gg + 32), v22, v18);
        }
        ++v28;
      }
    }
  }
  bInitTA = 1;
  return v28 == 0;
}
// 370: using guessed type int lpGTC;
// 374: using guessed type int lpQPC;
// 378: using guessed type int lpTGT;
// 384: using guessed type int lpGTC2;
// 388: using guessed type int lpQPC2;
// 38C: using guessed type int lpTGT2;
// 398: using guessed type char bInitTA;

//----- (000052E0) --------------------------------------------------------
int CheckTimeAddr()
{
  int v1; // esi
  const char *v2; // eax
  const char *v3; // eax
  const char *v4; // eax
  BOOL (__stdcall *v5)(LARGE_INTEGER *); // [esp-8h] [ebp-8h]
  DWORD (__stdcall *v6)(); // [esp-8h] [ebp-8h]
  DWORD (__stdcall *v7)(); // [esp-8h] [ebp-8h]

  if ( bEncryptedClient )
    return 1;
  if ( !bInitTA )
    return 2;
  v1 = 0;
  if ( (BOOL (__stdcall *)(LARGE_INTEGER *))lpQPC2 != QueryPerformanceCounter )
  {
    if ( gg )
    {
      v5 = QueryPerformanceCounter;
      v2 = _Dect1(&`string');
      CLog::Write((CGameGuard *)((char *)gg + 32), v2, v5);
    }
    v1 = 1;
  }
  if ( (DWORD (__stdcall *)())lpGTC2 != GetTickCount )
  {
    if ( gg )
    {
      v6 = GetTickCount;
      v3 = _Dect1(&`string');
      CLog::Write((CGameGuard *)((char *)gg + 32), v3, v6);
    }
    ++v1;
  }
  if ( (DWORD (__stdcall *)())lpTGT2 != timeGetTime )
  {
    if ( gg )
    {
      v7 = timeGetTime;
      v4 = _Dect1(&`string');
      CLog::Write((CGameGuard *)((char *)gg + 32), v4, v7);
    }
    ++v1;
  }
  return v1 == 0;
}
// 360: using guessed type char bEncryptedClient;
// 384: using guessed type int lpGTC2;
// 388: using guessed type int lpQPC2;
// 38C: using guessed type int lpTGT2;
// 398: using guessed type char bInitTA;

//----- (000053FC) --------------------------------------------------------
int __usercall InitSocketAddr@<eax>(int a1@<ebx>)
{
  int v1; // edi
  const CHAR *v2; // eax
  HMODULE v3; // esi
  char *v5; // eax
  const char *v6; // eax
  const char *v7; // eax
  const char *v8; // eax
  char *v9; // eax
  const char *v10; // eax
  const char *v11; // eax
  const char *v12; // eax
  const char *v13; // [esp-8h] [ebp-10h]
  const char *v14; // [esp-8h] [ebp-10h]
  int (__stdcall *v15)(SOCKET, LPWSABUF, DWORD, LPDWORD, DWORD, LPWSAOVERLAPPED, LPWSAOVERLAPPED_COMPLETION_ROUTINE); // [esp-4h] [ebp-Ch]
  int (__stdcall *v16)(SOCKET, const char *, int, int); // [esp-4h] [ebp-Ch]

  v1 = 0;
  v2 = _Dect1(&`string');
  v3 = GetModuleHandleA(v2);
  if ( !v3 )
    return 2;
  v5 = _Dect1(&`string');
  v6 = MyGetProcAddress(a1, v3, (int)v5);
  lpWSASend = (int)v6;
  if ( v6 )
  {
    lpWSASend2 = (int)WSASend;
    if ( gg )
    {
      v15 = WSASend;
      v13 = v6;
      v7 = _Dect1(&`string');
      CLog::Write((CGameGuard *)((char *)gg + 32), v7, v13, v15);
      v6 = (const char *)lpWSASend;
    }
    if ( v6 < (const char *)v3 )
    {
      if ( gg )
      {
        v8 = _Dect1(&`string');
        CLog::Write((CGameGuard *)((char *)gg + 32), v8, v3);
      }
      v1 = 1;
    }
  }
  v9 = _Dect1(&`string');
  v10 = MyGetProcAddress(a1, v3, (int)v9);
  lpsend = (int)v10;
  if ( v10 )
  {
    lpsend2 = (int)send;
    if ( gg )
    {
      v16 = send;
      v14 = v10;
      v11 = _Dect1(&`string');
      CLog::Write((CGameGuard *)((char *)gg + 32), v11, v14, v16);
      v10 = (const char *)lpsend;
    }
    if ( v10 < (const char *)v3 )
    {
      if ( gg )
      {
        v12 = _Dect1(&`string');
        CLog::Write((CGameGuard *)((char *)gg + 32), v12, v3);
      }
      ++v1;
    }
  }
  bInitSA = 1;
  return v1 == 0;
}
// 37C: using guessed type int lpWSASend;
// 380: using guessed type int lpsend;
// 390: using guessed type int lpWSASend2;
// 394: using guessed type int lpsend2;
// 399: using guessed type char bInitSA;

//----- (000055DC) --------------------------------------------------------
int CheckSocketAddr()
{
  int v1; // esi
  const char *v2; // eax
  const char *v3; // eax
  int (__stdcall *v4)(SOCKET, LPWSABUF, DWORD, LPDWORD, DWORD, LPWSAOVERLAPPED, LPWSAOVERLAPPED_COMPLETION_ROUTINE); // [esp-8h] [ebp-8h]
  int (__stdcall *v5)(SOCKET, const char *, int, int); // [esp-8h] [ebp-8h]

  if ( !bInitSA )
    return 2;
  v1 = 0;
  if ( (int (__stdcall *)(SOCKET, LPWSABUF, DWORD, LPDWORD, DWORD, LPWSAOVERLAPPED, LPWSAOVERLAPPED_COMPLETION_ROUTINE))lpWSASend2 != WSASend )
  {
    if ( gg )
    {
      v4 = WSASend;
      v2 = _Dect1(&`string');
      CLog::Write((CGameGuard *)((char *)gg + 32), v2, v4);
    }
    v1 = 1;
  }
  if ( (int (__stdcall *)(SOCKET, const char *, int, int))lpsend2 != send )
  {
    if ( gg )
    {
      v5 = send;
      v3 = _Dect1(&`string');
      CLog::Write((CGameGuard *)((char *)gg + 32), v3, v5);
    }
    ++v1;
  }
  return v1 == 0;
}
// 390: using guessed type int lpWSASend2;
// 394: using guessed type int lpsend2;
// 399: using guessed type char bInitSA;

//----- (000056A8) --------------------------------------------------------
int __cdecl EncryptPacket(int a1, int a2)
{
  return PPEncryptClientPacket(a1, a2, &dwClientSequenceNumber);
}
// 7268: using guessed type int __cdecl PPEncryptClientPacket(_DWORD, _DWORD, _DWORD);

//----- (000056C8) --------------------------------------------------------
int __cdecl DecryptPacket(int a1, int a2)
{
  return PPDecryptServerPacket(a1, a2, &dwServerSequenceNumber);
}
// 726C: using guessed type int __cdecl PPDecryptServerPacket(_DWORD, _DWORD, _DWORD);

//----- (000056E8) --------------------------------------------------------
int __cdecl EncryptPeerPacket(int a1, int a2)
{
  return PPEncryptClientPacket(a1, a2, &a2);
}
// 7268: using guessed type int __cdecl PPEncryptClientPacket(_DWORD, _DWORD, _DWORD);

//----- (00005708) --------------------------------------------------------
int __cdecl DecryptPeerPacket(int a1, int a2)
{
  return PPDecryptClientPacket(a1, a2, &a2);
}
// 7270: using guessed type int __cdecl PPDecryptClientPacket(_DWORD, _DWORD, _DWORD);

//----- (00005728) --------------------------------------------------------
char __cdecl CheckGameMonCrc(char *a1, char *a2, int a3)
{
  DWORD (__stdcall *v3)(); // edi
  int v4; // esi
  const char *v5; // eax
  const CHAR *v6; // eax
  LSTATUS v7; // eax
  const CHAR *v8; // eax
  unsigned int v9; // eax
  const char *v10; // eax
  char result; // al
  DWORD v12; // [esp-8h] [ebp-434h]
  const char *v13; // [esp-4h] [ebp-430h]
  const char *v14; // [esp-4h] [ebp-430h]
  unsigned int v15; // [esp+0h] [ebp-42Ch]
  unsigned int v16; // [esp+0h] [ebp-42Ch]
  int v17; // [esp+4h] [ebp-428h]
  LSTATUS v18; // [esp+4h] [ebp-428h]
  unsigned int v19; // [esp+8h] [ebp-424h] BYREF
  BYTE Data[4]; // [esp+Ch] [ebp-420h] BYREF
  HKEY phkResult; // [esp+10h] [ebp-41Ch] BYREF
  DWORD dwDisposition; // [esp+14h] [ebp-418h] BYREF
  DWORD cbData; // [esp+18h] [ebp-414h] BYREF
  char v24[1024]; // [esp+1Ch] [ebp-410h] BYREF
  int v25; // [esp+41Ch] [ebp-10h]
  unsigned int v26[2]; // [esp+420h] [ebp-Ch] BYREF
  int v27; // [esp+428h] [ebp-4h]

  v27 = -1;
  v26[1] = (unsigned int)&_L63583;
  v26[0] = __readfsdword((unsigned int)&_except_list);
  __writefsdword((unsigned int)&_except_list, (unsigned int)v26);
  cbData = 4;
  *(_DWORD *)Data = 0;
  v19 = 1;
  CFvCrc32::CFvCrc32((CFvCrc32 *)v24);
  v27 = 0;
  if ( !CFvCrc32::Crc32File((CFvCrc32 *)v24, a1, &v19) )
  {
    v3 = GetLastError;
    GetLastError();
    if ( gg )
    {
      v4 = v25;
      v12 = v3();
      v5 = _Dect1(&`string');
      CLog::Write((CGameGuard *)((char *)gg + 32), v5, a1, v4, v12);
    }
  }
  v6 = _Dect1(&`string');
  v7 = RegCreateKeyExA(HKEY_CURRENT_USER, v6, 0, 0, 0, 0xF003Fu, 0, &phkResult, &dwDisposition);
  if ( v7 )
  {
    if ( gg )
    {
      v18 = v7;
      v10 = _Dect1(&`string');
      CLog::Write((CGameGuard *)((char *)gg + 32), v10, v18);
    }
    v9 = v19;
  }
  else
  {
    if ( dwDisposition == 2 )
    {
      v8 = _Dect1(a2);
      RegQueryValueExA(phkResult, v8, 0, 0, Data, &cbData);
    }
    RegCloseKey(phkResult);
    v9 = v19;
    if ( v19 != *(_DWORD *)Data )
    {
      if ( gg )
      {
        v17 = *(_DWORD *)Data;
        v15 = v19;
        v13 = _Dect1(&`string');
        CLog::Write((CGameGuard *)((char *)gg + 32), v13, v15, v17);
      }
LABEL_16:
      v27 = -1;
      CFvCrc32::~CFvCrc32((CFvCrc32 *)v24);
      result = 0;
      __writefsdword((unsigned int)&_except_list, v26[0]);
      return result;
    }
  }
  if ( v9 != a3 )
  {
    if ( gg )
    {
      v16 = v9;
      v14 = _Dect1(&`string');
      CLog::Write((CGameGuard *)((char *)gg + 32), v14, v16, a3);
    }
    goto LABEL_16;
  }
  v27 = -1;
  CFvCrc32::~CFvCrc32((CFvCrc32 *)v24);
  result = 1;
  __writefsdword((unsigned int)&_except_list, v26[0]);
  return result;
}

//----- (00005938) --------------------------------------------------------
void __usercall _L63571(int a1@<ebp>)
{
  CFvCrc32::~CFvCrc32((CFvCrc32 *)(a1 - 1040));
}

//----- (00005A14) --------------------------------------------------------
int __cdecl ReadMemCrc(_DWORD *a1)
{
  const CHAR *v1; // eax
  HMODULE v2; // esi
  char *v3; // eax
  const char *v4; // edi
  char *v5; // eax
  const char *v6; // ecx
  int v7; // eax
  char v9[36]; // [esp+14h] [ebp-40h] BYREF
  int v10; // [esp+38h] [ebp-1Ch]

  v1 = _Dect1(&`string');
  v2 = GetModuleHandleA(v1);
  v3 = _Dect1(&`string');
  v4 = MyGetProcAddress(0, v2, (int)v3);
  v5 = _Dect1(&`string');
  v6 = MyGetProcAddress(0, v2, (int)v5);
  v7 = 0;
  if ( v6 )
    v7 = ((int (__stdcall *)(_DWORD, int, char *, int, _DWORD))v6)(*a1, 0x400000, v9, 64, 0);
  if ( v4 )
  {
    if ( v7 )
      return ~v10;
    v7 = ((int (__stdcall *)(_DWORD, int, char *, int, _DWORD))v4)(a1[2], 0x400000, v9, 64, 0);
  }
  if ( v7 )
    return ~v10;
  return 0;
}

//----- (00005B00) --------------------------------------------------------
char __cdecl CheckVersion(int a1, unsigned __int16 a2, unsigned __int16 a3, unsigned __int16 a4, unsigned __int16 a5)
{
  const CHAR *v5; // eax
  HMODULE v6; // ebx
  char *v7; // eax
  const char *v8; // esi
  char *v9; // eax
  const char *v10; // edi
  char *v11; // eax
  const char *v12; // eax
  const char *v13; // ebp
  unsigned int v14; // eax
  unsigned int v15; // esi
  unsigned int v16; // esi
  const char *v17; // eax
  char v19; // [esp+29h] [ebp-11h]
  void *v20; // [esp+2Ah] [ebp-10h]
  int v21; // [esp+2Eh] [ebp-Ch] BYREF
  int v22; // [esp+32h] [ebp-8h] BYREF
  int v23; // [esp+36h] [ebp-4h] BYREF

  v19 = 1;
  v5 = _Dect1(&`string');
  v6 = LoadLibraryA(v5);
  if ( !v6 )
    return 1;
  v7 = _Dect1(&`string');
  v8 = MyGetProcAddress((int)v6, v6, (int)v7);
  v9 = _Dect1(&`string');
  v10 = MyGetProcAddress((int)v6, v6, (int)v9);
  v11 = _Dect1(&`string');
  v12 = MyGetProcAddress((int)v6, v6, (int)v11);
  v13 = v12;
  if ( v8 )
  {
    if ( v10 )
    {
      if ( v12 )
      {
        v14 = ((int (__stdcall *)(int, int *))v8)(a1, &v21);
        v15 = v14;
        if ( v14 )
        {
          v20 = operator new(v14);
          if ( ((int (__stdcall *)(int, int, unsigned int, void *))v10)(a1, v21, v15, v20) )
          {
            ((void (__stdcall *)(void *, const CHAR *, int *, int *))v13)(v20, "\\", &v22, &v23);
            if ( *(_DWORD *)v22 == -17890115 )
            {
              v16 = *(unsigned __int16 *)(v22 + 12)
                  + 100
                  * (HIWORD(*(_DWORD *)(v22 + 12))
                   + 100 * (*(unsigned __int16 *)(v22 + 8) + 100 * HIWORD(*(_DWORD *)(v22 + 8))));
              if ( gg )
              {
                v17 = _Dect1(&`string');
                CLog::Write((CGameGuard *)((char *)gg + 32), v17, a1, v16, a5 + 100 * (a4 + 100 * (a3 + 100 * a2)));
              }
              if ( v16 < a5 + 100 * (a4 + 100 * (a3 + 100 * (unsigned int)a2)) )
                v19 = 0;
            }
          }
          operator delete(v20);
        }
      }
    }
  }
  FreeLibrary(v6);
  return v19;
}

//----- (00005D34) --------------------------------------------------------
const char *__userpurge MyGetProcAddress@<eax>(int a1@<ebx>, void *lp, int a3)
{
  const char *result; // eax
  char *v4; // eax
  int v5; // esi
  _DWORD *v6; // esi
  char *v7; // edi
  int v8; // ecx
  unsigned int v9; // ecx
  _BYTE *v10; // eax
  _DWORD *v11; // eax
  unsigned __int8 *v12; // esi
  unsigned int i; // eax
  unsigned __int8 *v14; // eax
  HMODULE v15; // eax
  int v16; // [esp-10h] [ebp-F8h]
  _DWORD v17[3]; // [esp-Ch] [ebp-F4h] BYREF
  unsigned __int8 Str[128]; // [esp+4h] [ebp-E4h] BYREF
  unsigned __int8 *v19; // [esp+84h] [ebp-64h]
  unsigned __int8 *v20; // [esp+88h] [ebp-60h]
  char v21; // [esp+8Ch] [ebp-5Ch]
  unsigned int v22; // [esp+90h] [ebp-58h]
  char v23; // [esp+94h] [ebp-54h]
  unsigned int v24; // [esp+98h] [ebp-50h]
  _DWORD *v25; // [esp+9Ch] [ebp-4Ch]
  unsigned __int16 *v26; // [esp+A0h] [ebp-48h]
  char *v27; // [esp+A4h] [ebp-44h]
  char *v28; // [esp+A8h] [ebp-40h]
  _DWORD *v29; // [esp+ACh] [ebp-3Ch]
  char *v30; // [esp+B0h] [ebp-38h]
  unsigned int v31; // [esp+B4h] [ebp-34h]
  void *v32; // [esp+B8h] [ebp-30h]
  int v33; // [esp+BCh] [ebp-2Ch]
  _DWORD *v34; // [esp+C0h] [ebp-28h]
  int v35; // [esp+C4h] [ebp-24h]
  const char *v36; // [esp+C8h] [ebp-20h]
  int v37; // [esp+CCh] [ebp-1Ch]
  _DWORD *v38; // [esp+D0h] [ebp-18h]
  unsigned int v39[3]; // [esp+D8h] [ebp-10h] BYREF
  int v40; // [esp+E4h] [ebp-4h]

  v40 = -1;
  v39[2] = (unsigned int)&_T63612;
  v39[1] = (unsigned int)&_except_handler3;
  v39[0] = __readfsdword((unsigned int)&_except_list);
  __writefsdword((unsigned int)&_except_list, (unsigned int)v39);
  v17[2] = a1;
  v38 = v17;
  if ( IsBadReadPtr(lp, 4u) )
  {
    result = 0;
    __writefsdword((unsigned int)&_except_list, v39[0]);
    return result;
  }
  v36 = 0;
  v37 = 0;
  v40 = 0;
  v32 = lp;
  if ( *(_WORD *)lp != 23117 )
    goto LABEL_28;
  v4 = (char *)lp + *((_DWORD *)lp + 15);
  v30 = v4;
  if ( *(_DWORD *)v4 != 17744 )
    goto LABEL_28;
  v33 = 0;
  v35 = 0;
  if ( *((_WORD *)v4 + 12) == 523 )
  {
    v28 = v4;
    v5 = *((_DWORD *)v4 + 34);
    v33 = v5;
    v35 = *((_DWORD *)v4 + 35);
  }
  else
  {
    v33 = *((_DWORD *)v4 + 30);
    v35 = *((_DWORD *)v4 + 31);
    v5 = v33;
  }
  if ( !v5 )
    goto LABEL_28;
  v6 = (char *)lp + v5;
  v29 = v6;
  v31 = 0;
  v7 = (char *)a3;
  if ( (unsigned int)a3 < 0x10000 )
  {
    v31 = a3;
    v8 = a3 - 1;
    goto LABEL_30;
  }
  v9 = 0;
  v24 = 0;
  v10 = (_BYTE *)a3;
  v27 = (char *)a3;
  while ( *v10 )
  {
    v27 = ++v10;
    v24 = ++v9;
    if ( v9 >= 0x100 )
      goto LABEL_28;
  }
  v11 = (char *)lp + v6[8];
  v25 = v11;
  v23 = 0;
  v31 = 0;
  while ( v31 < v6[6] )
  {
    v12 = (unsigned __int8 *)lp + *v11;
    v20 = v12;
    v27 = v7;
    if ( IsBadReadPtr(v12, 4u) )
      goto LABEL_28;
    v21 = 1;
    for ( i = 0; ; ++i )
    {
      v22 = i;
      if ( i >= v24 )
        break;
      if ( *v12 != *v7 )
      {
        v21 = 0;
        break;
      }
      v20 = ++v12;
      v27 = ++v7;
    }
    if ( v21 )
    {
      v23 = 1;
      v6 = v29;
      break;
    }
    ++v25;
    ++v31;
    v7 = (char *)a3;
    v6 = v29;
    v11 = v25;
  }
  if ( !v23 )
  {
LABEL_28:
    v40 = -1;
    result = 0;
    __writefsdword((unsigned int)&_except_list, v39[0]);
    return result;
  }
  v26 = (unsigned __int16 *)((char *)lp + 2 * v31 + v6[9]);
  v8 = *v26;
LABEL_30:
  v31 = v8;
  v34 = (char *)lp + 4 * v8 + v6[7];
  result = (char *)lp + *v34;
  v36 = result;
  if ( result >= (char *)lp + v33 && result < (char *)lp + v33 + v35 )
  {
    strcpy((char *)Str, result);
    v14 = _mbsstr(Str, &`string');
    v19 = v14;
    if ( v14 )
    {
      *v14++ = 0;
      v19 = v14;
    }
    v16 = (int)v14;
    v15 = GetModuleHandleA((LPCSTR)Str);
    result = (const char *)MyGetProcAddress(v15, v16);
    v36 = result;
  }
  __writefsdword((unsigned int)&_except_list, v39[0]);
  return result;
}
// 60A4: using guessed type _SCOPETABLE_ENTRY _T63612;

//----- (000060B0) --------------------------------------------------------
char CheckRsaBase()
{
  char v0; // bl
  const CHAR *v1; // eax
  LSTATUS (__stdcall *v2)(HKEY, LPCSTR, DWORD, REGSAM, PHKEY); // esi
  LSTATUS v3; // eax
  LSTATUS (__stdcall *v4)(HKEY, LPCSTR, LPDWORD, LPDWORD, LPBYTE, LPDWORD); // edi
  const CHAR *v5; // eax
  const char *v6; // eax
  const CHAR *v7; // eax
  const CHAR *v8; // eax
  const char *v9; // eax
  HANDLE v10; // eax
  void *v11; // esi
  const char *v12; // eax
  DWORD v13; // eax
  const char *v14; // eax
  const CHAR *v15; // eax
  HMODULE v16; // ebp
  char *v17; // eax
  const char *v18; // esi
  char *v19; // eax
  const char *v20; // edi
  char *v21; // eax
  const char *v22; // eax
  unsigned int v23; // eax
  unsigned int v24; // esi
  void *v25; // edi
  const char *v26; // eax
  const char *v27; // eax
  const CHAR *v28; // eax
  const char *v29; // eax
  int v31; // [esp+8h] [ebp-2D0h]
  int v32; // [esp+8h] [ebp-2D0h]
  int v33; // [esp+Ch] [ebp-2CCh]
  int v34; // [esp+Ch] [ebp-2CCh]
  int v35; // [esp+10h] [ebp-2C8h]
  DWORD v36; // [esp+10h] [ebp-2C8h]
  int v37; // [esp+10h] [ebp-2C8h]
  int v38; // [esp+14h] [ebp-2C4h]
  DWORD v39; // [esp+14h] [ebp-2C4h]
  int v40; // [esp+14h] [ebp-2C4h]
  BYTE v41; // [esp+28h] [ebp-2B0h] BYREF
  char v42; // [esp+29h] [ebp-2AFh]
  char v43; // [esp+2Ah] [ebp-2AEh]
  char v44; // [esp+2Bh] [ebp-2ADh]
  char v45; // [esp+2Ch] [ebp-2ACh]
  char v46; // [esp+2Dh] [ebp-2ABh]
  char v47; // [esp+2Eh] [ebp-2AAh]
  char v48; // [esp+2Fh] [ebp-2A9h]
  char v49; // [esp+30h] [ebp-2A8h]
  char v50; // [esp+31h] [ebp-2A7h]
  char v51; // [esp+32h] [ebp-2A6h]
  char v52; // [esp+33h] [ebp-2A5h]
  char v53; // [esp+34h] [ebp-2A4h]
  char v54; // [esp+35h] [ebp-2A3h]
  char v55; // [esp+36h] [ebp-2A2h]
  char v56; // [esp+37h] [ebp-2A1h]
  char v57; // [esp+38h] [ebp-2A0h]
  char v58; // [esp+39h] [ebp-29Fh]
  char v59; // [esp+3Ah] [ebp-29Eh]
  char v60; // [esp+3Bh] [ebp-29Dh]
  char v61; // [esp+3Ch] [ebp-29Ch]
  char v62; // [esp+3Dh] [ebp-29Bh]
  char v63; // [esp+3Eh] [ebp-29Ah]
  char v64; // [esp+3Fh] [ebp-299h]
  char v65; // [esp+40h] [ebp-298h]
  char v66; // [esp+41h] [ebp-297h]
  char v67; // [esp+42h] [ebp-296h]
  char v68; // [esp+43h] [ebp-295h]
  char v69; // [esp+44h] [ebp-294h]
  char v70; // [esp+45h] [ebp-293h]
  char v71; // [esp+46h] [ebp-292h]
  char v72; // [esp+47h] [ebp-291h]
  char v73; // [esp+48h] [ebp-290h]
  char v74; // [esp+49h] [ebp-28Fh]
  char v75; // [esp+4Ah] [ebp-28Eh]
  char v76; // [esp+4Bh] [ebp-28Dh]
  char v77; // [esp+4Ch] [ebp-28Ch]
  char v78; // [esp+4Dh] [ebp-28Bh]
  char v79; // [esp+4Eh] [ebp-28Ah]
  char v80; // [esp+4Fh] [ebp-289h]
  char v81; // [esp+50h] [ebp-288h]
  char v82; // [esp+51h] [ebp-287h]
  char v83; // [esp+52h] [ebp-286h]
  char v84; // [esp+53h] [ebp-285h]
  char v85; // [esp+54h] [ebp-284h]
  char v86; // [esp+55h] [ebp-283h]
  char v87; // [esp+56h] [ebp-282h]
  char v88; // [esp+57h] [ebp-281h]
  char v89; // [esp+58h] [ebp-280h]
  char v90; // [esp+59h] [ebp-27Fh]
  char v91; // [esp+5Ah] [ebp-27Eh]
  char v92; // [esp+5Bh] [ebp-27Dh]
  char v93; // [esp+5Ch] [ebp-27Ch]
  char v94; // [esp+5Dh] [ebp-27Bh]
  char v95; // [esp+5Eh] [ebp-27Ah]
  char v96; // [esp+5Fh] [ebp-279h]
  char v97; // [esp+60h] [ebp-278h]
  char v98; // [esp+61h] [ebp-277h]
  char v99; // [esp+62h] [ebp-276h]
  char v100; // [esp+63h] [ebp-275h]
  char v101; // [esp+64h] [ebp-274h]
  char v102; // [esp+65h] [ebp-273h]
  char v103; // [esp+66h] [ebp-272h]
  char v104; // [esp+67h] [ebp-271h]
  char v105; // [esp+68h] [ebp-270h]
  char v106; // [esp+69h] [ebp-26Fh]
  char v107; // [esp+6Ah] [ebp-26Eh]
  char v108; // [esp+6Bh] [ebp-26Dh]
  char v109; // [esp+6Ch] [ebp-26Ch]
  char v110; // [esp+6Dh] [ebp-26Bh]
  char v111; // [esp+6Eh] [ebp-26Ah]
  char v112; // [esp+6Fh] [ebp-269h]
  char v113; // [esp+70h] [ebp-268h]
  char v114; // [esp+71h] [ebp-267h]
  char v115; // [esp+72h] [ebp-266h]
  char v116; // [esp+73h] [ebp-265h]
  char v117; // [esp+74h] [ebp-264h]
  char v118; // [esp+75h] [ebp-263h]
  char v119; // [esp+76h] [ebp-262h]
  char v120; // [esp+77h] [ebp-261h]
  char v121; // [esp+78h] [ebp-260h]
  char v122; // [esp+79h] [ebp-25Fh]
  char v123; // [esp+7Ah] [ebp-25Eh]
  char v124; // [esp+7Bh] [ebp-25Dh]
  char v125; // [esp+7Ch] [ebp-25Ch]
  char v126; // [esp+7Dh] [ebp-25Bh]
  char v127; // [esp+7Eh] [ebp-25Ah]
  char v128; // [esp+7Fh] [ebp-259h]
  char v129; // [esp+80h] [ebp-258h]
  char v130; // [esp+81h] [ebp-257h]
  char v131; // [esp+82h] [ebp-256h]
  char v132; // [esp+83h] [ebp-255h]
  char v133; // [esp+84h] [ebp-254h]
  char v134; // [esp+85h] [ebp-253h]
  char v135; // [esp+86h] [ebp-252h]
  char v136; // [esp+87h] [ebp-251h]
  int v137; // [esp+88h] [ebp-250h]
  char v138; // [esp+8Ch] [ebp-24Ch]
  char v139; // [esp+8Dh] [ebp-24Bh]
  char v140; // [esp+8Eh] [ebp-24Ah]
  char v141; // [esp+8Fh] [ebp-249h]
  int v142; // [esp+90h] [ebp-248h]
  char v143; // [esp+94h] [ebp-244h]
  char v144; // [esp+95h] [ebp-243h]
  char v145; // [esp+96h] [ebp-242h]
  char v146; // [esp+97h] [ebp-241h]
  int v147; // [esp+98h] [ebp-240h]
  char v148; // [esp+9Ch] [ebp-23Ch]
  char v149; // [esp+9Dh] [ebp-23Bh]
  char v150; // [esp+9Eh] [ebp-23Ah]
  char v151; // [esp+9Fh] [ebp-239h]
  char v152; // [esp+A0h] [ebp-238h]
  char v153; // [esp+A1h] [ebp-237h]
  char v154; // [esp+A2h] [ebp-236h]
  char v155; // [esp+A3h] [ebp-235h]
  int v156; // [esp+A4h] [ebp-234h]
  char v157; // [esp+A8h] [ebp-230h]
  char v158; // [esp+A9h] [ebp-22Fh]
  char v159; // [esp+AAh] [ebp-22Eh]
  char v160; // [esp+ABh] [ebp-22Dh]
  char v161; // [esp+ACh] [ebp-22Ch]
  char v162; // [esp+ADh] [ebp-22Bh]
  char v163; // [esp+AEh] [ebp-22Ah]
  char v164; // [esp+AFh] [ebp-229h]
  HKEY phkResult; // [esp+B0h] [ebp-228h] BYREF
  DWORD cbData; // [esp+B4h] [ebp-224h] BYREF
  DWORD v167; // [esp+B8h] [ebp-220h]
  const char *v168; // [esp+BCh] [ebp-21Ch]
  int v169; // [esp+C0h] [ebp-218h] BYREF
  const char *v170; // [esp+C4h] [ebp-214h]
  int v171; // [esp+C8h] [ebp-210h] BYREF
  char v172[4]; // [esp+CCh] [ebp-20Ch] BYREF
  BYTE Data[4]; // [esp+D0h] [ebp-208h] BYREF
  CHAR Buffer[260]; // [esp+1D4h] [ebp-104h] BYREF

  v0 = 0;
  v1 = _Dect1(&`string');
  v2 = RegOpenKeyExA;
  v3 = RegOpenKeyExA(HKEY_LOCAL_MACHINE, v1, 0, 1u, &phkResult);
  v4 = RegQueryValueExA;
  if ( !v3 )
  {
    cbData = 260;
    v5 = _Dect1(&`string');
    if ( !v4(phkResult, v5, 0, 0, Data, &cbData) && gg )
    {
      v6 = _Dect1(&`string');
      CLog::Write((CGameGuard *)((char *)gg + 32), v6, Data);
    }
    RegCloseKey(phkResult);
  }
  v7 = _Dect1(&`string');
  if ( !v2(HKEY_LOCAL_MACHINE, v7, 0, 3u, &phkResult) )
  {
    cbData = 260;
    v8 = _Dect1(&`string');
    if ( !v4(phkResult, v8, 0, 0, Data, &cbData) && gg )
    {
      v38 = Data[3];
      v35 = Data[2];
      v33 = Data[1];
      v31 = Data[0];
      v9 = _Dect1(&`string');
      CLog::Write((CGameGuard *)((char *)gg + 32), v9, v31, v33, v35, v38);
    }
    GetSystemDirectoryA(Buffer, 0x104u);
    strcat(Buffer, _Dect1(&`string'));
    v167 = 0;
    v10 = CreateFileA(Buffer, 0x80000000, 3u, 0, 3u, 0x80u, 0);
    v11 = v10;
    if ( v10 == (HANDLE)-1 )
    {
      if ( gg )
      {
        v36 = GetLastError();
        v12 = _Dect1(&`string');
        CLog::Write((CGameGuard *)((char *)gg + 32), v12, v36, Buffer);
      }
    }
    else
    {
      v13 = GetFileSize(v10, 0);
      v167 = v13;
      if ( gg )
      {
        v39 = v13;
        v14 = _Dect1(&`string');
        CLog::Write((CGameGuard *)((char *)gg + 32), v14, v39);
      }
      CloseHandle(v11);
    }
    v15 = _Dect1(&`string');
    v16 = LoadLibraryA(v15);
    if ( v16 )
    {
      v17 = _Dect1(&`string');
      v18 = MyGetProcAddress(0, v16, (int)v17);
      v19 = _Dect1(&`string');
      v20 = MyGetProcAddress(0, v16, (int)v19);
      v170 = v20;
      v21 = _Dect1(&`string');
      v22 = MyGetProcAddress(0, v16, (int)v21);
      v168 = v22;
      if ( v18 )
      {
        if ( v20 )
        {
          if ( v22 )
          {
            v23 = ((int (__stdcall *)(CHAR *, int *))v18)(Buffer, &v171);
            v24 = v23;
            if ( v23 )
            {
              v25 = operator new(v23);
              ((void (__stdcall *)(CHAR *, int, unsigned int, void *))v170)(Buffer, v171, v24, v25);
              ((void (__stdcall *)(void *, const CHAR *, int *, char *))v168)(v25, "\\", &v169, v172);
              if ( *(_DWORD *)v169 == -17890115 && gg )
              {
                v40 = *(unsigned __int16 *)(v169 + 12);
                v37 = HIWORD(*(_DWORD *)(v169 + 12));
                v34 = *(unsigned __int16 *)(v169 + 8);
                v32 = HIWORD(*(_DWORD *)(v169 + 8));
                v26 = _Dect1(&`string');
                CLog::Write((CGameGuard *)((char *)gg + 32), v26, v32, v34, v37, v40);
              }
              operator delete(v25);
            }
          }
        }
      }
      FreeLibrary(v16);
    }
    if ( v167 == 101648 )
    {
      if ( gg )
      {
        v27 = _Dect1(&`string');
        CLog::Write((CGameGuard *)((char *)gg + 32), v27);
      }
      v42 = -57;
      v58 = -57;
      v92 = -14;
      v79 = 22;
      v96 = -14;
      v109 = 22;
      v41 = 42;
      v43 = 14;
      v44 = 16;
      v45 = 6;
      v46 = -66;
      v47 = -89;
      v48 = -51;
      v49 = -11;
      v50 = -6;
      v51 = 102;
      v52 = 15;
      v53 = -122;
      v54 = -93;
      v55 = -118;
      v56 = 65;
      v57 = 88;
      v59 = -81;
      v60 = 110;
      v61 = -11;
      v62 = -63;
      v63 = -110;
      v64 = 61;
      v65 = -11;
      v66 = 86;
      v67 = -88;
      v68 = -127;
      v69 = 72;
      v70 = 46;
      v71 = -119;
      v72 = 124;
      v73 = 4;
      v74 = 54;
      v75 = 83;
      v76 = -29;
      v77 = 100;
      v78 = 121;
      v80 = 52;
      v81 = 125;
      v82 = -24;
      v83 = -80;
      v84 = -82;
      v85 = -41;
      v86 = 60;
      v87 = -59;
      v88 = -21;
      v89 = 122;
      v90 = 37;
      v91 = 45;
      v93 = -72;
      v94 = -28;
      v95 = -12;
      v97 = -51;
      v98 = -107;
      v99 = 11;
      v100 = -35;
      v101 = 79;
      v102 = 10;
      v103 = -97;
      v104 = 39;
      v105 = 25;
      v106 = -75;
      v107 = -10;
      v108 = 82;
      v110 = 119;
      v111 = 1;
      v112 = 44;
      v113 = -10;
      v114 = -82;
      v115 = -102;
      v139 = -11;
      v116 = -45;
      v117 = 127;
      v118 = -65;
      v119 = 106;
      v120 = 34;
      v121 = -111;
      v122 = 107;
      v123 = -13;
      v124 = -37;
      v125 = -109;
      v126 = 13;
      v127 = 28;
      v128 = -46;
      v129 = 0;
      v130 = -75;
      v131 = -72;
      v132 = 20;
      v133 = 28;
      v134 = 62;
      v135 = -98;
      v136 = -108;
      v137 = -963729029;
      v138 = -124;
      v140 = 43;
      v141 = -6;
      v142 = -1526688331;
      v143 = -107;
      v144 = -78;
      v145 = 101;
      v146 = -116;
      v147 = 7805233;
      v148 = -51;
      v149 = 91;
      v150 = 78;
      v151 = -110;
      v152 = 104;
      v153 = -28;
      v154 = 66;
      v155 = 102;
      v156 = -1814776553;
      v157 = 0;
      v158 = 0;
      v159 = 0;
      v160 = 0;
      v161 = 0;
      v162 = 0;
      v163 = 0;
      v164 = 0;
      v28 = _Dect1(`string');
    }
    else
    {
      if ( v167 != 94480 )
      {
LABEL_35:
        RegCloseKey(phkResult);
        return v0;
      }
      if ( gg )
      {
        v29 = _Dect1(&`string');
        CLog::Write((CGameGuard *)((char *)gg + 32), v29);
      }
      v60 = 7;
      v81 = 7;
      v88 = 7;
      v41 = 95;
      v42 = 113;
      v43 = 105;
      v44 = 83;
      v45 = -118;
      v46 = -114;
      v47 = 84;
      v48 = -84;
      v49 = 9;
      v50 = 63;
      v51 = 101;
      v52 = 90;
      v53 = 38;
      v54 = -115;
      v55 = 119;
      v56 = 21;
      v57 = -98;
      v58 = 104;
      v59 = -69;
      v61 = -19;
      v62 = -113;
      v63 = -16;
      v64 = -73;
      v65 = -15;
      v66 = -103;
      v67 = 5;
      v68 = 21;
      v69 = 0x80;
      v70 = 100;
      v71 = -88;
      v72 = -40;
      v73 = -121;
      v74 = -61;
      v75 = 88;
      v76 = -87;
      v77 = -50;
      v78 = 38;
      v79 = -2;
      v80 = -77;
      v82 = -41;
      v83 = -93;
      v84 = -127;
      v85 = -66;
      v86 = -72;
      v87 = 110;
      v89 = 21;
      v90 = 104;
      v91 = 68;
      v92 = 23;
      v93 = -66;
      v94 = -127;
      v95 = 0x80;
      v96 = 117;
      v97 = -95;
      v98 = -37;
      v99 = -85;
      v100 = 33;
      v101 = -47;
      v102 = 31;
      v103 = -68;
      v104 = -100;
      v105 = 29;
      v106 = 73;
      v107 = -16;
      v108 = -27;
      v109 = -35;
      v110 = 73;
      v111 = 127;
      v112 = -75;
      v113 = -28;
      v114 = 9;
      v115 = -16;
      v116 = 57;
      v117 = -108;
      v131 = 32;
      v156 = 98602528;
      v118 = 42;
      v140 = 42;
      v119 = 107;
      v120 = -125;
      v121 = 15;
      v122 = -37;
      v123 = 86;
      v124 = 14;
      v125 = -93;
      v126 = 97;
      v127 = -97;
      v128 = 18;
      v129 = -44;
      v130 = -41;
      v132 = -112;
      v133 = 84;
      v134 = -101;
      v135 = -58;
      v136 = -103;
      v137 = -721206260;
      v138 = 27;
      v139 = -102;
      v141 = -96;
      v142 = -165901150;
      v143 = 104;
      v144 = -91;
      v145 = 87;
      v146 = 46;
      v147 = -1884995567;
      v148 = 119;
      v149 = 113;
      v150 = -20;
      v151 = 106;
      v152 = 105;
      v153 = -96;
      v154 = -53;
      v155 = 30;
      v157 = 0;
      v158 = 0;
      v159 = 0;
      v160 = 0;
      v161 = 0;
      v162 = 0;
      v163 = 0;
      v164 = 0;
      v28 = _Dect1(&`string');
    }
    RegSetValueExA(phkResult, v28, 0, 3u, &v41, 0x88u);
    v0 = 1;
    goto LABEL_35;
  }
  return v0;
}

//----- (00006CA8) --------------------------------------------------------
char RemoveCompatibleMode()
{
  size_t v0; // eax
  unsigned __int8 *v1; // eax
  const CHAR *v2; // eax
  LSTATUS (__stdcall *v3)(HKEY, DWORD, LPSTR, LPDWORD, LPDWORD, LPDWORD, LPBYTE, LPDWORD); // ebx
  int v4; // ebp
  LSTATUS i; // eax
  unsigned __int8 *v6; // eax
  const char *v7; // eax
  DWORD v9; // [esp-28h] [ebp-56Ch]
  char v10; // [esp+7h] [ebp-53Dh]
  HKEY phkResult; // [esp+8h] [ebp-53Ch] BYREF
  DWORD cchValueName; // [esp+Ch] [ebp-538h] BYREF
  BYTE Data[32]; // [esp+10h] [ebp-534h] BYREF
  CHAR ValueName[260]; // [esp+30h] [ebp-514h] BYREF
  CHAR MultiByteStr[260]; // [esp+134h] [ebp-410h] BYREF
  unsigned __int8 String[260]; // [esp+238h] [ebp-30Ch] BYREF
  WCHAR Filename[260]; // [esp+33Ch] [ebp-208h] BYREF

  v10 = 0;
  GetModuleFileNameW(0, Filename, 0x104u);
  v0 = wcslen(Filename);
  WideCharToMultiByte(0, 0, Filename, v0 + 1, MultiByteStr, 260, 0, 0);
  v1 = _mbsrchr((const unsigned __int8 *)MultiByteStr, 0x5Cu);
  if ( v1 )
    *v1 = 0;
  v2 = _Dect1(&`string');
  if ( RegOpenKeyExA(HKEY_CURRENT_USER, v2, 0, 3u, &phkResult) )
    return 0;
  v3 = RegEnumValueA;
  cchValueName = 260;
  v4 = 1;
  for ( i = RegEnumValueA(phkResult, 0, ValueName, &cchValueName, 0, 0, 0, 0);
        i != 259;
        i = v3(phkResult, v9, ValueName, &cchValueName, 0, 0, 0, 0) )
  {
    if ( !i )
    {
      strcpy((char *)String, ValueName);
      v6 = _mbsrchr(String, 0x5Cu);
      if ( v6 )
        *v6 = 0;
      if ( !_mbsicmp(String, (const unsigned __int8 *)MultiByteStr)
        && !RegQueryValueExA(phkResult, ValueName, 0, 0, Data, &cchValueName) )
      {
        if ( gg )
        {
          v7 = _Dect1(&`string');
          CLog::Write((CGameGuard *)((char *)gg + 32), v7, Data);
        }
        if ( !RegDeleteValueA(phkResult, ValueName) )
          v10 = 1;
      }
    }
    v9 = v4;
    cchValueName = 260;
    ++v4;
  }
  RegCloseKey(phkResult);
  return v10;
}

//----- (00006EF8) --------------------------------------------------------
char __cdecl DisableCompatibleMode(BYTE Data)
{
  char v1; // bl
  const CHAR *v2; // eax
  const CHAR *v3; // eax
  HKEY phkResult; // [esp+4h] [ebp-4h] BYREF

  v1 = 0;
  v2 = _Dect1(&`string');
  if ( !RegOpenKeyExA(HKEY_LOCAL_MACHINE, v2, 0, 0xF003Fu, &phkResult) )
  {
    v3 = _Dect1(&`string');
    if ( !RegSetValueExA(phkResult, v3, 0, 4u, &Data, 4u) )
      v1 = 1;
    RegCloseKey(phkResult);
  }
  return v1;
}

//----- (00006FC8) --------------------------------------------------------
HMODULE CheckEncryptedClient()
{
  HMODULE result; // eax
  HMODULE v1; // esi
  HMODULE v2; // edx
  HMODULE v3; // ecx

  result = GetModuleHandleA(0);
  if ( *(_WORD *)result == 23117 )
  {
    if ( *((_DWORD *)result + 13) )
    {
      if ( *((_DWORD *)result + 14) )
      {
        bEncryptedClient = 1;
        if ( !*((_DWORD *)result + 12) )
          bEncryptedClientArm = 1;
      }
    }
    v1 = (HMODULE)*((_DWORD *)result + 14);
    if ( v1 )
    {
      v2 = (HMODULE)*((_DWORD *)result + 13);
      if ( v2 )
      {
        result = (HMODULE)*((_DWORD *)result + 12);
        if ( result )
        {
          if ( v2 <= v1 )
            v3 = (HMODULE)((char *)v1 - (char *)v2);
          else
            v3 = (HMODULE)((char *)v2 - (char *)v1);
          if ( result == v3 || v2 == v1 && result == v2 )
            bEncryptedClientArm = 1;
        }
      }
    }
  }
  return result;
}
// 360: using guessed type char bEncryptedClient;
// 361: using guessed type char bEncryptedClientArm;

//----- (00007038) --------------------------------------------------------
CNPDword *__thiscall CNPDword::CNPDword(CNPDword *this)
{
  *(_DWORD *)this = VirtualAlloc(0, 4u, 0x1000u, 4u);
  return this;
}

//----- (00007058) --------------------------------------------------------
void __thiscall CNPDword::~CNPDword(CNPDword *this)
{
  VirtualFree(*(LPVOID *)this, 4u, 0x4000u);
}

//----- (00007078) --------------------------------------------------------
void __thiscall CNPDword::Guard(CNPDword *this)
{
  DWORD flOldProtect; // [esp+0h] [ebp-4h] BYREF

  flOldProtect = (DWORD)this;
  VirtualProtect(*(LPVOID *)this, 4u, 2u, &flOldProtect);
}

//----- (00007098) --------------------------------------------------------
void __thiscall CNPDword::Release(CNPDword *this)
{
  DWORD flOldProtect; // [esp+0h] [ebp-4h] BYREF

  flOldProtect = (DWORD)this;
  VirtualProtect(*(LPVOID *)this, 4u, 4u, &flOldProtect);
}

//----- (000070B8) --------------------------------------------------------
void __thiscall CNPDword::Set(CNPDword *this, unsigned int a2)
{
  CNPDword::Release(this);
  **(_DWORD **)this = a2;
  CNPDword::Guard(this);
}

//----- (000070D8) --------------------------------------------------------
unsigned int __thiscall CNPDword::Get(CNPDword *this)
{
  return **(_DWORD **)this;
}

// nfuncs=178 queued=69 decompiled=69 lumina nreq=0 worse=0 better=0
// ALL OK, 69 function(s) have been successfully decompiled
